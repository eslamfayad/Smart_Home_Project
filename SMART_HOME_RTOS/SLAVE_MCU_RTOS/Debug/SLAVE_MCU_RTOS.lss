
SLAVE_MCU_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006962  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000c6  00800060  00006962  000069f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000388  00800126  00800126  00006abc  2**0
                  ALLOC
  3 .stab         000079e0  00000000  00000000  00006abc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003779  00000000  00000000  0000e49c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00011c15  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00011d55  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00011ec5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00013b0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  000149f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000157a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00015908  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00015b95  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00016363  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 3c 0c 	jmp	0x1878	; 0x1878 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e6       	ldi	r30, 0x62	; 98
      68:	f9 e6       	ldi	r31, 0x69	; 105
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 32       	cpi	r26, 0x26	; 38
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a6 e2       	ldi	r26, 0x26	; 38
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3a       	cpi	r26, 0xAE	; 174
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 63 33 	call	0x66c6	; 0x66c6 <main>
      8a:	0c 94 af 34 	jmp	0x695e	; 0x695e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 6f 34 	jmp	0x68de	; 0x68de <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a8 e1       	ldi	r26, 0x18	; 24
     128:	b1 e0       	ldi	r27, 0x01	; 1
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 8b 34 	jmp	0x6916	; 0x6916 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 7b 34 	jmp	0x68f6	; 0x68f6 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 97 34 	jmp	0x692e	; 0x692e <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 7b 34 	jmp	0x68f6	; 0x68f6 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 97 34 	jmp	0x692e	; 0x692e <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 6f 34 	jmp	0x68de	; 0x68de <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	88 e1       	ldi	r24, 0x18	; 24
     496:	91 e0       	ldi	r25, 0x01	; 1
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 8b 34 	jmp	0x6916	; 0x6916 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 7b 34 	jmp	0x68f6	; 0x68f6 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 97 34 	jmp	0x692e	; 0x692e <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 7b 34 	jmp	0x68f6	; 0x68f6 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 97 34 	jmp	0x692e	; 0x692e <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 7b 34 	jmp	0x68f6	; 0x68f6 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 97 34 	jmp	0x692e	; 0x692e <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 7f 34 	jmp	0x68fe	; 0x68fe <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 9b 34 	jmp	0x6936	; 0x6936 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
     b4e:	2a 97       	sbiw	r28, 0x0a	; 10
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	de bf       	out	0x3e, r29	; 62
     b56:	0f be       	out	0x3f, r0	; 63
     b58:	cd bf       	out	0x3d, r28	; 61
     b5a:	9a 87       	std	Y+10, r25	; 0x0a
     b5c:	89 87       	std	Y+9, r24	; 0x09
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     b5e:	1a 82       	std	Y+2, r1	; 0x02
     b60:	19 82       	std	Y+1, r1	; 0x01

	vTaskSuspendAll();
     b62:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     b66:	80 91 26 01 	lds	r24, 0x0126
     b6a:	90 91 27 01 	lds	r25, 0x0127
     b6e:	00 97       	sbiw	r24, 0x00	; 0
     b70:	11 f4       	brne	.+4      	; 0xb76 <pvPortMalloc+0x30>
		{
			prvHeapInit();
     b72:	0e 94 1a 07 	call	0xe34	; 0xe34 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     b76:	80 91 2c 01 	lds	r24, 0x012C
     b7a:	90 91 2d 01 	lds	r25, 0x012D
     b7e:	29 85       	ldd	r18, Y+9	; 0x09
     b80:	3a 85       	ldd	r19, Y+10	; 0x0a
     b82:	82 23       	and	r24, r18
     b84:	93 23       	and	r25, r19
     b86:	00 97       	sbiw	r24, 0x00	; 0
     b88:	09 f0       	breq	.+2      	; 0xb8c <pvPortMalloc+0x46>
     b8a:	c5 c0       	rjmp	.+394    	; 0xd16 <pvPortMalloc+0x1d0>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     b8c:	89 85       	ldd	r24, Y+9	; 0x09
     b8e:	9a 85       	ldd	r25, Y+10	; 0x0a
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	51 f0       	breq	.+20     	; 0xba8 <pvPortMalloc+0x62>
			{
				xWantedSize += xHeapStructSize;
     b94:	80 91 24 01 	lds	r24, 0x0124
     b98:	90 91 25 01 	lds	r25, 0x0125
     b9c:	29 85       	ldd	r18, Y+9	; 0x09
     b9e:	3a 85       	ldd	r19, Y+10	; 0x0a
     ba0:	82 0f       	add	r24, r18
     ba2:	93 1f       	adc	r25, r19
     ba4:	9a 87       	std	Y+10, r25	; 0x0a
     ba6:	89 87       	std	Y+9, r24	; 0x09
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     ba8:	89 85       	ldd	r24, Y+9	; 0x09
     baa:	9a 85       	ldd	r25, Y+10	; 0x0a
     bac:	00 97       	sbiw	r24, 0x00	; 0
     bae:	09 f4       	brne	.+2      	; 0xbb2 <pvPortMalloc+0x6c>
     bb0:	b2 c0       	rjmp	.+356    	; 0xd16 <pvPortMalloc+0x1d0>
     bb2:	20 91 28 01 	lds	r18, 0x0128
     bb6:	30 91 29 01 	lds	r19, 0x0129
     bba:	89 85       	ldd	r24, Y+9	; 0x09
     bbc:	9a 85       	ldd	r25, Y+10	; 0x0a
     bbe:	28 17       	cp	r18, r24
     bc0:	39 07       	cpc	r19, r25
     bc2:	08 f4       	brcc	.+2      	; 0xbc6 <pvPortMalloc+0x80>
     bc4:	a8 c0       	rjmp	.+336    	; 0xd16 <pvPortMalloc+0x1d0>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     bc6:	8e e4       	ldi	r24, 0x4E	; 78
     bc8:	94 e0       	ldi	r25, 0x04	; 4
     bca:	9e 83       	std	Y+6, r25	; 0x06
     bcc:	8d 83       	std	Y+5, r24	; 0x05
				pxBlock = xStart.pxNextFreeBlock;
     bce:	80 91 4e 04 	lds	r24, 0x044E
     bd2:	90 91 4f 04 	lds	r25, 0x044F
     bd6:	98 87       	std	Y+8, r25	; 0x08
     bd8:	8f 83       	std	Y+7, r24	; 0x07
     bda:	0a c0       	rjmp	.+20     	; 0xbf0 <pvPortMalloc+0xaa>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
				{
					pxPreviousBlock = pxBlock;
     bdc:	8f 81       	ldd	r24, Y+7	; 0x07
     bde:	98 85       	ldd	r25, Y+8	; 0x08
     be0:	9e 83       	std	Y+6, r25	; 0x06
     be2:	8d 83       	std	Y+5, r24	; 0x05
					pxBlock = pxBlock->pxNextFreeBlock;
     be4:	ef 81       	ldd	r30, Y+7	; 0x07
     be6:	f8 85       	ldd	r31, Y+8	; 0x08
     be8:	80 81       	ld	r24, Z
     bea:	91 81       	ldd	r25, Z+1	; 0x01
     bec:	98 87       	std	Y+8, r25	; 0x08
     bee:	8f 83       	std	Y+7, r24	; 0x07
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     bf0:	ef 81       	ldd	r30, Y+7	; 0x07
     bf2:	f8 85       	ldd	r31, Y+8	; 0x08
     bf4:	22 81       	ldd	r18, Z+2	; 0x02
     bf6:	33 81       	ldd	r19, Z+3	; 0x03
     bf8:	89 85       	ldd	r24, Y+9	; 0x09
     bfa:	9a 85       	ldd	r25, Y+10	; 0x0a
     bfc:	28 17       	cp	r18, r24
     bfe:	39 07       	cpc	r19, r25
     c00:	30 f4       	brcc	.+12     	; 0xc0e <pvPortMalloc+0xc8>
     c02:	ef 81       	ldd	r30, Y+7	; 0x07
     c04:	f8 85       	ldd	r31, Y+8	; 0x08
     c06:	80 81       	ld	r24, Z
     c08:	91 81       	ldd	r25, Z+1	; 0x01
     c0a:	00 97       	sbiw	r24, 0x00	; 0
     c0c:	39 f7       	brne	.-50     	; 0xbdc <pvPortMalloc+0x96>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     c0e:	20 91 26 01 	lds	r18, 0x0126
     c12:	30 91 27 01 	lds	r19, 0x0127
     c16:	8f 81       	ldd	r24, Y+7	; 0x07
     c18:	98 85       	ldd	r25, Y+8	; 0x08
     c1a:	82 17       	cp	r24, r18
     c1c:	93 07       	cpc	r25, r19
     c1e:	09 f4       	brne	.+2      	; 0xc22 <pvPortMalloc+0xdc>
     c20:	7a c0       	rjmp	.+244    	; 0xd16 <pvPortMalloc+0x1d0>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     c22:	ed 81       	ldd	r30, Y+5	; 0x05
     c24:	fe 81       	ldd	r31, Y+6	; 0x06
     c26:	20 81       	ld	r18, Z
     c28:	31 81       	ldd	r19, Z+1	; 0x01
     c2a:	80 91 24 01 	lds	r24, 0x0124
     c2e:	90 91 25 01 	lds	r25, 0x0125
     c32:	82 0f       	add	r24, r18
     c34:	93 1f       	adc	r25, r19
     c36:	9a 83       	std	Y+2, r25	; 0x02
     c38:	89 83       	std	Y+1, r24	; 0x01

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     c3a:	ef 81       	ldd	r30, Y+7	; 0x07
     c3c:	f8 85       	ldd	r31, Y+8	; 0x08
     c3e:	80 81       	ld	r24, Z
     c40:	91 81       	ldd	r25, Z+1	; 0x01
     c42:	ed 81       	ldd	r30, Y+5	; 0x05
     c44:	fe 81       	ldd	r31, Y+6	; 0x06
     c46:	91 83       	std	Z+1, r25	; 0x01
     c48:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     c4a:	ef 81       	ldd	r30, Y+7	; 0x07
     c4c:	f8 85       	ldd	r31, Y+8	; 0x08
     c4e:	22 81       	ldd	r18, Z+2	; 0x02
     c50:	33 81       	ldd	r19, Z+3	; 0x03
     c52:	89 85       	ldd	r24, Y+9	; 0x09
     c54:	9a 85       	ldd	r25, Y+10	; 0x0a
     c56:	28 1b       	sub	r18, r24
     c58:	39 0b       	sbc	r19, r25
     c5a:	80 91 24 01 	lds	r24, 0x0124
     c5e:	90 91 25 01 	lds	r25, 0x0125
     c62:	88 0f       	add	r24, r24
     c64:	99 1f       	adc	r25, r25
     c66:	82 17       	cp	r24, r18
     c68:	93 07       	cpc	r25, r19
     c6a:	00 f5       	brcc	.+64     	; 0xcac <pvPortMalloc+0x166>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     c6c:	2f 81       	ldd	r18, Y+7	; 0x07
     c6e:	38 85       	ldd	r19, Y+8	; 0x08
     c70:	89 85       	ldd	r24, Y+9	; 0x09
     c72:	9a 85       	ldd	r25, Y+10	; 0x0a
     c74:	82 0f       	add	r24, r18
     c76:	93 1f       	adc	r25, r19
     c78:	9c 83       	std	Y+4, r25	; 0x04
     c7a:	8b 83       	std	Y+3, r24	; 0x03
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     c7c:	ef 81       	ldd	r30, Y+7	; 0x07
     c7e:	f8 85       	ldd	r31, Y+8	; 0x08
     c80:	22 81       	ldd	r18, Z+2	; 0x02
     c82:	33 81       	ldd	r19, Z+3	; 0x03
     c84:	89 85       	ldd	r24, Y+9	; 0x09
     c86:	9a 85       	ldd	r25, Y+10	; 0x0a
     c88:	a9 01       	movw	r20, r18
     c8a:	48 1b       	sub	r20, r24
     c8c:	59 0b       	sbc	r21, r25
     c8e:	ca 01       	movw	r24, r20
     c90:	eb 81       	ldd	r30, Y+3	; 0x03
     c92:	fc 81       	ldd	r31, Y+4	; 0x04
     c94:	93 83       	std	Z+3, r25	; 0x03
     c96:	82 83       	std	Z+2, r24	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     c98:	ef 81       	ldd	r30, Y+7	; 0x07
     c9a:	f8 85       	ldd	r31, Y+8	; 0x08
     c9c:	89 85       	ldd	r24, Y+9	; 0x09
     c9e:	9a 85       	ldd	r25, Y+10	; 0x0a
     ca0:	93 83       	std	Z+3, r25	; 0x03
     ca2:	82 83       	std	Z+2, r24	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     ca4:	8b 81       	ldd	r24, Y+3	; 0x03
     ca6:	9c 81       	ldd	r25, Y+4	; 0x04
     ca8:	0e 94 93 07 	call	0xf26	; 0xf26 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     cac:	20 91 28 01 	lds	r18, 0x0128
     cb0:	30 91 29 01 	lds	r19, 0x0129
     cb4:	ef 81       	ldd	r30, Y+7	; 0x07
     cb6:	f8 85       	ldd	r31, Y+8	; 0x08
     cb8:	82 81       	ldd	r24, Z+2	; 0x02
     cba:	93 81       	ldd	r25, Z+3	; 0x03
     cbc:	a9 01       	movw	r20, r18
     cbe:	48 1b       	sub	r20, r24
     cc0:	59 0b       	sbc	r21, r25
     cc2:	ca 01       	movw	r24, r20
     cc4:	90 93 29 01 	sts	0x0129, r25
     cc8:	80 93 28 01 	sts	0x0128, r24

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     ccc:	20 91 28 01 	lds	r18, 0x0128
     cd0:	30 91 29 01 	lds	r19, 0x0129
     cd4:	80 91 2a 01 	lds	r24, 0x012A
     cd8:	90 91 2b 01 	lds	r25, 0x012B
     cdc:	28 17       	cp	r18, r24
     cde:	39 07       	cpc	r19, r25
     ce0:	40 f4       	brcc	.+16     	; 0xcf2 <pvPortMalloc+0x1ac>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     ce2:	80 91 28 01 	lds	r24, 0x0128
     ce6:	90 91 29 01 	lds	r25, 0x0129
     cea:	90 93 2b 01 	sts	0x012B, r25
     cee:	80 93 2a 01 	sts	0x012A, r24
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     cf2:	ef 81       	ldd	r30, Y+7	; 0x07
     cf4:	f8 85       	ldd	r31, Y+8	; 0x08
     cf6:	22 81       	ldd	r18, Z+2	; 0x02
     cf8:	33 81       	ldd	r19, Z+3	; 0x03
     cfa:	80 91 2c 01 	lds	r24, 0x012C
     cfe:	90 91 2d 01 	lds	r25, 0x012D
     d02:	82 2b       	or	r24, r18
     d04:	93 2b       	or	r25, r19
     d06:	ef 81       	ldd	r30, Y+7	; 0x07
     d08:	f8 85       	ldd	r31, Y+8	; 0x08
     d0a:	93 83       	std	Z+3, r25	; 0x03
     d0c:	82 83       	std	Z+2, r24	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     d0e:	ef 81       	ldd	r30, Y+7	; 0x07
     d10:	f8 85       	ldd	r31, Y+8	; 0x08
     d12:	11 82       	std	Z+1, r1	; 0x01
     d14:	10 82       	st	Z, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     d16:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
		}
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
     d1a:	89 81       	ldd	r24, Y+1	; 0x01
     d1c:	9a 81       	ldd	r25, Y+2	; 0x02
}
     d1e:	2a 96       	adiw	r28, 0x0a	; 10
     d20:	0f b6       	in	r0, 0x3f	; 63
     d22:	f8 94       	cli
     d24:	de bf       	out	0x3e, r29	; 62
     d26:	0f be       	out	0x3f, r0	; 63
     d28:	cd bf       	out	0x3d, r28	; 61
     d2a:	cf 91       	pop	r28
     d2c:	df 91       	pop	r29
     d2e:	08 95       	ret

00000d30 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     d30:	df 93       	push	r29
     d32:	cf 93       	push	r28
     d34:	00 d0       	rcall	.+0      	; 0xd36 <vPortFree+0x6>
     d36:	00 d0       	rcall	.+0      	; 0xd38 <vPortFree+0x8>
     d38:	00 d0       	rcall	.+0      	; 0xd3a <vPortFree+0xa>
     d3a:	cd b7       	in	r28, 0x3d	; 61
     d3c:	de b7       	in	r29, 0x3e	; 62
     d3e:	9e 83       	std	Y+6, r25	; 0x06
     d40:	8d 83       	std	Y+5, r24	; 0x05
uint8_t *puc = ( uint8_t * ) pv;
     d42:	8d 81       	ldd	r24, Y+5	; 0x05
     d44:	9e 81       	ldd	r25, Y+6	; 0x06
     d46:	9c 83       	std	Y+4, r25	; 0x04
     d48:	8b 83       	std	Y+3, r24	; 0x03
BlockLink_t *pxLink;

	if( pv != NULL )
     d4a:	8d 81       	ldd	r24, Y+5	; 0x05
     d4c:	9e 81       	ldd	r25, Y+6	; 0x06
     d4e:	00 97       	sbiw	r24, 0x00	; 0
     d50:	09 f4       	brne	.+2      	; 0xd54 <vPortFree+0x24>
     d52:	4a c0       	rjmp	.+148    	; 0xde8 <vPortFree+0xb8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     d54:	80 91 24 01 	lds	r24, 0x0124
     d58:	90 91 25 01 	lds	r25, 0x0125
     d5c:	22 27       	eor	r18, r18
     d5e:	33 27       	eor	r19, r19
     d60:	28 1b       	sub	r18, r24
     d62:	39 0b       	sbc	r19, r25
     d64:	8b 81       	ldd	r24, Y+3	; 0x03
     d66:	9c 81       	ldd	r25, Y+4	; 0x04
     d68:	82 0f       	add	r24, r18
     d6a:	93 1f       	adc	r25, r19
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	9c 81       	ldd	r25, Y+4	; 0x04
     d74:	9a 83       	std	Y+2, r25	; 0x02
     d76:	89 83       	std	Y+1, r24	; 0x01

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     d78:	e9 81       	ldd	r30, Y+1	; 0x01
     d7a:	fa 81       	ldd	r31, Y+2	; 0x02
     d7c:	22 81       	ldd	r18, Z+2	; 0x02
     d7e:	33 81       	ldd	r19, Z+3	; 0x03
     d80:	80 91 2c 01 	lds	r24, 0x012C
     d84:	90 91 2d 01 	lds	r25, 0x012D
     d88:	82 23       	and	r24, r18
     d8a:	93 23       	and	r25, r19
     d8c:	00 97       	sbiw	r24, 0x00	; 0
     d8e:	61 f1       	breq	.+88     	; 0xde8 <vPortFree+0xb8>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     d90:	e9 81       	ldd	r30, Y+1	; 0x01
     d92:	fa 81       	ldd	r31, Y+2	; 0x02
     d94:	80 81       	ld	r24, Z
     d96:	91 81       	ldd	r25, Z+1	; 0x01
     d98:	00 97       	sbiw	r24, 0x00	; 0
     d9a:	31 f5       	brne	.+76     	; 0xde8 <vPortFree+0xb8>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     d9c:	e9 81       	ldd	r30, Y+1	; 0x01
     d9e:	fa 81       	ldd	r31, Y+2	; 0x02
     da0:	22 81       	ldd	r18, Z+2	; 0x02
     da2:	33 81       	ldd	r19, Z+3	; 0x03
     da4:	80 91 2c 01 	lds	r24, 0x012C
     da8:	90 91 2d 01 	lds	r25, 0x012D
     dac:	80 95       	com	r24
     dae:	90 95       	com	r25
     db0:	82 23       	and	r24, r18
     db2:	93 23       	and	r25, r19
     db4:	e9 81       	ldd	r30, Y+1	; 0x01
     db6:	fa 81       	ldd	r31, Y+2	; 0x02
     db8:	93 83       	std	Z+3, r25	; 0x03
     dba:	82 83       	std	Z+2, r24	; 0x02

				vTaskSuspendAll();
     dbc:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     dc0:	e9 81       	ldd	r30, Y+1	; 0x01
     dc2:	fa 81       	ldd	r31, Y+2	; 0x02
     dc4:	22 81       	ldd	r18, Z+2	; 0x02
     dc6:	33 81       	ldd	r19, Z+3	; 0x03
     dc8:	80 91 28 01 	lds	r24, 0x0128
     dcc:	90 91 29 01 	lds	r25, 0x0129
     dd0:	82 0f       	add	r24, r18
     dd2:	93 1f       	adc	r25, r19
     dd4:	90 93 29 01 	sts	0x0129, r25
     dd8:	80 93 28 01 	sts	0x0128, r24
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     ddc:	89 81       	ldd	r24, Y+1	; 0x01
     dde:	9a 81       	ldd	r25, Y+2	; 0x02
     de0:	0e 94 93 07 	call	0xf26	; 0xf26 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     de4:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     de8:	26 96       	adiw	r28, 0x06	; 6
     dea:	0f b6       	in	r0, 0x3f	; 63
     dec:	f8 94       	cli
     dee:	de bf       	out	0x3e, r29	; 62
     df0:	0f be       	out	0x3f, r0	; 63
     df2:	cd bf       	out	0x3d, r28	; 61
     df4:	cf 91       	pop	r28
     df6:	df 91       	pop	r29
     df8:	08 95       	ret

00000dfa <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     dfa:	df 93       	push	r29
     dfc:	cf 93       	push	r28
     dfe:	cd b7       	in	r28, 0x3d	; 61
     e00:	de b7       	in	r29, 0x3e	; 62
	return xFreeBytesRemaining;
     e02:	80 91 28 01 	lds	r24, 0x0128
     e06:	90 91 29 01 	lds	r25, 0x0129
}
     e0a:	cf 91       	pop	r28
     e0c:	df 91       	pop	r29
     e0e:	08 95       	ret

00000e10 <xPortGetMinimumEverFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetMinimumEverFreeHeapSize( void )
{
     e10:	df 93       	push	r29
     e12:	cf 93       	push	r28
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62
	return xMinimumEverFreeBytesRemaining;
     e18:	80 91 2a 01 	lds	r24, 0x012A
     e1c:	90 91 2b 01 	lds	r25, 0x012B
}
     e20:	cf 91       	pop	r28
     e22:	df 91       	pop	r29
     e24:	08 95       	ret

00000e26 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     e26:	df 93       	push	r29
     e28:	cf 93       	push	r28
     e2a:	cd b7       	in	r28, 0x3d	; 61
     e2c:	de b7       	in	r29, 0x3e	; 62
	/* This just exists to keep the linker quiet. */
}
     e2e:	cf 91       	pop	r28
     e30:	df 91       	pop	r29
     e32:	08 95       	ret

00000e34 <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
     e34:	df 93       	push	r29
     e36:	cf 93       	push	r28
     e38:	cd b7       	in	r28, 0x3d	; 61
     e3a:	de b7       	in	r29, 0x3e	; 62
     e3c:	28 97       	sbiw	r28, 0x08	; 8
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	f8 94       	cli
     e42:	de bf       	out	0x3e, r29	; 62
     e44:	0f be       	out	0x3f, r0	; 63
     e46:	cd bf       	out	0x3d, r28	; 61
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
     e48:	80 e2       	ldi	r24, 0x20	; 32
     e4a:	93 e0       	ldi	r25, 0x03	; 3
     e4c:	9a 83       	std	Y+2, r25	; 0x02
     e4e:	89 83       	std	Y+1, r24	; 0x01

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
     e50:	8e e2       	ldi	r24, 0x2E	; 46
     e52:	91 e0       	ldi	r25, 0x01	; 1
     e54:	9c 83       	std	Y+4, r25	; 0x04
     e56:	8b 83       	std	Y+3, r24	; 0x03
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
     e58:	8b 81       	ldd	r24, Y+3	; 0x03
     e5a:	9c 81       	ldd	r25, Y+4	; 0x04
     e5c:	9e 83       	std	Y+6, r25	; 0x06
     e5e:	8d 83       	std	Y+5, r24	; 0x05

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     e60:	8d 81       	ldd	r24, Y+5	; 0x05
     e62:	9e 81       	ldd	r25, Y+6	; 0x06
     e64:	90 93 4f 04 	sts	0x044F, r25
     e68:	80 93 4e 04 	sts	0x044E, r24
	xStart.xBlockSize = ( size_t ) 0;
     e6c:	10 92 51 04 	sts	0x0451, r1
     e70:	10 92 50 04 	sts	0x0450, r1

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
     e74:	2d 81       	ldd	r18, Y+5	; 0x05
     e76:	3e 81       	ldd	r19, Y+6	; 0x06
     e78:	89 81       	ldd	r24, Y+1	; 0x01
     e7a:	9a 81       	ldd	r25, Y+2	; 0x02
     e7c:	82 0f       	add	r24, r18
     e7e:	93 1f       	adc	r25, r19
     e80:	9c 83       	std	Y+4, r25	; 0x04
     e82:	8b 83       	std	Y+3, r24	; 0x03
	uxAddress -= xHeapStructSize;
     e84:	20 91 24 01 	lds	r18, 0x0124
     e88:	30 91 25 01 	lds	r19, 0x0125
     e8c:	8b 81       	ldd	r24, Y+3	; 0x03
     e8e:	9c 81       	ldd	r25, Y+4	; 0x04
     e90:	82 1b       	sub	r24, r18
     e92:	93 0b       	sbc	r25, r19
     e94:	9c 83       	std	Y+4, r25	; 0x04
     e96:	8b 83       	std	Y+3, r24	; 0x03
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     e98:	8b 81       	ldd	r24, Y+3	; 0x03
     e9a:	9c 81       	ldd	r25, Y+4	; 0x04
     e9c:	90 93 27 01 	sts	0x0127, r25
     ea0:	80 93 26 01 	sts	0x0126, r24
	pxEnd->xBlockSize = 0;
     ea4:	e0 91 26 01 	lds	r30, 0x0126
     ea8:	f0 91 27 01 	lds	r31, 0x0127
     eac:	13 82       	std	Z+3, r1	; 0x03
     eae:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     eb0:	e0 91 26 01 	lds	r30, 0x0126
     eb4:	f0 91 27 01 	lds	r31, 0x0127
     eb8:	11 82       	std	Z+1, r1	; 0x01
     eba:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
     ebc:	8d 81       	ldd	r24, Y+5	; 0x05
     ebe:	9e 81       	ldd	r25, Y+6	; 0x06
     ec0:	98 87       	std	Y+8, r25	; 0x08
     ec2:	8f 83       	std	Y+7, r24	; 0x07
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     ec4:	2f 81       	ldd	r18, Y+7	; 0x07
     ec6:	38 85       	ldd	r19, Y+8	; 0x08
     ec8:	8b 81       	ldd	r24, Y+3	; 0x03
     eca:	9c 81       	ldd	r25, Y+4	; 0x04
     ecc:	82 1b       	sub	r24, r18
     ece:	93 0b       	sbc	r25, r19
     ed0:	ef 81       	ldd	r30, Y+7	; 0x07
     ed2:	f8 85       	ldd	r31, Y+8	; 0x08
     ed4:	93 83       	std	Z+3, r25	; 0x03
     ed6:	82 83       	std	Z+2, r24	; 0x02
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     ed8:	80 91 26 01 	lds	r24, 0x0126
     edc:	90 91 27 01 	lds	r25, 0x0127
     ee0:	ef 81       	ldd	r30, Y+7	; 0x07
     ee2:	f8 85       	ldd	r31, Y+8	; 0x08
     ee4:	91 83       	std	Z+1, r25	; 0x01
     ee6:	80 83       	st	Z, r24

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     ee8:	ef 81       	ldd	r30, Y+7	; 0x07
     eea:	f8 85       	ldd	r31, Y+8	; 0x08
     eec:	82 81       	ldd	r24, Z+2	; 0x02
     eee:	93 81       	ldd	r25, Z+3	; 0x03
     ef0:	90 93 2b 01 	sts	0x012B, r25
     ef4:	80 93 2a 01 	sts	0x012A, r24
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     ef8:	ef 81       	ldd	r30, Y+7	; 0x07
     efa:	f8 85       	ldd	r31, Y+8	; 0x08
     efc:	82 81       	ldd	r24, Z+2	; 0x02
     efe:	93 81       	ldd	r25, Z+3	; 0x03
     f00:	90 93 29 01 	sts	0x0129, r25
     f04:	80 93 28 01 	sts	0x0128, r24

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     f08:	80 e0       	ldi	r24, 0x00	; 0
     f0a:	90 e8       	ldi	r25, 0x80	; 128
     f0c:	90 93 2d 01 	sts	0x012D, r25
     f10:	80 93 2c 01 	sts	0x012C, r24
}
     f14:	28 96       	adiw	r28, 0x08	; 8
     f16:	0f b6       	in	r0, 0x3f	; 63
     f18:	f8 94       	cli
     f1a:	de bf       	out	0x3e, r29	; 62
     f1c:	0f be       	out	0x3f, r0	; 63
     f1e:	cd bf       	out	0x3d, r28	; 61
     f20:	cf 91       	pop	r28
     f22:	df 91       	pop	r29
     f24:	08 95       	ret

00000f26 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     f26:	df 93       	push	r29
     f28:	cf 93       	push	r28
     f2a:	00 d0       	rcall	.+0      	; 0xf2c <prvInsertBlockIntoFreeList+0x6>
     f2c:	00 d0       	rcall	.+0      	; 0xf2e <prvInsertBlockIntoFreeList+0x8>
     f2e:	00 d0       	rcall	.+0      	; 0xf30 <prvInsertBlockIntoFreeList+0xa>
     f30:	cd b7       	in	r28, 0x3d	; 61
     f32:	de b7       	in	r29, 0x3e	; 62
     f34:	9e 83       	std	Y+6, r25	; 0x06
     f36:	8d 83       	std	Y+5, r24	; 0x05
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     f38:	8e e4       	ldi	r24, 0x4E	; 78
     f3a:	94 e0       	ldi	r25, 0x04	; 4
     f3c:	9c 83       	std	Y+4, r25	; 0x04
     f3e:	8b 83       	std	Y+3, r24	; 0x03
     f40:	06 c0       	rjmp	.+12     	; 0xf4e <prvInsertBlockIntoFreeList+0x28>
     f42:	eb 81       	ldd	r30, Y+3	; 0x03
     f44:	fc 81       	ldd	r31, Y+4	; 0x04
     f46:	80 81       	ld	r24, Z
     f48:	91 81       	ldd	r25, Z+1	; 0x01
     f4a:	9c 83       	std	Y+4, r25	; 0x04
     f4c:	8b 83       	std	Y+3, r24	; 0x03
     f4e:	eb 81       	ldd	r30, Y+3	; 0x03
     f50:	fc 81       	ldd	r31, Y+4	; 0x04
     f52:	20 81       	ld	r18, Z
     f54:	31 81       	ldd	r19, Z+1	; 0x01
     f56:	8d 81       	ldd	r24, Y+5	; 0x05
     f58:	9e 81       	ldd	r25, Y+6	; 0x06
     f5a:	28 17       	cp	r18, r24
     f5c:	39 07       	cpc	r19, r25
     f5e:	88 f3       	brcs	.-30     	; 0xf42 <prvInsertBlockIntoFreeList+0x1c>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
     f60:	8b 81       	ldd	r24, Y+3	; 0x03
     f62:	9c 81       	ldd	r25, Y+4	; 0x04
     f64:	9a 83       	std	Y+2, r25	; 0x02
     f66:	89 83       	std	Y+1, r24	; 0x01
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     f68:	eb 81       	ldd	r30, Y+3	; 0x03
     f6a:	fc 81       	ldd	r31, Y+4	; 0x04
     f6c:	22 81       	ldd	r18, Z+2	; 0x02
     f6e:	33 81       	ldd	r19, Z+3	; 0x03
     f70:	89 81       	ldd	r24, Y+1	; 0x01
     f72:	9a 81       	ldd	r25, Y+2	; 0x02
     f74:	28 0f       	add	r18, r24
     f76:	39 1f       	adc	r19, r25
     f78:	8d 81       	ldd	r24, Y+5	; 0x05
     f7a:	9e 81       	ldd	r25, Y+6	; 0x06
     f7c:	28 17       	cp	r18, r24
     f7e:	39 07       	cpc	r19, r25
     f80:	91 f4       	brne	.+36     	; 0xfa6 <prvInsertBlockIntoFreeList+0x80>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     f82:	eb 81       	ldd	r30, Y+3	; 0x03
     f84:	fc 81       	ldd	r31, Y+4	; 0x04
     f86:	22 81       	ldd	r18, Z+2	; 0x02
     f88:	33 81       	ldd	r19, Z+3	; 0x03
     f8a:	ed 81       	ldd	r30, Y+5	; 0x05
     f8c:	fe 81       	ldd	r31, Y+6	; 0x06
     f8e:	82 81       	ldd	r24, Z+2	; 0x02
     f90:	93 81       	ldd	r25, Z+3	; 0x03
     f92:	82 0f       	add	r24, r18
     f94:	93 1f       	adc	r25, r19
     f96:	eb 81       	ldd	r30, Y+3	; 0x03
     f98:	fc 81       	ldd	r31, Y+4	; 0x04
     f9a:	93 83       	std	Z+3, r25	; 0x03
     f9c:	82 83       	std	Z+2, r24	; 0x02
		pxBlockToInsert = pxIterator;
     f9e:	8b 81       	ldd	r24, Y+3	; 0x03
     fa0:	9c 81       	ldd	r25, Y+4	; 0x04
     fa2:	9e 83       	std	Y+6, r25	; 0x06
     fa4:	8d 83       	std	Y+5, r24	; 0x05
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
     fa6:	8d 81       	ldd	r24, Y+5	; 0x05
     fa8:	9e 81       	ldd	r25, Y+6	; 0x06
     faa:	9a 83       	std	Y+2, r25	; 0x02
     fac:	89 83       	std	Y+1, r24	; 0x01
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     fae:	ed 81       	ldd	r30, Y+5	; 0x05
     fb0:	fe 81       	ldd	r31, Y+6	; 0x06
     fb2:	22 81       	ldd	r18, Z+2	; 0x02
     fb4:	33 81       	ldd	r19, Z+3	; 0x03
     fb6:	89 81       	ldd	r24, Y+1	; 0x01
     fb8:	9a 81       	ldd	r25, Y+2	; 0x02
     fba:	28 0f       	add	r18, r24
     fbc:	39 1f       	adc	r19, r25
     fbe:	eb 81       	ldd	r30, Y+3	; 0x03
     fc0:	fc 81       	ldd	r31, Y+4	; 0x04
     fc2:	80 81       	ld	r24, Z
     fc4:	91 81       	ldd	r25, Z+1	; 0x01
     fc6:	28 17       	cp	r18, r24
     fc8:	39 07       	cpc	r19, r25
     fca:	89 f5       	brne	.+98     	; 0x102e <prvInsertBlockIntoFreeList+0x108>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     fcc:	eb 81       	ldd	r30, Y+3	; 0x03
     fce:	fc 81       	ldd	r31, Y+4	; 0x04
     fd0:	20 81       	ld	r18, Z
     fd2:	31 81       	ldd	r19, Z+1	; 0x01
     fd4:	80 91 26 01 	lds	r24, 0x0126
     fd8:	90 91 27 01 	lds	r25, 0x0127
     fdc:	28 17       	cp	r18, r24
     fde:	39 07       	cpc	r19, r25
     fe0:	e9 f0       	breq	.+58     	; 0x101c <prvInsertBlockIntoFreeList+0xf6>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     fe2:	ed 81       	ldd	r30, Y+5	; 0x05
     fe4:	fe 81       	ldd	r31, Y+6	; 0x06
     fe6:	22 81       	ldd	r18, Z+2	; 0x02
     fe8:	33 81       	ldd	r19, Z+3	; 0x03
     fea:	eb 81       	ldd	r30, Y+3	; 0x03
     fec:	fc 81       	ldd	r31, Y+4	; 0x04
     fee:	01 90       	ld	r0, Z+
     ff0:	f0 81       	ld	r31, Z
     ff2:	e0 2d       	mov	r30, r0
     ff4:	82 81       	ldd	r24, Z+2	; 0x02
     ff6:	93 81       	ldd	r25, Z+3	; 0x03
     ff8:	82 0f       	add	r24, r18
     ffa:	93 1f       	adc	r25, r19
     ffc:	ed 81       	ldd	r30, Y+5	; 0x05
     ffe:	fe 81       	ldd	r31, Y+6	; 0x06
    1000:	93 83       	std	Z+3, r25	; 0x03
    1002:	82 83       	std	Z+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1004:	eb 81       	ldd	r30, Y+3	; 0x03
    1006:	fc 81       	ldd	r31, Y+4	; 0x04
    1008:	01 90       	ld	r0, Z+
    100a:	f0 81       	ld	r31, Z
    100c:	e0 2d       	mov	r30, r0
    100e:	80 81       	ld	r24, Z
    1010:	91 81       	ldd	r25, Z+1	; 0x01
    1012:	ed 81       	ldd	r30, Y+5	; 0x05
    1014:	fe 81       	ldd	r31, Y+6	; 0x06
    1016:	91 83       	std	Z+1, r25	; 0x01
    1018:	80 83       	st	Z, r24
    101a:	11 c0       	rjmp	.+34     	; 0x103e <prvInsertBlockIntoFreeList+0x118>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    101c:	80 91 26 01 	lds	r24, 0x0126
    1020:	90 91 27 01 	lds	r25, 0x0127
    1024:	ed 81       	ldd	r30, Y+5	; 0x05
    1026:	fe 81       	ldd	r31, Y+6	; 0x06
    1028:	91 83       	std	Z+1, r25	; 0x01
    102a:	80 83       	st	Z, r24
    102c:	08 c0       	rjmp	.+16     	; 0x103e <prvInsertBlockIntoFreeList+0x118>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    102e:	eb 81       	ldd	r30, Y+3	; 0x03
    1030:	fc 81       	ldd	r31, Y+4	; 0x04
    1032:	80 81       	ld	r24, Z
    1034:	91 81       	ldd	r25, Z+1	; 0x01
    1036:	ed 81       	ldd	r30, Y+5	; 0x05
    1038:	fe 81       	ldd	r31, Y+6	; 0x06
    103a:	91 83       	std	Z+1, r25	; 0x01
    103c:	80 83       	st	Z, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    103e:	2b 81       	ldd	r18, Y+3	; 0x03
    1040:	3c 81       	ldd	r19, Y+4	; 0x04
    1042:	8d 81       	ldd	r24, Y+5	; 0x05
    1044:	9e 81       	ldd	r25, Y+6	; 0x06
    1046:	28 17       	cp	r18, r24
    1048:	39 07       	cpc	r19, r25
    104a:	31 f0       	breq	.+12     	; 0x1058 <prvInsertBlockIntoFreeList+0x132>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    104c:	eb 81       	ldd	r30, Y+3	; 0x03
    104e:	fc 81       	ldd	r31, Y+4	; 0x04
    1050:	8d 81       	ldd	r24, Y+5	; 0x05
    1052:	9e 81       	ldd	r25, Y+6	; 0x06
    1054:	91 83       	std	Z+1, r25	; 0x01
    1056:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    1058:	26 96       	adiw	r28, 0x06	; 6
    105a:	0f b6       	in	r0, 0x3f	; 63
    105c:	f8 94       	cli
    105e:	de bf       	out	0x3e, r29	; 62
    1060:	0f be       	out	0x3f, r0	; 63
    1062:	cd bf       	out	0x3d, r28	; 61
    1064:	cf 91       	pop	r28
    1066:	df 91       	pop	r29
    1068:	08 95       	ret

0000106a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    106a:	df 93       	push	r29
    106c:	cf 93       	push	r28
    106e:	00 d0       	rcall	.+0      	; 0x1070 <vListInitialise+0x6>
    1070:	cd b7       	in	r28, 0x3d	; 61
    1072:	de b7       	in	r29, 0x3e	; 62
    1074:	9a 83       	std	Y+2, r25	; 0x02
    1076:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1078:	89 81       	ldd	r24, Y+1	; 0x01
    107a:	9a 81       	ldd	r25, Y+2	; 0x02
    107c:	03 96       	adiw	r24, 0x03	; 3
    107e:	e9 81       	ldd	r30, Y+1	; 0x01
    1080:	fa 81       	ldd	r31, Y+2	; 0x02
    1082:	92 83       	std	Z+2, r25	; 0x02
    1084:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1086:	e9 81       	ldd	r30, Y+1	; 0x01
    1088:	fa 81       	ldd	r31, Y+2	; 0x02
    108a:	8f ef       	ldi	r24, 0xFF	; 255
    108c:	9f ef       	ldi	r25, 0xFF	; 255
    108e:	94 83       	std	Z+4, r25	; 0x04
    1090:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1092:	89 81       	ldd	r24, Y+1	; 0x01
    1094:	9a 81       	ldd	r25, Y+2	; 0x02
    1096:	03 96       	adiw	r24, 0x03	; 3
    1098:	e9 81       	ldd	r30, Y+1	; 0x01
    109a:	fa 81       	ldd	r31, Y+2	; 0x02
    109c:	96 83       	std	Z+6, r25	; 0x06
    109e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    10a0:	89 81       	ldd	r24, Y+1	; 0x01
    10a2:	9a 81       	ldd	r25, Y+2	; 0x02
    10a4:	03 96       	adiw	r24, 0x03	; 3
    10a6:	e9 81       	ldd	r30, Y+1	; 0x01
    10a8:	fa 81       	ldd	r31, Y+2	; 0x02
    10aa:	90 87       	std	Z+8, r25	; 0x08
    10ac:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    10ae:	e9 81       	ldd	r30, Y+1	; 0x01
    10b0:	fa 81       	ldd	r31, Y+2	; 0x02
    10b2:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    10b4:	0f 90       	pop	r0
    10b6:	0f 90       	pop	r0
    10b8:	cf 91       	pop	r28
    10ba:	df 91       	pop	r29
    10bc:	08 95       	ret

000010be <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    10be:	df 93       	push	r29
    10c0:	cf 93       	push	r28
    10c2:	00 d0       	rcall	.+0      	; 0x10c4 <vListInitialiseItem+0x6>
    10c4:	cd b7       	in	r28, 0x3d	; 61
    10c6:	de b7       	in	r29, 0x3e	; 62
    10c8:	9a 83       	std	Y+2, r25	; 0x02
    10ca:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    10cc:	e9 81       	ldd	r30, Y+1	; 0x01
    10ce:	fa 81       	ldd	r31, Y+2	; 0x02
    10d0:	11 86       	std	Z+9, r1	; 0x09
    10d2:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    10d4:	0f 90       	pop	r0
    10d6:	0f 90       	pop	r0
    10d8:	cf 91       	pop	r28
    10da:	df 91       	pop	r29
    10dc:	08 95       	ret

000010de <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    10de:	df 93       	push	r29
    10e0:	cf 93       	push	r28
    10e2:	00 d0       	rcall	.+0      	; 0x10e4 <vListInsertEnd+0x6>
    10e4:	00 d0       	rcall	.+0      	; 0x10e6 <vListInsertEnd+0x8>
    10e6:	00 d0       	rcall	.+0      	; 0x10e8 <vListInsertEnd+0xa>
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	9c 83       	std	Y+4, r25	; 0x04
    10ee:	8b 83       	std	Y+3, r24	; 0x03
    10f0:	7e 83       	std	Y+6, r23	; 0x06
    10f2:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    10f4:	eb 81       	ldd	r30, Y+3	; 0x03
    10f6:	fc 81       	ldd	r31, Y+4	; 0x04
    10f8:	81 81       	ldd	r24, Z+1	; 0x01
    10fa:	92 81       	ldd	r25, Z+2	; 0x02
    10fc:	9a 83       	std	Y+2, r25	; 0x02
    10fe:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1100:	ed 81       	ldd	r30, Y+5	; 0x05
    1102:	fe 81       	ldd	r31, Y+6	; 0x06
    1104:	89 81       	ldd	r24, Y+1	; 0x01
    1106:	9a 81       	ldd	r25, Y+2	; 0x02
    1108:	93 83       	std	Z+3, r25	; 0x03
    110a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    110c:	e9 81       	ldd	r30, Y+1	; 0x01
    110e:	fa 81       	ldd	r31, Y+2	; 0x02
    1110:	84 81       	ldd	r24, Z+4	; 0x04
    1112:	95 81       	ldd	r25, Z+5	; 0x05
    1114:	ed 81       	ldd	r30, Y+5	; 0x05
    1116:	fe 81       	ldd	r31, Y+6	; 0x06
    1118:	95 83       	std	Z+5, r25	; 0x05
    111a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    111c:	e9 81       	ldd	r30, Y+1	; 0x01
    111e:	fa 81       	ldd	r31, Y+2	; 0x02
    1120:	04 80       	ldd	r0, Z+4	; 0x04
    1122:	f5 81       	ldd	r31, Z+5	; 0x05
    1124:	e0 2d       	mov	r30, r0
    1126:	8d 81       	ldd	r24, Y+5	; 0x05
    1128:	9e 81       	ldd	r25, Y+6	; 0x06
    112a:	93 83       	std	Z+3, r25	; 0x03
    112c:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    112e:	e9 81       	ldd	r30, Y+1	; 0x01
    1130:	fa 81       	ldd	r31, Y+2	; 0x02
    1132:	8d 81       	ldd	r24, Y+5	; 0x05
    1134:	9e 81       	ldd	r25, Y+6	; 0x06
    1136:	95 83       	std	Z+5, r25	; 0x05
    1138:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    113a:	ed 81       	ldd	r30, Y+5	; 0x05
    113c:	fe 81       	ldd	r31, Y+6	; 0x06
    113e:	8b 81       	ldd	r24, Y+3	; 0x03
    1140:	9c 81       	ldd	r25, Y+4	; 0x04
    1142:	91 87       	std	Z+9, r25	; 0x09
    1144:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1146:	eb 81       	ldd	r30, Y+3	; 0x03
    1148:	fc 81       	ldd	r31, Y+4	; 0x04
    114a:	80 81       	ld	r24, Z
    114c:	8f 5f       	subi	r24, 0xFF	; 255
    114e:	eb 81       	ldd	r30, Y+3	; 0x03
    1150:	fc 81       	ldd	r31, Y+4	; 0x04
    1152:	80 83       	st	Z, r24
}
    1154:	26 96       	adiw	r28, 0x06	; 6
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	f8 94       	cli
    115a:	de bf       	out	0x3e, r29	; 62
    115c:	0f be       	out	0x3f, r0	; 63
    115e:	cd bf       	out	0x3d, r28	; 61
    1160:	cf 91       	pop	r28
    1162:	df 91       	pop	r29
    1164:	08 95       	ret

00001166 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1166:	df 93       	push	r29
    1168:	cf 93       	push	r28
    116a:	cd b7       	in	r28, 0x3d	; 61
    116c:	de b7       	in	r29, 0x3e	; 62
    116e:	28 97       	sbiw	r28, 0x08	; 8
    1170:	0f b6       	in	r0, 0x3f	; 63
    1172:	f8 94       	cli
    1174:	de bf       	out	0x3e, r29	; 62
    1176:	0f be       	out	0x3f, r0	; 63
    1178:	cd bf       	out	0x3d, r28	; 61
    117a:	9e 83       	std	Y+6, r25	; 0x06
    117c:	8d 83       	std	Y+5, r24	; 0x05
    117e:	78 87       	std	Y+8, r23	; 0x08
    1180:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1182:	ef 81       	ldd	r30, Y+7	; 0x07
    1184:	f8 85       	ldd	r31, Y+8	; 0x08
    1186:	80 81       	ld	r24, Z
    1188:	91 81       	ldd	r25, Z+1	; 0x01
    118a:	9a 83       	std	Y+2, r25	; 0x02
    118c:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    118e:	89 81       	ldd	r24, Y+1	; 0x01
    1190:	9a 81       	ldd	r25, Y+2	; 0x02
    1192:	2f ef       	ldi	r18, 0xFF	; 255
    1194:	8f 3f       	cpi	r24, 0xFF	; 255
    1196:	92 07       	cpc	r25, r18
    1198:	39 f4       	brne	.+14     	; 0x11a8 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    119a:	ed 81       	ldd	r30, Y+5	; 0x05
    119c:	fe 81       	ldd	r31, Y+6	; 0x06
    119e:	87 81       	ldd	r24, Z+7	; 0x07
    11a0:	90 85       	ldd	r25, Z+8	; 0x08
    11a2:	9c 83       	std	Y+4, r25	; 0x04
    11a4:	8b 83       	std	Y+3, r24	; 0x03
    11a6:	18 c0       	rjmp	.+48     	; 0x11d8 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    11a8:	8d 81       	ldd	r24, Y+5	; 0x05
    11aa:	9e 81       	ldd	r25, Y+6	; 0x06
    11ac:	03 96       	adiw	r24, 0x03	; 3
    11ae:	9c 83       	std	Y+4, r25	; 0x04
    11b0:	8b 83       	std	Y+3, r24	; 0x03
    11b2:	06 c0       	rjmp	.+12     	; 0x11c0 <vListInsert+0x5a>
    11b4:	eb 81       	ldd	r30, Y+3	; 0x03
    11b6:	fc 81       	ldd	r31, Y+4	; 0x04
    11b8:	82 81       	ldd	r24, Z+2	; 0x02
    11ba:	93 81       	ldd	r25, Z+3	; 0x03
    11bc:	9c 83       	std	Y+4, r25	; 0x04
    11be:	8b 83       	std	Y+3, r24	; 0x03
    11c0:	eb 81       	ldd	r30, Y+3	; 0x03
    11c2:	fc 81       	ldd	r31, Y+4	; 0x04
    11c4:	02 80       	ldd	r0, Z+2	; 0x02
    11c6:	f3 81       	ldd	r31, Z+3	; 0x03
    11c8:	e0 2d       	mov	r30, r0
    11ca:	20 81       	ld	r18, Z
    11cc:	31 81       	ldd	r19, Z+1	; 0x01
    11ce:	89 81       	ldd	r24, Y+1	; 0x01
    11d0:	9a 81       	ldd	r25, Y+2	; 0x02
    11d2:	82 17       	cp	r24, r18
    11d4:	93 07       	cpc	r25, r19
    11d6:	70 f7       	brcc	.-36     	; 0x11b4 <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    11d8:	eb 81       	ldd	r30, Y+3	; 0x03
    11da:	fc 81       	ldd	r31, Y+4	; 0x04
    11dc:	82 81       	ldd	r24, Z+2	; 0x02
    11de:	93 81       	ldd	r25, Z+3	; 0x03
    11e0:	ef 81       	ldd	r30, Y+7	; 0x07
    11e2:	f8 85       	ldd	r31, Y+8	; 0x08
    11e4:	93 83       	std	Z+3, r25	; 0x03
    11e6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    11e8:	ef 81       	ldd	r30, Y+7	; 0x07
    11ea:	f8 85       	ldd	r31, Y+8	; 0x08
    11ec:	02 80       	ldd	r0, Z+2	; 0x02
    11ee:	f3 81       	ldd	r31, Z+3	; 0x03
    11f0:	e0 2d       	mov	r30, r0
    11f2:	8f 81       	ldd	r24, Y+7	; 0x07
    11f4:	98 85       	ldd	r25, Y+8	; 0x08
    11f6:	95 83       	std	Z+5, r25	; 0x05
    11f8:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    11fa:	ef 81       	ldd	r30, Y+7	; 0x07
    11fc:	f8 85       	ldd	r31, Y+8	; 0x08
    11fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1200:	9c 81       	ldd	r25, Y+4	; 0x04
    1202:	95 83       	std	Z+5, r25	; 0x05
    1204:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1206:	eb 81       	ldd	r30, Y+3	; 0x03
    1208:	fc 81       	ldd	r31, Y+4	; 0x04
    120a:	8f 81       	ldd	r24, Y+7	; 0x07
    120c:	98 85       	ldd	r25, Y+8	; 0x08
    120e:	93 83       	std	Z+3, r25	; 0x03
    1210:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1212:	ef 81       	ldd	r30, Y+7	; 0x07
    1214:	f8 85       	ldd	r31, Y+8	; 0x08
    1216:	8d 81       	ldd	r24, Y+5	; 0x05
    1218:	9e 81       	ldd	r25, Y+6	; 0x06
    121a:	91 87       	std	Z+9, r25	; 0x09
    121c:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    121e:	ed 81       	ldd	r30, Y+5	; 0x05
    1220:	fe 81       	ldd	r31, Y+6	; 0x06
    1222:	80 81       	ld	r24, Z
    1224:	8f 5f       	subi	r24, 0xFF	; 255
    1226:	ed 81       	ldd	r30, Y+5	; 0x05
    1228:	fe 81       	ldd	r31, Y+6	; 0x06
    122a:	80 83       	st	Z, r24
}
    122c:	28 96       	adiw	r28, 0x08	; 8
    122e:	0f b6       	in	r0, 0x3f	; 63
    1230:	f8 94       	cli
    1232:	de bf       	out	0x3e, r29	; 62
    1234:	0f be       	out	0x3f, r0	; 63
    1236:	cd bf       	out	0x3d, r28	; 61
    1238:	cf 91       	pop	r28
    123a:	df 91       	pop	r29
    123c:	08 95       	ret

0000123e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    123e:	df 93       	push	r29
    1240:	cf 93       	push	r28
    1242:	00 d0       	rcall	.+0      	; 0x1244 <uxListRemove+0x6>
    1244:	00 d0       	rcall	.+0      	; 0x1246 <uxListRemove+0x8>
    1246:	cd b7       	in	r28, 0x3d	; 61
    1248:	de b7       	in	r29, 0x3e	; 62
    124a:	9c 83       	std	Y+4, r25	; 0x04
    124c:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    124e:	eb 81       	ldd	r30, Y+3	; 0x03
    1250:	fc 81       	ldd	r31, Y+4	; 0x04
    1252:	80 85       	ldd	r24, Z+8	; 0x08
    1254:	91 85       	ldd	r25, Z+9	; 0x09
    1256:	9a 83       	std	Y+2, r25	; 0x02
    1258:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    125a:	eb 81       	ldd	r30, Y+3	; 0x03
    125c:	fc 81       	ldd	r31, Y+4	; 0x04
    125e:	a2 81       	ldd	r26, Z+2	; 0x02
    1260:	b3 81       	ldd	r27, Z+3	; 0x03
    1262:	eb 81       	ldd	r30, Y+3	; 0x03
    1264:	fc 81       	ldd	r31, Y+4	; 0x04
    1266:	84 81       	ldd	r24, Z+4	; 0x04
    1268:	95 81       	ldd	r25, Z+5	; 0x05
    126a:	15 96       	adiw	r26, 0x05	; 5
    126c:	9c 93       	st	X, r25
    126e:	8e 93       	st	-X, r24
    1270:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1272:	eb 81       	ldd	r30, Y+3	; 0x03
    1274:	fc 81       	ldd	r31, Y+4	; 0x04
    1276:	a4 81       	ldd	r26, Z+4	; 0x04
    1278:	b5 81       	ldd	r27, Z+5	; 0x05
    127a:	eb 81       	ldd	r30, Y+3	; 0x03
    127c:	fc 81       	ldd	r31, Y+4	; 0x04
    127e:	82 81       	ldd	r24, Z+2	; 0x02
    1280:	93 81       	ldd	r25, Z+3	; 0x03
    1282:	13 96       	adiw	r26, 0x03	; 3
    1284:	9c 93       	st	X, r25
    1286:	8e 93       	st	-X, r24
    1288:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    128a:	e9 81       	ldd	r30, Y+1	; 0x01
    128c:	fa 81       	ldd	r31, Y+2	; 0x02
    128e:	21 81       	ldd	r18, Z+1	; 0x01
    1290:	32 81       	ldd	r19, Z+2	; 0x02
    1292:	8b 81       	ldd	r24, Y+3	; 0x03
    1294:	9c 81       	ldd	r25, Y+4	; 0x04
    1296:	28 17       	cp	r18, r24
    1298:	39 07       	cpc	r19, r25
    129a:	41 f4       	brne	.+16     	; 0x12ac <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    129c:	eb 81       	ldd	r30, Y+3	; 0x03
    129e:	fc 81       	ldd	r31, Y+4	; 0x04
    12a0:	84 81       	ldd	r24, Z+4	; 0x04
    12a2:	95 81       	ldd	r25, Z+5	; 0x05
    12a4:	e9 81       	ldd	r30, Y+1	; 0x01
    12a6:	fa 81       	ldd	r31, Y+2	; 0x02
    12a8:	92 83       	std	Z+2, r25	; 0x02
    12aa:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    12ac:	eb 81       	ldd	r30, Y+3	; 0x03
    12ae:	fc 81       	ldd	r31, Y+4	; 0x04
    12b0:	11 86       	std	Z+9, r1	; 0x09
    12b2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    12b4:	e9 81       	ldd	r30, Y+1	; 0x01
    12b6:	fa 81       	ldd	r31, Y+2	; 0x02
    12b8:	80 81       	ld	r24, Z
    12ba:	81 50       	subi	r24, 0x01	; 1
    12bc:	e9 81       	ldd	r30, Y+1	; 0x01
    12be:	fa 81       	ldd	r31, Y+2	; 0x02
    12c0:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    12c2:	e9 81       	ldd	r30, Y+1	; 0x01
    12c4:	fa 81       	ldd	r31, Y+2	; 0x02
    12c6:	80 81       	ld	r24, Z
}
    12c8:	0f 90       	pop	r0
    12ca:	0f 90       	pop	r0
    12cc:	0f 90       	pop	r0
    12ce:	0f 90       	pop	r0
    12d0:	cf 91       	pop	r28
    12d2:	df 91       	pop	r29
    12d4:	08 95       	ret

000012d6 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    12d6:	df 93       	push	r29
    12d8:	cf 93       	push	r28
    12da:	cd b7       	in	r28, 0x3d	; 61
    12dc:	de b7       	in	r29, 0x3e	; 62
    12de:	28 97       	sbiw	r28, 0x08	; 8
    12e0:	0f b6       	in	r0, 0x3f	; 63
    12e2:	f8 94       	cli
    12e4:	de bf       	out	0x3e, r29	; 62
    12e6:	0f be       	out	0x3f, r0	; 63
    12e8:	cd bf       	out	0x3d, r28	; 61
    12ea:	9c 83       	std	Y+4, r25	; 0x04
    12ec:	8b 83       	std	Y+3, r24	; 0x03
    12ee:	7e 83       	std	Y+6, r23	; 0x06
    12f0:	6d 83       	std	Y+5, r22	; 0x05
    12f2:	58 87       	std	Y+8, r21	; 0x08
    12f4:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    12f6:	eb 81       	ldd	r30, Y+3	; 0x03
    12f8:	fc 81       	ldd	r31, Y+4	; 0x04
    12fa:	81 e1       	ldi	r24, 0x11	; 17
    12fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    12fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1300:	9c 81       	ldd	r25, Y+4	; 0x04
    1302:	01 97       	sbiw	r24, 0x01	; 1
    1304:	9c 83       	std	Y+4, r25	; 0x04
    1306:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1308:	eb 81       	ldd	r30, Y+3	; 0x03
    130a:	fc 81       	ldd	r31, Y+4	; 0x04
    130c:	82 e2       	ldi	r24, 0x22	; 34
    130e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1310:	8b 81       	ldd	r24, Y+3	; 0x03
    1312:	9c 81       	ldd	r25, Y+4	; 0x04
    1314:	01 97       	sbiw	r24, 0x01	; 1
    1316:	9c 83       	std	Y+4, r25	; 0x04
    1318:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    131a:	eb 81       	ldd	r30, Y+3	; 0x03
    131c:	fc 81       	ldd	r31, Y+4	; 0x04
    131e:	83 e3       	ldi	r24, 0x33	; 51
    1320:	80 83       	st	Z, r24
	pxTopOfStack--;
    1322:	8b 81       	ldd	r24, Y+3	; 0x03
    1324:	9c 81       	ldd	r25, Y+4	; 0x04
    1326:	01 97       	sbiw	r24, 0x01	; 1
    1328:	9c 83       	std	Y+4, r25	; 0x04
    132a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    132c:	8d 81       	ldd	r24, Y+5	; 0x05
    132e:	9e 81       	ldd	r25, Y+6	; 0x06
    1330:	9a 83       	std	Y+2, r25	; 0x02
    1332:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1334:	89 81       	ldd	r24, Y+1	; 0x01
    1336:	eb 81       	ldd	r30, Y+3	; 0x03
    1338:	fc 81       	ldd	r31, Y+4	; 0x04
    133a:	80 83       	st	Z, r24
	pxTopOfStack--;
    133c:	8b 81       	ldd	r24, Y+3	; 0x03
    133e:	9c 81       	ldd	r25, Y+4	; 0x04
    1340:	01 97       	sbiw	r24, 0x01	; 1
    1342:	9c 83       	std	Y+4, r25	; 0x04
    1344:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1346:	89 81       	ldd	r24, Y+1	; 0x01
    1348:	9a 81       	ldd	r25, Y+2	; 0x02
    134a:	89 2f       	mov	r24, r25
    134c:	99 27       	eor	r25, r25
    134e:	9a 83       	std	Y+2, r25	; 0x02
    1350:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1352:	89 81       	ldd	r24, Y+1	; 0x01
    1354:	eb 81       	ldd	r30, Y+3	; 0x03
    1356:	fc 81       	ldd	r31, Y+4	; 0x04
    1358:	80 83       	st	Z, r24
	pxTopOfStack--;
    135a:	8b 81       	ldd	r24, Y+3	; 0x03
    135c:	9c 81       	ldd	r25, Y+4	; 0x04
    135e:	01 97       	sbiw	r24, 0x01	; 1
    1360:	9c 83       	std	Y+4, r25	; 0x04
    1362:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1364:	eb 81       	ldd	r30, Y+3	; 0x03
    1366:	fc 81       	ldd	r31, Y+4	; 0x04
    1368:	10 82       	st	Z, r1
	pxTopOfStack--;
    136a:	8b 81       	ldd	r24, Y+3	; 0x03
    136c:	9c 81       	ldd	r25, Y+4	; 0x04
    136e:	01 97       	sbiw	r24, 0x01	; 1
    1370:	9c 83       	std	Y+4, r25	; 0x04
    1372:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1374:	eb 81       	ldd	r30, Y+3	; 0x03
    1376:	fc 81       	ldd	r31, Y+4	; 0x04
    1378:	80 e8       	ldi	r24, 0x80	; 128
    137a:	80 83       	st	Z, r24
	pxTopOfStack--;
    137c:	8b 81       	ldd	r24, Y+3	; 0x03
    137e:	9c 81       	ldd	r25, Y+4	; 0x04
    1380:	01 97       	sbiw	r24, 0x01	; 1
    1382:	9c 83       	std	Y+4, r25	; 0x04
    1384:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1386:	eb 81       	ldd	r30, Y+3	; 0x03
    1388:	fc 81       	ldd	r31, Y+4	; 0x04
    138a:	10 82       	st	Z, r1
	pxTopOfStack--;
    138c:	8b 81       	ldd	r24, Y+3	; 0x03
    138e:	9c 81       	ldd	r25, Y+4	; 0x04
    1390:	01 97       	sbiw	r24, 0x01	; 1
    1392:	9c 83       	std	Y+4, r25	; 0x04
    1394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1396:	eb 81       	ldd	r30, Y+3	; 0x03
    1398:	fc 81       	ldd	r31, Y+4	; 0x04
    139a:	82 e0       	ldi	r24, 0x02	; 2
    139c:	80 83       	st	Z, r24
	pxTopOfStack--;
    139e:	8b 81       	ldd	r24, Y+3	; 0x03
    13a0:	9c 81       	ldd	r25, Y+4	; 0x04
    13a2:	01 97       	sbiw	r24, 0x01	; 1
    13a4:	9c 83       	std	Y+4, r25	; 0x04
    13a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    13a8:	eb 81       	ldd	r30, Y+3	; 0x03
    13aa:	fc 81       	ldd	r31, Y+4	; 0x04
    13ac:	83 e0       	ldi	r24, 0x03	; 3
    13ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    13b0:	8b 81       	ldd	r24, Y+3	; 0x03
    13b2:	9c 81       	ldd	r25, Y+4	; 0x04
    13b4:	01 97       	sbiw	r24, 0x01	; 1
    13b6:	9c 83       	std	Y+4, r25	; 0x04
    13b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    13ba:	eb 81       	ldd	r30, Y+3	; 0x03
    13bc:	fc 81       	ldd	r31, Y+4	; 0x04
    13be:	84 e0       	ldi	r24, 0x04	; 4
    13c0:	80 83       	st	Z, r24
	pxTopOfStack--;
    13c2:	8b 81       	ldd	r24, Y+3	; 0x03
    13c4:	9c 81       	ldd	r25, Y+4	; 0x04
    13c6:	01 97       	sbiw	r24, 0x01	; 1
    13c8:	9c 83       	std	Y+4, r25	; 0x04
    13ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    13cc:	eb 81       	ldd	r30, Y+3	; 0x03
    13ce:	fc 81       	ldd	r31, Y+4	; 0x04
    13d0:	85 e0       	ldi	r24, 0x05	; 5
    13d2:	80 83       	st	Z, r24
	pxTopOfStack--;
    13d4:	8b 81       	ldd	r24, Y+3	; 0x03
    13d6:	9c 81       	ldd	r25, Y+4	; 0x04
    13d8:	01 97       	sbiw	r24, 0x01	; 1
    13da:	9c 83       	std	Y+4, r25	; 0x04
    13dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    13de:	eb 81       	ldd	r30, Y+3	; 0x03
    13e0:	fc 81       	ldd	r31, Y+4	; 0x04
    13e2:	86 e0       	ldi	r24, 0x06	; 6
    13e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    13e6:	8b 81       	ldd	r24, Y+3	; 0x03
    13e8:	9c 81       	ldd	r25, Y+4	; 0x04
    13ea:	01 97       	sbiw	r24, 0x01	; 1
    13ec:	9c 83       	std	Y+4, r25	; 0x04
    13ee:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    13f0:	eb 81       	ldd	r30, Y+3	; 0x03
    13f2:	fc 81       	ldd	r31, Y+4	; 0x04
    13f4:	87 e0       	ldi	r24, 0x07	; 7
    13f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    13f8:	8b 81       	ldd	r24, Y+3	; 0x03
    13fa:	9c 81       	ldd	r25, Y+4	; 0x04
    13fc:	01 97       	sbiw	r24, 0x01	; 1
    13fe:	9c 83       	std	Y+4, r25	; 0x04
    1400:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1402:	eb 81       	ldd	r30, Y+3	; 0x03
    1404:	fc 81       	ldd	r31, Y+4	; 0x04
    1406:	88 e0       	ldi	r24, 0x08	; 8
    1408:	80 83       	st	Z, r24
	pxTopOfStack--;
    140a:	8b 81       	ldd	r24, Y+3	; 0x03
    140c:	9c 81       	ldd	r25, Y+4	; 0x04
    140e:	01 97       	sbiw	r24, 0x01	; 1
    1410:	9c 83       	std	Y+4, r25	; 0x04
    1412:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1414:	eb 81       	ldd	r30, Y+3	; 0x03
    1416:	fc 81       	ldd	r31, Y+4	; 0x04
    1418:	89 e0       	ldi	r24, 0x09	; 9
    141a:	80 83       	st	Z, r24
	pxTopOfStack--;
    141c:	8b 81       	ldd	r24, Y+3	; 0x03
    141e:	9c 81       	ldd	r25, Y+4	; 0x04
    1420:	01 97       	sbiw	r24, 0x01	; 1
    1422:	9c 83       	std	Y+4, r25	; 0x04
    1424:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1426:	eb 81       	ldd	r30, Y+3	; 0x03
    1428:	fc 81       	ldd	r31, Y+4	; 0x04
    142a:	80 e1       	ldi	r24, 0x10	; 16
    142c:	80 83       	st	Z, r24
	pxTopOfStack--;
    142e:	8b 81       	ldd	r24, Y+3	; 0x03
    1430:	9c 81       	ldd	r25, Y+4	; 0x04
    1432:	01 97       	sbiw	r24, 0x01	; 1
    1434:	9c 83       	std	Y+4, r25	; 0x04
    1436:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1438:	eb 81       	ldd	r30, Y+3	; 0x03
    143a:	fc 81       	ldd	r31, Y+4	; 0x04
    143c:	81 e1       	ldi	r24, 0x11	; 17
    143e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1440:	8b 81       	ldd	r24, Y+3	; 0x03
    1442:	9c 81       	ldd	r25, Y+4	; 0x04
    1444:	01 97       	sbiw	r24, 0x01	; 1
    1446:	9c 83       	std	Y+4, r25	; 0x04
    1448:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    144a:	eb 81       	ldd	r30, Y+3	; 0x03
    144c:	fc 81       	ldd	r31, Y+4	; 0x04
    144e:	82 e1       	ldi	r24, 0x12	; 18
    1450:	80 83       	st	Z, r24
	pxTopOfStack--;
    1452:	8b 81       	ldd	r24, Y+3	; 0x03
    1454:	9c 81       	ldd	r25, Y+4	; 0x04
    1456:	01 97       	sbiw	r24, 0x01	; 1
    1458:	9c 83       	std	Y+4, r25	; 0x04
    145a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    145c:	eb 81       	ldd	r30, Y+3	; 0x03
    145e:	fc 81       	ldd	r31, Y+4	; 0x04
    1460:	83 e1       	ldi	r24, 0x13	; 19
    1462:	80 83       	st	Z, r24
	pxTopOfStack--;
    1464:	8b 81       	ldd	r24, Y+3	; 0x03
    1466:	9c 81       	ldd	r25, Y+4	; 0x04
    1468:	01 97       	sbiw	r24, 0x01	; 1
    146a:	9c 83       	std	Y+4, r25	; 0x04
    146c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    146e:	eb 81       	ldd	r30, Y+3	; 0x03
    1470:	fc 81       	ldd	r31, Y+4	; 0x04
    1472:	84 e1       	ldi	r24, 0x14	; 20
    1474:	80 83       	st	Z, r24
	pxTopOfStack--;
    1476:	8b 81       	ldd	r24, Y+3	; 0x03
    1478:	9c 81       	ldd	r25, Y+4	; 0x04
    147a:	01 97       	sbiw	r24, 0x01	; 1
    147c:	9c 83       	std	Y+4, r25	; 0x04
    147e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1480:	eb 81       	ldd	r30, Y+3	; 0x03
    1482:	fc 81       	ldd	r31, Y+4	; 0x04
    1484:	85 e1       	ldi	r24, 0x15	; 21
    1486:	80 83       	st	Z, r24
	pxTopOfStack--;
    1488:	8b 81       	ldd	r24, Y+3	; 0x03
    148a:	9c 81       	ldd	r25, Y+4	; 0x04
    148c:	01 97       	sbiw	r24, 0x01	; 1
    148e:	9c 83       	std	Y+4, r25	; 0x04
    1490:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1492:	eb 81       	ldd	r30, Y+3	; 0x03
    1494:	fc 81       	ldd	r31, Y+4	; 0x04
    1496:	86 e1       	ldi	r24, 0x16	; 22
    1498:	80 83       	st	Z, r24
	pxTopOfStack--;
    149a:	8b 81       	ldd	r24, Y+3	; 0x03
    149c:	9c 81       	ldd	r25, Y+4	; 0x04
    149e:	01 97       	sbiw	r24, 0x01	; 1
    14a0:	9c 83       	std	Y+4, r25	; 0x04
    14a2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    14a4:	eb 81       	ldd	r30, Y+3	; 0x03
    14a6:	fc 81       	ldd	r31, Y+4	; 0x04
    14a8:	87 e1       	ldi	r24, 0x17	; 23
    14aa:	80 83       	st	Z, r24
	pxTopOfStack--;
    14ac:	8b 81       	ldd	r24, Y+3	; 0x03
    14ae:	9c 81       	ldd	r25, Y+4	; 0x04
    14b0:	01 97       	sbiw	r24, 0x01	; 1
    14b2:	9c 83       	std	Y+4, r25	; 0x04
    14b4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    14b6:	eb 81       	ldd	r30, Y+3	; 0x03
    14b8:	fc 81       	ldd	r31, Y+4	; 0x04
    14ba:	88 e1       	ldi	r24, 0x18	; 24
    14bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    14be:	8b 81       	ldd	r24, Y+3	; 0x03
    14c0:	9c 81       	ldd	r25, Y+4	; 0x04
    14c2:	01 97       	sbiw	r24, 0x01	; 1
    14c4:	9c 83       	std	Y+4, r25	; 0x04
    14c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    14c8:	eb 81       	ldd	r30, Y+3	; 0x03
    14ca:	fc 81       	ldd	r31, Y+4	; 0x04
    14cc:	89 e1       	ldi	r24, 0x19	; 25
    14ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    14d0:	8b 81       	ldd	r24, Y+3	; 0x03
    14d2:	9c 81       	ldd	r25, Y+4	; 0x04
    14d4:	01 97       	sbiw	r24, 0x01	; 1
    14d6:	9c 83       	std	Y+4, r25	; 0x04
    14d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    14da:	eb 81       	ldd	r30, Y+3	; 0x03
    14dc:	fc 81       	ldd	r31, Y+4	; 0x04
    14de:	80 e2       	ldi	r24, 0x20	; 32
    14e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    14e2:	8b 81       	ldd	r24, Y+3	; 0x03
    14e4:	9c 81       	ldd	r25, Y+4	; 0x04
    14e6:	01 97       	sbiw	r24, 0x01	; 1
    14e8:	9c 83       	std	Y+4, r25	; 0x04
    14ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    14ec:	eb 81       	ldd	r30, Y+3	; 0x03
    14ee:	fc 81       	ldd	r31, Y+4	; 0x04
    14f0:	81 e2       	ldi	r24, 0x21	; 33
    14f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    14f4:	8b 81       	ldd	r24, Y+3	; 0x03
    14f6:	9c 81       	ldd	r25, Y+4	; 0x04
    14f8:	01 97       	sbiw	r24, 0x01	; 1
    14fa:	9c 83       	std	Y+4, r25	; 0x04
    14fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    14fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1500:	fc 81       	ldd	r31, Y+4	; 0x04
    1502:	82 e2       	ldi	r24, 0x22	; 34
    1504:	80 83       	st	Z, r24
	pxTopOfStack--;
    1506:	8b 81       	ldd	r24, Y+3	; 0x03
    1508:	9c 81       	ldd	r25, Y+4	; 0x04
    150a:	01 97       	sbiw	r24, 0x01	; 1
    150c:	9c 83       	std	Y+4, r25	; 0x04
    150e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1510:	eb 81       	ldd	r30, Y+3	; 0x03
    1512:	fc 81       	ldd	r31, Y+4	; 0x04
    1514:	83 e2       	ldi	r24, 0x23	; 35
    1516:	80 83       	st	Z, r24
	pxTopOfStack--;
    1518:	8b 81       	ldd	r24, Y+3	; 0x03
    151a:	9c 81       	ldd	r25, Y+4	; 0x04
    151c:	01 97       	sbiw	r24, 0x01	; 1
    151e:	9c 83       	std	Y+4, r25	; 0x04
    1520:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    1522:	8f 81       	ldd	r24, Y+7	; 0x07
    1524:	98 85       	ldd	r25, Y+8	; 0x08
    1526:	9a 83       	std	Y+2, r25	; 0x02
    1528:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    152a:	89 81       	ldd	r24, Y+1	; 0x01
    152c:	eb 81       	ldd	r30, Y+3	; 0x03
    152e:	fc 81       	ldd	r31, Y+4	; 0x04
    1530:	80 83       	st	Z, r24
	pxTopOfStack--;
    1532:	8b 81       	ldd	r24, Y+3	; 0x03
    1534:	9c 81       	ldd	r25, Y+4	; 0x04
    1536:	01 97       	sbiw	r24, 0x01	; 1
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	9a 81       	ldd	r25, Y+2	; 0x02
    1540:	89 2f       	mov	r24, r25
    1542:	99 27       	eor	r25, r25
    1544:	9a 83       	std	Y+2, r25	; 0x02
    1546:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1548:	89 81       	ldd	r24, Y+1	; 0x01
    154a:	eb 81       	ldd	r30, Y+3	; 0x03
    154c:	fc 81       	ldd	r31, Y+4	; 0x04
    154e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1550:	8b 81       	ldd	r24, Y+3	; 0x03
    1552:	9c 81       	ldd	r25, Y+4	; 0x04
    1554:	01 97       	sbiw	r24, 0x01	; 1
    1556:	9c 83       	std	Y+4, r25	; 0x04
    1558:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    155a:	eb 81       	ldd	r30, Y+3	; 0x03
    155c:	fc 81       	ldd	r31, Y+4	; 0x04
    155e:	86 e2       	ldi	r24, 0x26	; 38
    1560:	80 83       	st	Z, r24
	pxTopOfStack--;
    1562:	8b 81       	ldd	r24, Y+3	; 0x03
    1564:	9c 81       	ldd	r25, Y+4	; 0x04
    1566:	01 97       	sbiw	r24, 0x01	; 1
    1568:	9c 83       	std	Y+4, r25	; 0x04
    156a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    156c:	eb 81       	ldd	r30, Y+3	; 0x03
    156e:	fc 81       	ldd	r31, Y+4	; 0x04
    1570:	87 e2       	ldi	r24, 0x27	; 39
    1572:	80 83       	st	Z, r24
	pxTopOfStack--;
    1574:	8b 81       	ldd	r24, Y+3	; 0x03
    1576:	9c 81       	ldd	r25, Y+4	; 0x04
    1578:	01 97       	sbiw	r24, 0x01	; 1
    157a:	9c 83       	std	Y+4, r25	; 0x04
    157c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    157e:	eb 81       	ldd	r30, Y+3	; 0x03
    1580:	fc 81       	ldd	r31, Y+4	; 0x04
    1582:	88 e2       	ldi	r24, 0x28	; 40
    1584:	80 83       	st	Z, r24
	pxTopOfStack--;
    1586:	8b 81       	ldd	r24, Y+3	; 0x03
    1588:	9c 81       	ldd	r25, Y+4	; 0x04
    158a:	01 97       	sbiw	r24, 0x01	; 1
    158c:	9c 83       	std	Y+4, r25	; 0x04
    158e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1590:	eb 81       	ldd	r30, Y+3	; 0x03
    1592:	fc 81       	ldd	r31, Y+4	; 0x04
    1594:	89 e2       	ldi	r24, 0x29	; 41
    1596:	80 83       	st	Z, r24
	pxTopOfStack--;
    1598:	8b 81       	ldd	r24, Y+3	; 0x03
    159a:	9c 81       	ldd	r25, Y+4	; 0x04
    159c:	01 97       	sbiw	r24, 0x01	; 1
    159e:	9c 83       	std	Y+4, r25	; 0x04
    15a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	80 e3       	ldi	r24, 0x30	; 48
    15a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	01 97       	sbiw	r24, 0x01	; 1
    15b0:	9c 83       	std	Y+4, r25	; 0x04
    15b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    15b4:	eb 81       	ldd	r30, Y+3	; 0x03
    15b6:	fc 81       	ldd	r31, Y+4	; 0x04
    15b8:	81 e3       	ldi	r24, 0x31	; 49
    15ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    15bc:	8b 81       	ldd	r24, Y+3	; 0x03
    15be:	9c 81       	ldd	r25, Y+4	; 0x04
    15c0:	01 97       	sbiw	r24, 0x01	; 1
    15c2:	9c 83       	std	Y+4, r25	; 0x04
    15c4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    15c6:	8b 81       	ldd	r24, Y+3	; 0x03
    15c8:	9c 81       	ldd	r25, Y+4	; 0x04
}
    15ca:	28 96       	adiw	r28, 0x08	; 8
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	cf 91       	pop	r28
    15d8:	df 91       	pop	r29
    15da:	08 95       	ret

000015dc <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    15dc:	df 93       	push	r29
    15de:	cf 93       	push	r28
    15e0:	cd b7       	in	r28, 0x3d	; 61
    15e2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    15e4:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    15e8:	a0 91 52 04 	lds	r26, 0x0452
    15ec:	b0 91 53 04 	lds	r27, 0x0453
    15f0:	cd 91       	ld	r28, X+
    15f2:	cd bf       	out	0x3d, r28	; 61
    15f4:	dd 91       	ld	r29, X+
    15f6:	de bf       	out	0x3e, r29	; 62
    15f8:	ff 91       	pop	r31
    15fa:	ef 91       	pop	r30
    15fc:	df 91       	pop	r29
    15fe:	cf 91       	pop	r28
    1600:	bf 91       	pop	r27
    1602:	af 91       	pop	r26
    1604:	9f 91       	pop	r25
    1606:	8f 91       	pop	r24
    1608:	7f 91       	pop	r23
    160a:	6f 91       	pop	r22
    160c:	5f 91       	pop	r21
    160e:	4f 91       	pop	r20
    1610:	3f 91       	pop	r19
    1612:	2f 91       	pop	r18
    1614:	1f 91       	pop	r17
    1616:	0f 91       	pop	r16
    1618:	ff 90       	pop	r15
    161a:	ef 90       	pop	r14
    161c:	df 90       	pop	r13
    161e:	cf 90       	pop	r12
    1620:	bf 90       	pop	r11
    1622:	af 90       	pop	r10
    1624:	9f 90       	pop	r9
    1626:	8f 90       	pop	r8
    1628:	7f 90       	pop	r7
    162a:	6f 90       	pop	r6
    162c:	5f 90       	pop	r5
    162e:	4f 90       	pop	r4
    1630:	3f 90       	pop	r3
    1632:	2f 90       	pop	r2
    1634:	1f 90       	pop	r1
    1636:	0f 90       	pop	r0
    1638:	0f be       	out	0x3f, r0	; 63
    163a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    163c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    163e:	81 e0       	ldi	r24, 0x01	; 1
}
    1640:	cf 91       	pop	r28
    1642:	df 91       	pop	r29
    1644:	08 95       	ret

00001646 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1646:	df 93       	push	r29
    1648:	cf 93       	push	r28
    164a:	cd b7       	in	r28, 0x3d	; 61
    164c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    164e:	cf 91       	pop	r28
    1650:	df 91       	pop	r29
    1652:	08 95       	ret

00001654 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1654:	0f 92       	push	r0
    1656:	0f b6       	in	r0, 0x3f	; 63
    1658:	f8 94       	cli
    165a:	0f 92       	push	r0
    165c:	1f 92       	push	r1
    165e:	11 24       	eor	r1, r1
    1660:	2f 92       	push	r2
    1662:	3f 92       	push	r3
    1664:	4f 92       	push	r4
    1666:	5f 92       	push	r5
    1668:	6f 92       	push	r6
    166a:	7f 92       	push	r7
    166c:	8f 92       	push	r8
    166e:	9f 92       	push	r9
    1670:	af 92       	push	r10
    1672:	bf 92       	push	r11
    1674:	cf 92       	push	r12
    1676:	df 92       	push	r13
    1678:	ef 92       	push	r14
    167a:	ff 92       	push	r15
    167c:	0f 93       	push	r16
    167e:	1f 93       	push	r17
    1680:	2f 93       	push	r18
    1682:	3f 93       	push	r19
    1684:	4f 93       	push	r20
    1686:	5f 93       	push	r21
    1688:	6f 93       	push	r22
    168a:	7f 93       	push	r23
    168c:	8f 93       	push	r24
    168e:	9f 93       	push	r25
    1690:	af 93       	push	r26
    1692:	bf 93       	push	r27
    1694:	cf 93       	push	r28
    1696:	df 93       	push	r29
    1698:	ef 93       	push	r30
    169a:	ff 93       	push	r31
    169c:	a0 91 52 04 	lds	r26, 0x0452
    16a0:	b0 91 53 04 	lds	r27, 0x0453
    16a4:	0d b6       	in	r0, 0x3d	; 61
    16a6:	0d 92       	st	X+, r0
    16a8:	0e b6       	in	r0, 0x3e	; 62
    16aa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    16ac:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    16b0:	a0 91 52 04 	lds	r26, 0x0452
    16b4:	b0 91 53 04 	lds	r27, 0x0453
    16b8:	cd 91       	ld	r28, X+
    16ba:	cd bf       	out	0x3d, r28	; 61
    16bc:	dd 91       	ld	r29, X+
    16be:	de bf       	out	0x3e, r29	; 62
    16c0:	ff 91       	pop	r31
    16c2:	ef 91       	pop	r30
    16c4:	df 91       	pop	r29
    16c6:	cf 91       	pop	r28
    16c8:	bf 91       	pop	r27
    16ca:	af 91       	pop	r26
    16cc:	9f 91       	pop	r25
    16ce:	8f 91       	pop	r24
    16d0:	7f 91       	pop	r23
    16d2:	6f 91       	pop	r22
    16d4:	5f 91       	pop	r21
    16d6:	4f 91       	pop	r20
    16d8:	3f 91       	pop	r19
    16da:	2f 91       	pop	r18
    16dc:	1f 91       	pop	r17
    16de:	0f 91       	pop	r16
    16e0:	ff 90       	pop	r15
    16e2:	ef 90       	pop	r14
    16e4:	df 90       	pop	r13
    16e6:	cf 90       	pop	r12
    16e8:	bf 90       	pop	r11
    16ea:	af 90       	pop	r10
    16ec:	9f 90       	pop	r9
    16ee:	8f 90       	pop	r8
    16f0:	7f 90       	pop	r7
    16f2:	6f 90       	pop	r6
    16f4:	5f 90       	pop	r5
    16f6:	4f 90       	pop	r4
    16f8:	3f 90       	pop	r3
    16fa:	2f 90       	pop	r2
    16fc:	1f 90       	pop	r1
    16fe:	0f 90       	pop	r0
    1700:	0f be       	out	0x3f, r0	; 63
    1702:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1704:	08 95       	ret

00001706 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1706:	0f 92       	push	r0
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	0f 92       	push	r0
    170e:	1f 92       	push	r1
    1710:	11 24       	eor	r1, r1
    1712:	2f 92       	push	r2
    1714:	3f 92       	push	r3
    1716:	4f 92       	push	r4
    1718:	5f 92       	push	r5
    171a:	6f 92       	push	r6
    171c:	7f 92       	push	r7
    171e:	8f 92       	push	r8
    1720:	9f 92       	push	r9
    1722:	af 92       	push	r10
    1724:	bf 92       	push	r11
    1726:	cf 92       	push	r12
    1728:	df 92       	push	r13
    172a:	ef 92       	push	r14
    172c:	ff 92       	push	r15
    172e:	0f 93       	push	r16
    1730:	1f 93       	push	r17
    1732:	2f 93       	push	r18
    1734:	3f 93       	push	r19
    1736:	4f 93       	push	r20
    1738:	5f 93       	push	r21
    173a:	6f 93       	push	r22
    173c:	7f 93       	push	r23
    173e:	8f 93       	push	r24
    1740:	9f 93       	push	r25
    1742:	af 93       	push	r26
    1744:	bf 93       	push	r27
    1746:	cf 93       	push	r28
    1748:	df 93       	push	r29
    174a:	ef 93       	push	r30
    174c:	ff 93       	push	r31
    174e:	a0 91 52 04 	lds	r26, 0x0452
    1752:	b0 91 53 04 	lds	r27, 0x0453
    1756:	0d b6       	in	r0, 0x3d	; 61
    1758:	0d 92       	st	X+, r0
    175a:	0e b6       	in	r0, 0x3e	; 62
    175c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    175e:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskIncrementTick>
    1762:	88 23       	and	r24, r24
    1764:	11 f0       	breq	.+4      	; 0x176a <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1766:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    176a:	a0 91 52 04 	lds	r26, 0x0452
    176e:	b0 91 53 04 	lds	r27, 0x0453
    1772:	cd 91       	ld	r28, X+
    1774:	cd bf       	out	0x3d, r28	; 61
    1776:	dd 91       	ld	r29, X+
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	ff 91       	pop	r31
    177c:	ef 91       	pop	r30
    177e:	df 91       	pop	r29
    1780:	cf 91       	pop	r28
    1782:	bf 91       	pop	r27
    1784:	af 91       	pop	r26
    1786:	9f 91       	pop	r25
    1788:	8f 91       	pop	r24
    178a:	7f 91       	pop	r23
    178c:	6f 91       	pop	r22
    178e:	5f 91       	pop	r21
    1790:	4f 91       	pop	r20
    1792:	3f 91       	pop	r19
    1794:	2f 91       	pop	r18
    1796:	1f 91       	pop	r17
    1798:	0f 91       	pop	r16
    179a:	ff 90       	pop	r15
    179c:	ef 90       	pop	r14
    179e:	df 90       	pop	r13
    17a0:	cf 90       	pop	r12
    17a2:	bf 90       	pop	r11
    17a4:	af 90       	pop	r10
    17a6:	9f 90       	pop	r9
    17a8:	8f 90       	pop	r8
    17aa:	7f 90       	pop	r7
    17ac:	6f 90       	pop	r6
    17ae:	5f 90       	pop	r5
    17b0:	4f 90       	pop	r4
    17b2:	3f 90       	pop	r3
    17b4:	2f 90       	pop	r2
    17b6:	1f 90       	pop	r1
    17b8:	0f 90       	pop	r0
    17ba:	0f be       	out	0x3f, r0	; 63
    17bc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    17be:	08 95       	ret

000017c0 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    17c0:	df 93       	push	r29
    17c2:	cf 93       	push	r28
    17c4:	00 d0       	rcall	.+0      	; 0x17c6 <prvSetupTimerInterrupt+0x6>
    17c6:	00 d0       	rcall	.+0      	; 0x17c8 <prvSetupTimerInterrupt+0x8>
    17c8:	00 d0       	rcall	.+0      	; 0x17ca <prvSetupTimerInterrupt+0xa>
    17ca:	cd b7       	in	r28, 0x3d	; 61
    17cc:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    17ce:	80 e8       	ldi	r24, 0x80	; 128
    17d0:	9e e3       	ldi	r25, 0x3E	; 62
    17d2:	a0 e0       	ldi	r26, 0x00	; 0
    17d4:	b0 e0       	ldi	r27, 0x00	; 0
    17d6:	8b 83       	std	Y+3, r24	; 0x03
    17d8:	9c 83       	std	Y+4, r25	; 0x04
    17da:	ad 83       	std	Y+5, r26	; 0x05
    17dc:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    17de:	8b 81       	ldd	r24, Y+3	; 0x03
    17e0:	9c 81       	ldd	r25, Y+4	; 0x04
    17e2:	ad 81       	ldd	r26, Y+5	; 0x05
    17e4:	be 81       	ldd	r27, Y+6	; 0x06
    17e6:	68 94       	set
    17e8:	15 f8       	bld	r1, 5
    17ea:	b6 95       	lsr	r27
    17ec:	a7 95       	ror	r26
    17ee:	97 95       	ror	r25
    17f0:	87 95       	ror	r24
    17f2:	16 94       	lsr	r1
    17f4:	d1 f7       	brne	.-12     	; 0x17ea <prvSetupTimerInterrupt+0x2a>
    17f6:	8b 83       	std	Y+3, r24	; 0x03
    17f8:	9c 83       	std	Y+4, r25	; 0x04
    17fa:	ad 83       	std	Y+5, r26	; 0x05
    17fc:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    17fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1800:	9c 81       	ldd	r25, Y+4	; 0x04
    1802:	ad 81       	ldd	r26, Y+5	; 0x05
    1804:	be 81       	ldd	r27, Y+6	; 0x06
    1806:	01 97       	sbiw	r24, 0x01	; 1
    1808:	a1 09       	sbc	r26, r1
    180a:	b1 09       	sbc	r27, r1
    180c:	8b 83       	std	Y+3, r24	; 0x03
    180e:	9c 83       	std	Y+4, r25	; 0x04
    1810:	ad 83       	std	Y+5, r26	; 0x05
    1812:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1814:	8b 81       	ldd	r24, Y+3	; 0x03
    1816:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	9c 81       	ldd	r25, Y+4	; 0x04
    181c:	ad 81       	ldd	r26, Y+5	; 0x05
    181e:	be 81       	ldd	r27, Y+6	; 0x06
    1820:	89 2f       	mov	r24, r25
    1822:	9a 2f       	mov	r25, r26
    1824:	ab 2f       	mov	r26, r27
    1826:	bb 27       	eor	r27, r27
    1828:	8b 83       	std	Y+3, r24	; 0x03
    182a:	9c 83       	std	Y+4, r25	; 0x04
    182c:	ad 83       	std	Y+5, r26	; 0x05
    182e:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1830:	8b 81       	ldd	r24, Y+3	; 0x03
    1832:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1834:	eb e4       	ldi	r30, 0x4B	; 75
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	8a 81       	ldd	r24, Y+2	; 0x02
    183a:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    183c:	ea e4       	ldi	r30, 0x4A	; 74
    183e:	f0 e0       	ldi	r31, 0x00	; 0
    1840:	89 81       	ldd	r24, Y+1	; 0x01
    1842:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1844:	8b e0       	ldi	r24, 0x0B	; 11
    1846:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1848:	ee e4       	ldi	r30, 0x4E	; 78
    184a:	f0 e0       	ldi	r31, 0x00	; 0
    184c:	89 81       	ldd	r24, Y+1	; 0x01
    184e:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1850:	e9 e5       	ldi	r30, 0x59	; 89
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	80 81       	ld	r24, Z
    1856:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1858:	89 81       	ldd	r24, Y+1	; 0x01
    185a:	80 61       	ori	r24, 0x10	; 16
    185c:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    185e:	e9 e5       	ldi	r30, 0x59	; 89
    1860:	f0 e0       	ldi	r31, 0x00	; 0
    1862:	89 81       	ldd	r24, Y+1	; 0x01
    1864:	80 83       	st	Z, r24
}
    1866:	26 96       	adiw	r28, 0x06	; 6
    1868:	0f b6       	in	r0, 0x3f	; 63
    186a:	f8 94       	cli
    186c:	de bf       	out	0x3e, r29	; 62
    186e:	0f be       	out	0x3f, r0	; 63
    1870:	cd bf       	out	0x3d, r28	; 61
    1872:	cf 91       	pop	r28
    1874:	df 91       	pop	r29
    1876:	08 95       	ret

00001878 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1878:	0e 94 83 0b 	call	0x1706	; 0x1706 <vPortYieldFromTick>
		asm volatile ( "reti" );
    187c:	18 95       	reti

0000187e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    187e:	df 93       	push	r29
    1880:	cf 93       	push	r28
    1882:	00 d0       	rcall	.+0      	; 0x1884 <xQueueGenericReset+0x6>
    1884:	00 d0       	rcall	.+0      	; 0x1886 <xQueueGenericReset+0x8>
    1886:	0f 92       	push	r0
    1888:	cd b7       	in	r28, 0x3d	; 61
    188a:	de b7       	in	r29, 0x3e	; 62
    188c:	9c 83       	std	Y+4, r25	; 0x04
    188e:	8b 83       	std	Y+3, r24	; 0x03
    1890:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1892:	8b 81       	ldd	r24, Y+3	; 0x03
    1894:	9c 81       	ldd	r25, Y+4	; 0x04
    1896:	9a 83       	std	Y+2, r25	; 0x02
    1898:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    189a:	0f b6       	in	r0, 0x3f	; 63
    189c:	f8 94       	cli
    189e:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    18a0:	e9 81       	ldd	r30, Y+1	; 0x01
    18a2:	fa 81       	ldd	r31, Y+2	; 0x02
    18a4:	40 81       	ld	r20, Z
    18a6:	51 81       	ldd	r21, Z+1	; 0x01
    18a8:	e9 81       	ldd	r30, Y+1	; 0x01
    18aa:	fa 81       	ldd	r31, Y+2	; 0x02
    18ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    18ae:	28 2f       	mov	r18, r24
    18b0:	30 e0       	ldi	r19, 0x00	; 0
    18b2:	e9 81       	ldd	r30, Y+1	; 0x01
    18b4:	fa 81       	ldd	r31, Y+2	; 0x02
    18b6:	84 8d       	ldd	r24, Z+28	; 0x1c
    18b8:	88 2f       	mov	r24, r24
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	bc 01       	movw	r22, r24
    18be:	26 9f       	mul	r18, r22
    18c0:	c0 01       	movw	r24, r0
    18c2:	27 9f       	mul	r18, r23
    18c4:	90 0d       	add	r25, r0
    18c6:	36 9f       	mul	r19, r22
    18c8:	90 0d       	add	r25, r0
    18ca:	11 24       	eor	r1, r1
    18cc:	84 0f       	add	r24, r20
    18ce:	95 1f       	adc	r25, r21
    18d0:	e9 81       	ldd	r30, Y+1	; 0x01
    18d2:	fa 81       	ldd	r31, Y+2	; 0x02
    18d4:	93 83       	std	Z+3, r25	; 0x03
    18d6:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    18d8:	e9 81       	ldd	r30, Y+1	; 0x01
    18da:	fa 81       	ldd	r31, Y+2	; 0x02
    18dc:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    18de:	e9 81       	ldd	r30, Y+1	; 0x01
    18e0:	fa 81       	ldd	r31, Y+2	; 0x02
    18e2:	80 81       	ld	r24, Z
    18e4:	91 81       	ldd	r25, Z+1	; 0x01
    18e6:	e9 81       	ldd	r30, Y+1	; 0x01
    18e8:	fa 81       	ldd	r31, Y+2	; 0x02
    18ea:	95 83       	std	Z+5, r25	; 0x05
    18ec:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    18ee:	e9 81       	ldd	r30, Y+1	; 0x01
    18f0:	fa 81       	ldd	r31, Y+2	; 0x02
    18f2:	40 81       	ld	r20, Z
    18f4:	51 81       	ldd	r21, Z+1	; 0x01
    18f6:	e9 81       	ldd	r30, Y+1	; 0x01
    18f8:	fa 81       	ldd	r31, Y+2	; 0x02
    18fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    18fc:	88 2f       	mov	r24, r24
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	9c 01       	movw	r18, r24
    1902:	21 50       	subi	r18, 0x01	; 1
    1904:	30 40       	sbci	r19, 0x00	; 0
    1906:	e9 81       	ldd	r30, Y+1	; 0x01
    1908:	fa 81       	ldd	r31, Y+2	; 0x02
    190a:	84 8d       	ldd	r24, Z+28	; 0x1c
    190c:	88 2f       	mov	r24, r24
    190e:	90 e0       	ldi	r25, 0x00	; 0
    1910:	bc 01       	movw	r22, r24
    1912:	26 9f       	mul	r18, r22
    1914:	c0 01       	movw	r24, r0
    1916:	27 9f       	mul	r18, r23
    1918:	90 0d       	add	r25, r0
    191a:	36 9f       	mul	r19, r22
    191c:	90 0d       	add	r25, r0
    191e:	11 24       	eor	r1, r1
    1920:	84 0f       	add	r24, r20
    1922:	95 1f       	adc	r25, r21
    1924:	e9 81       	ldd	r30, Y+1	; 0x01
    1926:	fa 81       	ldd	r31, Y+2	; 0x02
    1928:	97 83       	std	Z+7, r25	; 0x07
    192a:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    192c:	e9 81       	ldd	r30, Y+1	; 0x01
    192e:	fa 81       	ldd	r31, Y+2	; 0x02
    1930:	8f ef       	ldi	r24, 0xFF	; 255
    1932:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1934:	e9 81       	ldd	r30, Y+1	; 0x01
    1936:	fa 81       	ldd	r31, Y+2	; 0x02
    1938:	8f ef       	ldi	r24, 0xFF	; 255
    193a:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    193c:	8d 81       	ldd	r24, Y+5	; 0x05
    193e:	88 23       	and	r24, r24
    1940:	79 f4       	brne	.+30     	; 0x1960 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1942:	e9 81       	ldd	r30, Y+1	; 0x01
    1944:	fa 81       	ldd	r31, Y+2	; 0x02
    1946:	80 85       	ldd	r24, Z+8	; 0x08
    1948:	88 23       	and	r24, r24
    194a:	a1 f0       	breq	.+40     	; 0x1974 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    194c:	89 81       	ldd	r24, Y+1	; 0x01
    194e:	9a 81       	ldd	r25, Y+2	; 0x02
    1950:	08 96       	adiw	r24, 0x08	; 8
    1952:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1956:	81 30       	cpi	r24, 0x01	; 1
    1958:	69 f4       	brne	.+26     	; 0x1974 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    195a:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    195e:	0a c0       	rjmp	.+20     	; 0x1974 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	9a 81       	ldd	r25, Y+2	; 0x02
    1964:	08 96       	adiw	r24, 0x08	; 8
    1966:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    196a:	89 81       	ldd	r24, Y+1	; 0x01
    196c:	9a 81       	ldd	r25, Y+2	; 0x02
    196e:	41 96       	adiw	r24, 0x11	; 17
    1970:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1978:	81 e0       	ldi	r24, 0x01	; 1
}
    197a:	0f 90       	pop	r0
    197c:	0f 90       	pop	r0
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	cf 91       	pop	r28
    1986:	df 91       	pop	r29
    1988:	08 95       	ret

0000198a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    198a:	df 93       	push	r29
    198c:	cf 93       	push	r28
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
    1992:	29 97       	sbiw	r28, 0x09	; 9
    1994:	0f b6       	in	r0, 0x3f	; 63
    1996:	f8 94       	cli
    1998:	de bf       	out	0x3e, r29	; 62
    199a:	0f be       	out	0x3f, r0	; 63
    199c:	cd bf       	out	0x3d, r28	; 61
    199e:	8f 83       	std	Y+7, r24	; 0x07
    19a0:	68 87       	std	Y+8, r22	; 0x08
    19a2:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    19a4:	1a 82       	std	Y+2, r1	; 0x02
    19a6:	19 82       	std	Y+1, r1	; 0x01
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
    19a8:	88 85       	ldd	r24, Y+8	; 0x08
    19aa:	88 23       	and	r24, r24
    19ac:	19 f4       	brne	.+6      	; 0x19b4 <xQueueGenericCreate+0x2a>
	{
		/* There is not going to be a queue storage area. */
		xQueueSizeInBytes = ( size_t ) 0;
    19ae:	1c 82       	std	Y+4, r1	; 0x04
    19b0:	1b 82       	std	Y+3, r1	; 0x03
    19b2:	11 c0       	rjmp	.+34     	; 0x19d6 <xQueueGenericCreate+0x4c>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    19b4:	8f 81       	ldd	r24, Y+7	; 0x07
    19b6:	28 2f       	mov	r18, r24
    19b8:	30 e0       	ldi	r19, 0x00	; 0
    19ba:	88 85       	ldd	r24, Y+8	; 0x08
    19bc:	88 2f       	mov	r24, r24
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	ac 01       	movw	r20, r24
    19c2:	24 9f       	mul	r18, r20
    19c4:	c0 01       	movw	r24, r0
    19c6:	25 9f       	mul	r18, r21
    19c8:	90 0d       	add	r25, r0
    19ca:	34 9f       	mul	r19, r20
    19cc:	90 0d       	add	r25, r0
    19ce:	11 24       	eor	r1, r1
    19d0:	01 96       	adiw	r24, 0x01	; 1
    19d2:	9c 83       	std	Y+4, r25	; 0x04
    19d4:	8b 83       	std	Y+3, r24	; 0x03
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
    19d6:	8b 81       	ldd	r24, Y+3	; 0x03
    19d8:	9c 81       	ldd	r25, Y+4	; 0x04
    19da:	4f 96       	adiw	r24, 0x1f	; 31
    19dc:	0e 94 a3 05 	call	0xb46	; 0xb46 <pvPortMalloc>
    19e0:	9e 83       	std	Y+6, r25	; 0x06
    19e2:	8d 83       	std	Y+5, r24	; 0x05

	if( pxNewQueue != NULL )
    19e4:	8d 81       	ldd	r24, Y+5	; 0x05
    19e6:	9e 81       	ldd	r25, Y+6	; 0x06
    19e8:	00 97       	sbiw	r24, 0x00	; 0
    19ea:	11 f1       	breq	.+68     	; 0x1a30 <xQueueGenericCreate+0xa6>
	{
		if( uxItemSize == ( UBaseType_t ) 0 )
    19ec:	88 85       	ldd	r24, Y+8	; 0x08
    19ee:	88 23       	and	r24, r24
    19f0:	39 f4       	brne	.+14     	; 0x1a00 <xQueueGenericCreate+0x76>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    19f2:	8d 81       	ldd	r24, Y+5	; 0x05
    19f4:	9e 81       	ldd	r25, Y+6	; 0x06
    19f6:	ed 81       	ldd	r30, Y+5	; 0x05
    19f8:	fe 81       	ldd	r31, Y+6	; 0x06
    19fa:	91 83       	std	Z+1, r25	; 0x01
    19fc:	80 83       	st	Z, r24
    19fe:	07 c0       	rjmp	.+14     	; 0x1a0e <xQueueGenericCreate+0x84>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
    1a00:	8d 81       	ldd	r24, Y+5	; 0x05
    1a02:	9e 81       	ldd	r25, Y+6	; 0x06
    1a04:	4f 96       	adiw	r24, 0x1f	; 31
    1a06:	ed 81       	ldd	r30, Y+5	; 0x05
    1a08:	fe 81       	ldd	r31, Y+6	; 0x06
    1a0a:	91 83       	std	Z+1, r25	; 0x01
    1a0c:	80 83       	st	Z, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
    1a0e:	ed 81       	ldd	r30, Y+5	; 0x05
    1a10:	fe 81       	ldd	r31, Y+6	; 0x06
    1a12:	8f 81       	ldd	r24, Y+7	; 0x07
    1a14:	83 8f       	std	Z+27, r24	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
    1a16:	ed 81       	ldd	r30, Y+5	; 0x05
    1a18:	fe 81       	ldd	r31, Y+6	; 0x06
    1a1a:	88 85       	ldd	r24, Y+8	; 0x08
    1a1c:	84 8f       	std	Z+28, r24	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1a1e:	8d 81       	ldd	r24, Y+5	; 0x05
    1a20:	9e 81       	ldd	r25, Y+6	; 0x06
    1a22:	61 e0       	ldi	r22, 0x01	; 1
    1a24:	0e 94 3f 0c 	call	0x187e	; 0x187e <xQueueGenericReset>
			pxNewQueue->pxQueueSetContainer = NULL;
		}
		#endif /* configUSE_QUEUE_SETS */

		traceQUEUE_CREATE( pxNewQueue );
		xReturn = pxNewQueue;
    1a28:	8d 81       	ldd	r24, Y+5	; 0x05
    1a2a:	9e 81       	ldd	r25, Y+6	; 0x06
    1a2c:	9a 83       	std	Y+2, r25	; 0x02
    1a2e:	89 83       	std	Y+1, r24	; 0x01
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    1a30:	89 81       	ldd	r24, Y+1	; 0x01
    1a32:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1a34:	29 96       	adiw	r28, 0x09	; 9
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	de bf       	out	0x3e, r29	; 62
    1a3c:	0f be       	out	0x3f, r0	; 63
    1a3e:	cd bf       	out	0x3d, r28	; 61
    1a40:	cf 91       	pop	r28
    1a42:	df 91       	pop	r29
    1a44:	08 95       	ret

00001a46 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1a46:	df 93       	push	r29
    1a48:	cf 93       	push	r28
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
    1a4e:	2f 97       	sbiw	r28, 0x0f	; 15
    1a50:	0f b6       	in	r0, 0x3f	; 63
    1a52:	f8 94       	cli
    1a54:	de bf       	out	0x3e, r29	; 62
    1a56:	0f be       	out	0x3f, r0	; 63
    1a58:	cd bf       	out	0x3d, r28	; 61
    1a5a:	99 87       	std	Y+9, r25	; 0x09
    1a5c:	88 87       	std	Y+8, r24	; 0x08
    1a5e:	7b 87       	std	Y+11, r23	; 0x0b
    1a60:	6a 87       	std	Y+10, r22	; 0x0a
    1a62:	5d 87       	std	Y+13, r21	; 0x0d
    1a64:	4c 87       	std	Y+12, r20	; 0x0c
    1a66:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1a68:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1a6a:	88 85       	ldd	r24, Y+8	; 0x08
    1a6c:	99 85       	ldd	r25, Y+9	; 0x09
    1a6e:	9a 83       	std	Y+2, r25	; 0x02
    1a70:	89 83       	std	Y+1, r24	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1a72:	0f b6       	in	r0, 0x3f	; 63
    1a74:	f8 94       	cli
    1a76:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a78:	e9 81       	ldd	r30, Y+1	; 0x01
    1a7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a7c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a7e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a80:	fa 81       	ldd	r31, Y+2	; 0x02
    1a82:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a84:	98 17       	cp	r25, r24
    1a86:	18 f0       	brcs	.+6      	; 0x1a8e <xQueueGenericSend+0x48>
    1a88:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a8a:	82 30       	cpi	r24, 0x02	; 2
    1a8c:	11 f5       	brne	.+68     	; 0x1ad2 <xQueueGenericSend+0x8c>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a8e:	89 81       	ldd	r24, Y+1	; 0x01
    1a90:	9a 81       	ldd	r25, Y+2	; 0x02
    1a92:	2a 85       	ldd	r18, Y+10	; 0x0a
    1a94:	3b 85       	ldd	r19, Y+11	; 0x0b
    1a96:	b9 01       	movw	r22, r18
    1a98:	4e 85       	ldd	r20, Y+14	; 0x0e
    1a9a:	0e 94 33 10 	call	0x2066	; 0x2066 <prvCopyDataToQueue>
    1a9e:	8b 83       	std	Y+3, r24	; 0x03
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1aa0:	e9 81       	ldd	r30, Y+1	; 0x01
    1aa2:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa4:	81 89       	ldd	r24, Z+17	; 0x11
    1aa6:	88 23       	and	r24, r24
    1aa8:	51 f0       	breq	.+20     	; 0x1abe <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1aaa:	89 81       	ldd	r24, Y+1	; 0x01
    1aac:	9a 81       	ldd	r25, Y+2	; 0x02
    1aae:	41 96       	adiw	r24, 0x11	; 17
    1ab0:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1ab4:	81 30       	cpi	r24, 0x01	; 1
    1ab6:	41 f4       	brne	.+16     	; 0x1ac8 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1ab8:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    1abc:	05 c0       	rjmp	.+10     	; 0x1ac8 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1abe:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac0:	88 23       	and	r24, r24
    1ac2:	11 f0       	breq	.+4      	; 0x1ac8 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1ac4:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1ac8:	0f 90       	pop	r0
    1aca:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	8f 87       	std	Y+15, r24	; 0x0f
    1ad0:	5c c0       	rjmp	.+184    	; 0x1b8a <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1ad2:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ad4:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ad6:	00 97       	sbiw	r24, 0x00	; 0
    1ad8:	21 f4       	brne	.+8      	; 0x1ae2 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ada:	0f 90       	pop	r0
    1adc:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1ade:	1f 86       	std	Y+15, r1	; 0x0f
    1ae0:	54 c0       	rjmp	.+168    	; 0x1b8a <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ae2:	8c 81       	ldd	r24, Y+4	; 0x04
    1ae4:	88 23       	and	r24, r24
    1ae6:	31 f4       	brne	.+12     	; 0x1af4 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ae8:	ce 01       	movw	r24, r28
    1aea:	05 96       	adiw	r24, 0x05	; 5
    1aec:	0e 94 80 17 	call	0x2f00	; 0x2f00 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1af4:	0f 90       	pop	r0
    1af6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1af8:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1afc:	0f b6       	in	r0, 0x3f	; 63
    1afe:	f8 94       	cli
    1b00:	0f 92       	push	r0
    1b02:	e9 81       	ldd	r30, Y+1	; 0x01
    1b04:	fa 81       	ldd	r31, Y+2	; 0x02
    1b06:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b08:	8f 3f       	cpi	r24, 0xFF	; 255
    1b0a:	19 f4       	brne	.+6      	; 0x1b12 <xQueueGenericSend+0xcc>
    1b0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b10:	15 8e       	std	Z+29, r1	; 0x1d
    1b12:	e9 81       	ldd	r30, Y+1	; 0x01
    1b14:	fa 81       	ldd	r31, Y+2	; 0x02
    1b16:	86 8d       	ldd	r24, Z+30	; 0x1e
    1b18:	8f 3f       	cpi	r24, 0xFF	; 255
    1b1a:	19 f4       	brne	.+6      	; 0x1b22 <xQueueGenericSend+0xdc>
    1b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b20:	16 8e       	std	Z+30, r1	; 0x1e
    1b22:	0f 90       	pop	r0
    1b24:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1b26:	ce 01       	movw	r24, r28
    1b28:	05 96       	adiw	r24, 0x05	; 5
    1b2a:	9e 01       	movw	r18, r28
    1b2c:	24 5f       	subi	r18, 0xF4	; 244
    1b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b30:	b9 01       	movw	r22, r18
    1b32:	0e 94 99 17 	call	0x2f32	; 0x2f32 <xTaskCheckForTimeOut>
    1b36:	88 23       	and	r24, r24
    1b38:	09 f5       	brne	.+66     	; 0x1b7c <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1b3a:	89 81       	ldd	r24, Y+1	; 0x01
    1b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b3e:	0e 94 aa 11 	call	0x2354	; 0x2354 <prvIsQueueFull>
    1b42:	88 23       	and	r24, r24
    1b44:	a1 f0       	breq	.+40     	; 0x1b6e <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1b46:	89 81       	ldd	r24, Y+1	; 0x01
    1b48:	9a 81       	ldd	r25, Y+2	; 0x02
    1b4a:	08 96       	adiw	r24, 0x08	; 8
    1b4c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1b4e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1b50:	b9 01       	movw	r22, r18
    1b52:	0e 94 38 16 	call	0x2c70	; 0x2c70 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1b56:	89 81       	ldd	r24, Y+1	; 0x01
    1b58:	9a 81       	ldd	r25, Y+2	; 0x02
    1b5a:	0e 94 21 11 	call	0x2242	; 0x2242 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1b5e:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    1b62:	88 23       	and	r24, r24
    1b64:	09 f0       	breq	.+2      	; 0x1b68 <xQueueGenericSend+0x122>
    1b66:	85 cf       	rjmp	.-246    	; 0x1a72 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    1b68:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    1b6c:	82 cf       	rjmp	.-252    	; 0x1a72 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1b6e:	89 81       	ldd	r24, Y+1	; 0x01
    1b70:	9a 81       	ldd	r25, Y+2	; 0x02
    1b72:	0e 94 21 11 	call	0x2242	; 0x2242 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1b76:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    1b7a:	7b cf       	rjmp	.-266    	; 0x1a72 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b80:	0e 94 21 11 	call	0x2242	; 0x2242 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1b84:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1b88:	1f 86       	std	Y+15, r1	; 0x0f
    1b8a:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	}
}
    1b8c:	2f 96       	adiw	r28, 0x0f	; 15
    1b8e:	0f b6       	in	r0, 0x3f	; 63
    1b90:	f8 94       	cli
    1b92:	de bf       	out	0x3e, r29	; 62
    1b94:	0f be       	out	0x3f, r0	; 63
    1b96:	cd bf       	out	0x3d, r28	; 61
    1b98:	cf 91       	pop	r28
    1b9a:	df 91       	pop	r29
    1b9c:	08 95       	ret

00001b9e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1b9e:	df 93       	push	r29
    1ba0:	cf 93       	push	r28
    1ba2:	cd b7       	in	r28, 0x3d	; 61
    1ba4:	de b7       	in	r29, 0x3e	; 62
    1ba6:	2b 97       	sbiw	r28, 0x0b	; 11
    1ba8:	0f b6       	in	r0, 0x3f	; 63
    1baa:	f8 94       	cli
    1bac:	de bf       	out	0x3e, r29	; 62
    1bae:	0f be       	out	0x3f, r0	; 63
    1bb0:	cd bf       	out	0x3d, r28	; 61
    1bb2:	9e 83       	std	Y+6, r25	; 0x06
    1bb4:	8d 83       	std	Y+5, r24	; 0x05
    1bb6:	78 87       	std	Y+8, r23	; 0x08
    1bb8:	6f 83       	std	Y+7, r22	; 0x07
    1bba:	5a 87       	std	Y+10, r21	; 0x0a
    1bbc:	49 87       	std	Y+9, r20	; 0x09
    1bbe:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1bc0:	8d 81       	ldd	r24, Y+5	; 0x05
    1bc2:	9e 81       	ldd	r25, Y+6	; 0x06
    1bc4:	9a 83       	std	Y+2, r25	; 0x02
    1bc6:	89 83       	std	Y+1, r24	; 0x01
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1bc8:	1b 82       	std	Y+3, r1	; 0x03
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1bca:	e9 81       	ldd	r30, Y+1	; 0x01
    1bcc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bce:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bd4:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bd6:	98 17       	cp	r25, r24
    1bd8:	18 f0       	brcs	.+6      	; 0x1be0 <xQueueGenericSendFromISR+0x42>
    1bda:	8b 85       	ldd	r24, Y+11	; 0x0b
    1bdc:	82 30       	cpi	r24, 0x02	; 2
    1bde:	61 f5       	brne	.+88     	; 0x1c38 <xQueueGenericSendFromISR+0x9a>
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1be0:	89 81       	ldd	r24, Y+1	; 0x01
    1be2:	9a 81       	ldd	r25, Y+2	; 0x02
    1be4:	2f 81       	ldd	r18, Y+7	; 0x07
    1be6:	38 85       	ldd	r19, Y+8	; 0x08
    1be8:	b9 01       	movw	r22, r18
    1bea:	4b 85       	ldd	r20, Y+11	; 0x0b
    1bec:	0e 94 33 10 	call	0x2066	; 0x2066 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1bf0:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf2:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bf6:	8f 3f       	cpi	r24, 0xFF	; 255
    1bf8:	a9 f4       	brne	.+42     	; 0x1c24 <xQueueGenericSendFromISR+0x86>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfe:	81 89       	ldd	r24, Z+17	; 0x11
    1c00:	88 23       	and	r24, r24
    1c02:	b9 f0       	breq	.+46     	; 0x1c32 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c04:	89 81       	ldd	r24, Y+1	; 0x01
    1c06:	9a 81       	ldd	r25, Y+2	; 0x02
    1c08:	41 96       	adiw	r24, 0x11	; 17
    1c0a:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1c0e:	88 23       	and	r24, r24
    1c10:	81 f0       	breq	.+32     	; 0x1c32 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1c12:	89 85       	ldd	r24, Y+9	; 0x09
    1c14:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c16:	00 97       	sbiw	r24, 0x00	; 0
    1c18:	61 f0       	breq	.+24     	; 0x1c32 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1c1a:	e9 85       	ldd	r30, Y+9	; 0x09
    1c1c:	fa 85       	ldd	r31, Y+10	; 0x0a
    1c1e:	81 e0       	ldi	r24, 0x01	; 1
    1c20:	80 83       	st	Z, r24
    1c22:	07 c0       	rjmp	.+14     	; 0x1c32 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1c24:	e9 81       	ldd	r30, Y+1	; 0x01
    1c26:	fa 81       	ldd	r31, Y+2	; 0x02
    1c28:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c2a:	8f 5f       	subi	r24, 0xFF	; 255
    1c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c30:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1c32:	81 e0       	ldi	r24, 0x01	; 1
    1c34:	8c 83       	std	Y+4, r24	; 0x04
    1c36:	01 c0       	rjmp	.+2      	; 0x1c3a <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1c38:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1c3a:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1c3c:	2b 96       	adiw	r28, 0x0b	; 11
    1c3e:	0f b6       	in	r0, 0x3f	; 63
    1c40:	f8 94       	cli
    1c42:	de bf       	out	0x3e, r29	; 62
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	cd bf       	out	0x3d, r28	; 61
    1c48:	cf 91       	pop	r28
    1c4a:	df 91       	pop	r29
    1c4c:	08 95       	ret

00001c4e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1c4e:	df 93       	push	r29
    1c50:	cf 93       	push	r28
    1c52:	cd b7       	in	r28, 0x3d	; 61
    1c54:	de b7       	in	r29, 0x3e	; 62
    1c56:	28 97       	sbiw	r28, 0x08	; 8
    1c58:	0f b6       	in	r0, 0x3f	; 63
    1c5a:	f8 94       	cli
    1c5c:	de bf       	out	0x3e, r29	; 62
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	cd bf       	out	0x3d, r28	; 61
    1c62:	9e 83       	std	Y+6, r25	; 0x06
    1c64:	8d 83       	std	Y+5, r24	; 0x05
    1c66:	78 87       	std	Y+8, r23	; 0x08
    1c68:	6f 83       	std	Y+7, r22	; 0x07
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1c6a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c6c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c6e:	9a 83       	std	Y+2, r25	; 0x02
    1c70:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1c72:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1c74:	e9 81       	ldd	r30, Y+1	; 0x01
    1c76:	fa 81       	ldd	r31, Y+2	; 0x02
    1c78:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c80:	98 17       	cp	r25, r24
    1c82:	58 f5       	brcc	.+86     	; 0x1cda <xQueueGiveFromISR+0x8c>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1c84:	e9 81       	ldd	r30, Y+1	; 0x01
    1c86:	fa 81       	ldd	r31, Y+2	; 0x02
    1c88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c8a:	8f 5f       	subi	r24, 0xFF	; 255
    1c8c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c8e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c90:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1c92:	e9 81       	ldd	r30, Y+1	; 0x01
    1c94:	fa 81       	ldd	r31, Y+2	; 0x02
    1c96:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c98:	8f 3f       	cpi	r24, 0xFF	; 255
    1c9a:	a9 f4       	brne	.+42     	; 0x1cc6 <xQueueGiveFromISR+0x78>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca0:	81 89       	ldd	r24, Z+17	; 0x11
    1ca2:	88 23       	and	r24, r24
    1ca4:	b9 f0       	breq	.+46     	; 0x1cd4 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ca6:	89 81       	ldd	r24, Y+1	; 0x01
    1ca8:	9a 81       	ldd	r25, Y+2	; 0x02
    1caa:	41 96       	adiw	r24, 0x11	; 17
    1cac:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1cb0:	88 23       	and	r24, r24
    1cb2:	81 f0       	breq	.+32     	; 0x1cd4 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1cb4:	8f 81       	ldd	r24, Y+7	; 0x07
    1cb6:	98 85       	ldd	r25, Y+8	; 0x08
    1cb8:	00 97       	sbiw	r24, 0x00	; 0
    1cba:	61 f0       	breq	.+24     	; 0x1cd4 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1cbc:	ef 81       	ldd	r30, Y+7	; 0x07
    1cbe:	f8 85       	ldd	r31, Y+8	; 0x08
    1cc0:	81 e0       	ldi	r24, 0x01	; 1
    1cc2:	80 83       	st	Z, r24
    1cc4:	07 c0       	rjmp	.+14     	; 0x1cd4 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1cc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1cca:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ccc:	8f 5f       	subi	r24, 0xFF	; 255
    1cce:	e9 81       	ldd	r30, Y+1	; 0x01
    1cd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1cd2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1cd4:	81 e0       	ldi	r24, 0x01	; 1
    1cd6:	8c 83       	std	Y+4, r24	; 0x04
    1cd8:	01 c0       	rjmp	.+2      	; 0x1cdc <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1cda:	1c 82       	std	Y+4, r1	; 0x04
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1cdc:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1cde:	28 96       	adiw	r28, 0x08	; 8
    1ce0:	0f b6       	in	r0, 0x3f	; 63
    1ce2:	f8 94       	cli
    1ce4:	de bf       	out	0x3e, r29	; 62
    1ce6:	0f be       	out	0x3f, r0	; 63
    1ce8:	cd bf       	out	0x3d, r28	; 61
    1cea:	cf 91       	pop	r28
    1cec:	df 91       	pop	r29
    1cee:	08 95       	ret

00001cf0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1cf0:	df 93       	push	r29
    1cf2:	cf 93       	push	r28
    1cf4:	cd b7       	in	r28, 0x3d	; 61
    1cf6:	de b7       	in	r29, 0x3e	; 62
    1cf8:	60 97       	sbiw	r28, 0x10	; 16
    1cfa:	0f b6       	in	r0, 0x3f	; 63
    1cfc:	f8 94       	cli
    1cfe:	de bf       	out	0x3e, r29	; 62
    1d00:	0f be       	out	0x3f, r0	; 63
    1d02:	cd bf       	out	0x3d, r28	; 61
    1d04:	9a 87       	std	Y+10, r25	; 0x0a
    1d06:	89 87       	std	Y+9, r24	; 0x09
    1d08:	7c 87       	std	Y+12, r23	; 0x0c
    1d0a:	6b 87       	std	Y+11, r22	; 0x0b
    1d0c:	5e 87       	std	Y+14, r21	; 0x0e
    1d0e:	4d 87       	std	Y+13, r20	; 0x0d
    1d10:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    1d12:	1d 82       	std	Y+5, r1	; 0x05
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1d14:	89 85       	ldd	r24, Y+9	; 0x09
    1d16:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d18:	9a 83       	std	Y+2, r25	; 0x02
    1d1a:	89 83       	std	Y+1, r24	; 0x01
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1d1c:	0f b6       	in	r0, 0x3f	; 63
    1d1e:	f8 94       	cli
    1d20:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d22:	e9 81       	ldd	r30, Y+1	; 0x01
    1d24:	fa 81       	ldd	r31, Y+2	; 0x02
    1d26:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d28:	88 23       	and	r24, r24
    1d2a:	09 f4       	brne	.+2      	; 0x1d2e <xQueueGenericReceive+0x3e>
    1d2c:	3f c0       	rjmp	.+126    	; 0x1dac <xQueueGenericReceive+0xbc>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1d2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d30:	fa 81       	ldd	r31, Y+2	; 0x02
    1d32:	86 81       	ldd	r24, Z+6	; 0x06
    1d34:	97 81       	ldd	r25, Z+7	; 0x07
    1d36:	9c 83       	std	Y+4, r25	; 0x04
    1d38:	8b 83       	std	Y+3, r24	; 0x03

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d3a:	89 81       	ldd	r24, Y+1	; 0x01
    1d3c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d3e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1d40:	3c 85       	ldd	r19, Y+12	; 0x0c
    1d42:	b9 01       	movw	r22, r18
    1d44:	0e 94 da 10 	call	0x21b4	; 0x21b4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1d48:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d4a:	88 23       	and	r24, r24
    1d4c:	b1 f4       	brne	.+44     	; 0x1d7a <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1d4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d50:	fa 81       	ldd	r31, Y+2	; 0x02
    1d52:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d54:	81 50       	subi	r24, 0x01	; 1
    1d56:	e9 81       	ldd	r30, Y+1	; 0x01
    1d58:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5a:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d60:	80 85       	ldd	r24, Z+8	; 0x08
    1d62:	88 23       	and	r24, r24
    1d64:	f1 f0       	breq	.+60     	; 0x1da2 <xQueueGenericReceive+0xb2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1d66:	89 81       	ldd	r24, Y+1	; 0x01
    1d68:	9a 81       	ldd	r25, Y+2	; 0x02
    1d6a:	08 96       	adiw	r24, 0x08	; 8
    1d6c:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1d70:	81 30       	cpi	r24, 0x01	; 1
    1d72:	b9 f4       	brne	.+46     	; 0x1da2 <xQueueGenericReceive+0xb2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1d74:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    1d78:	14 c0       	rjmp	.+40     	; 0x1da2 <xQueueGenericReceive+0xb2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d80:	9c 81       	ldd	r25, Y+4	; 0x04
    1d82:	97 83       	std	Z+7, r25	; 0x07
    1d84:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d86:	e9 81       	ldd	r30, Y+1	; 0x01
    1d88:	fa 81       	ldd	r31, Y+2	; 0x02
    1d8a:	81 89       	ldd	r24, Z+17	; 0x11
    1d8c:	88 23       	and	r24, r24
    1d8e:	49 f0       	breq	.+18     	; 0x1da2 <xQueueGenericReceive+0xb2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d90:	89 81       	ldd	r24, Y+1	; 0x01
    1d92:	9a 81       	ldd	r25, Y+2	; 0x02
    1d94:	41 96       	adiw	r24, 0x11	; 17
    1d96:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1d9a:	88 23       	and	r24, r24
    1d9c:	11 f0       	breq	.+4      	; 0x1da2 <xQueueGenericReceive+0xb2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1d9e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1da2:	0f 90       	pop	r0
    1da4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1da6:	81 e0       	ldi	r24, 0x01	; 1
    1da8:	88 8b       	std	Y+16, r24	; 0x10
    1daa:	5c c0       	rjmp	.+184    	; 0x1e64 <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1dac:	8d 85       	ldd	r24, Y+13	; 0x0d
    1dae:	9e 85       	ldd	r25, Y+14	; 0x0e
    1db0:	00 97       	sbiw	r24, 0x00	; 0
    1db2:	21 f4       	brne	.+8      	; 0x1dbc <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1db4:	0f 90       	pop	r0
    1db6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1db8:	18 8a       	std	Y+16, r1	; 0x10
    1dba:	54 c0       	rjmp	.+168    	; 0x1e64 <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
    1dbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1dbe:	88 23       	and	r24, r24
    1dc0:	31 f4       	brne	.+12     	; 0x1dce <xQueueGenericReceive+0xde>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1dc2:	ce 01       	movw	r24, r28
    1dc4:	06 96       	adiw	r24, 0x06	; 6
    1dc6:	0e 94 80 17 	call	0x2f00	; 0x2f00 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	8d 83       	std	Y+5, r24	; 0x05
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1dce:	0f 90       	pop	r0
    1dd0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1dd2:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1dd6:	0f b6       	in	r0, 0x3f	; 63
    1dd8:	f8 94       	cli
    1dda:	0f 92       	push	r0
    1ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    1dde:	fa 81       	ldd	r31, Y+2	; 0x02
    1de0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1de2:	8f 3f       	cpi	r24, 0xFF	; 255
    1de4:	19 f4       	brne	.+6      	; 0x1dec <xQueueGenericReceive+0xfc>
    1de6:	e9 81       	ldd	r30, Y+1	; 0x01
    1de8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dea:	15 8e       	std	Z+29, r1	; 0x1d
    1dec:	e9 81       	ldd	r30, Y+1	; 0x01
    1dee:	fa 81       	ldd	r31, Y+2	; 0x02
    1df0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1df2:	8f 3f       	cpi	r24, 0xFF	; 255
    1df4:	19 f4       	brne	.+6      	; 0x1dfc <xQueueGenericReceive+0x10c>
    1df6:	e9 81       	ldd	r30, Y+1	; 0x01
    1df8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfa:	16 8e       	std	Z+30, r1	; 0x1e
    1dfc:	0f 90       	pop	r0
    1dfe:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1e00:	ce 01       	movw	r24, r28
    1e02:	06 96       	adiw	r24, 0x06	; 6
    1e04:	9e 01       	movw	r18, r28
    1e06:	23 5f       	subi	r18, 0xF3	; 243
    1e08:	3f 4f       	sbci	r19, 0xFF	; 255
    1e0a:	b9 01       	movw	r22, r18
    1e0c:	0e 94 99 17 	call	0x2f32	; 0x2f32 <xTaskCheckForTimeOut>
    1e10:	88 23       	and	r24, r24
    1e12:	09 f5       	brne	.+66     	; 0x1e56 <xQueueGenericReceive+0x166>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1e14:	89 81       	ldd	r24, Y+1	; 0x01
    1e16:	9a 81       	ldd	r25, Y+2	; 0x02
    1e18:	0e 94 75 11 	call	0x22ea	; 0x22ea <prvIsQueueEmpty>
    1e1c:	88 23       	and	r24, r24
    1e1e:	a1 f0       	breq	.+40     	; 0x1e48 <xQueueGenericReceive+0x158>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e20:	89 81       	ldd	r24, Y+1	; 0x01
    1e22:	9a 81       	ldd	r25, Y+2	; 0x02
    1e24:	41 96       	adiw	r24, 0x11	; 17
    1e26:	2d 85       	ldd	r18, Y+13	; 0x0d
    1e28:	3e 85       	ldd	r19, Y+14	; 0x0e
    1e2a:	b9 01       	movw	r22, r18
    1e2c:	0e 94 38 16 	call	0x2c70	; 0x2c70 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1e30:	89 81       	ldd	r24, Y+1	; 0x01
    1e32:	9a 81       	ldd	r25, Y+2	; 0x02
    1e34:	0e 94 21 11 	call	0x2242	; 0x2242 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1e38:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    1e3c:	88 23       	and	r24, r24
    1e3e:	09 f0       	breq	.+2      	; 0x1e42 <xQueueGenericReceive+0x152>
    1e40:	6d cf       	rjmp	.-294    	; 0x1d1c <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1e42:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    1e46:	6a cf       	rjmp	.-300    	; 0x1d1c <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1e48:	89 81       	ldd	r24, Y+1	; 0x01
    1e4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1e4c:	0e 94 21 11 	call	0x2242	; 0x2242 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e50:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    1e54:	63 cf       	rjmp	.-314    	; 0x1d1c <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1e56:	89 81       	ldd	r24, Y+1	; 0x01
    1e58:	9a 81       	ldd	r25, Y+2	; 0x02
    1e5a:	0e 94 21 11 	call	0x2242	; 0x2242 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e5e:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1e62:	18 8a       	std	Y+16, r1	; 0x10
    1e64:	88 89       	ldd	r24, Y+16	; 0x10
		}
	}
}
    1e66:	60 96       	adiw	r28, 0x10	; 16
    1e68:	0f b6       	in	r0, 0x3f	; 63
    1e6a:	f8 94       	cli
    1e6c:	de bf       	out	0x3e, r29	; 62
    1e6e:	0f be       	out	0x3f, r0	; 63
    1e70:	cd bf       	out	0x3d, r28	; 61
    1e72:	cf 91       	pop	r28
    1e74:	df 91       	pop	r29
    1e76:	08 95       	ret

00001e78 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1e78:	df 93       	push	r29
    1e7a:	cf 93       	push	r28
    1e7c:	cd b7       	in	r28, 0x3d	; 61
    1e7e:	de b7       	in	r29, 0x3e	; 62
    1e80:	2a 97       	sbiw	r28, 0x0a	; 10
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	de bf       	out	0x3e, r29	; 62
    1e88:	0f be       	out	0x3f, r0	; 63
    1e8a:	cd bf       	out	0x3d, r28	; 61
    1e8c:	9e 83       	std	Y+6, r25	; 0x06
    1e8e:	8d 83       	std	Y+5, r24	; 0x05
    1e90:	78 87       	std	Y+8, r23	; 0x08
    1e92:	6f 83       	std	Y+7, r22	; 0x07
    1e94:	5a 87       	std	Y+10, r21	; 0x0a
    1e96:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1e98:	8d 81       	ldd	r24, Y+5	; 0x05
    1e9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e9c:	9a 83       	std	Y+2, r25	; 0x02
    1e9e:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ea0:	1b 82       	std	Y+3, r1	; 0x03
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ea2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ea4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ea6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ea8:	88 23       	and	r24, r24
    1eaa:	91 f1       	breq	.+100    	; 0x1f10 <xQueueReceiveFromISR+0x98>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1eac:	89 81       	ldd	r24, Y+1	; 0x01
    1eae:	9a 81       	ldd	r25, Y+2	; 0x02
    1eb0:	2f 81       	ldd	r18, Y+7	; 0x07
    1eb2:	38 85       	ldd	r19, Y+8	; 0x08
    1eb4:	b9 01       	movw	r22, r18
    1eb6:	0e 94 da 10 	call	0x21b4	; 0x21b4 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1eba:	e9 81       	ldd	r30, Y+1	; 0x01
    1ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ebe:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec0:	81 50       	subi	r24, 0x01	; 1
    1ec2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec6:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    1eca:	fa 81       	ldd	r31, Y+2	; 0x02
    1ecc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ece:	8f 3f       	cpi	r24, 0xFF	; 255
    1ed0:	a9 f4       	brne	.+42     	; 0x1efc <xQueueReceiveFromISR+0x84>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ed2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed6:	80 85       	ldd	r24, Z+8	; 0x08
    1ed8:	88 23       	and	r24, r24
    1eda:	b9 f0       	breq	.+46     	; 0x1f0a <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1edc:	89 81       	ldd	r24, Y+1	; 0x01
    1ede:	9a 81       	ldd	r25, Y+2	; 0x02
    1ee0:	08 96       	adiw	r24, 0x08	; 8
    1ee2:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    1ee6:	88 23       	and	r24, r24
    1ee8:	81 f0       	breq	.+32     	; 0x1f0a <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1eea:	89 85       	ldd	r24, Y+9	; 0x09
    1eec:	9a 85       	ldd	r25, Y+10	; 0x0a
    1eee:	00 97       	sbiw	r24, 0x00	; 0
    1ef0:	61 f0       	breq	.+24     	; 0x1f0a <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1ef2:	e9 85       	ldd	r30, Y+9	; 0x09
    1ef4:	fa 85       	ldd	r31, Y+10	; 0x0a
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	80 83       	st	Z, r24
    1efa:	07 c0       	rjmp	.+14     	; 0x1f0a <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1efc:	e9 81       	ldd	r30, Y+1	; 0x01
    1efe:	fa 81       	ldd	r31, Y+2	; 0x02
    1f00:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f02:	8f 5f       	subi	r24, 0xFF	; 255
    1f04:	e9 81       	ldd	r30, Y+1	; 0x01
    1f06:	fa 81       	ldd	r31, Y+2	; 0x02
    1f08:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1f0a:	81 e0       	ldi	r24, 0x01	; 1
    1f0c:	8c 83       	std	Y+4, r24	; 0x04
    1f0e:	01 c0       	rjmp	.+2      	; 0x1f12 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1f10:	1c 82       	std	Y+4, r1	; 0x04
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f12:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1f14:	2a 96       	adiw	r28, 0x0a	; 10
    1f16:	0f b6       	in	r0, 0x3f	; 63
    1f18:	f8 94       	cli
    1f1a:	de bf       	out	0x3e, r29	; 62
    1f1c:	0f be       	out	0x3f, r0	; 63
    1f1e:	cd bf       	out	0x3d, r28	; 61
    1f20:	cf 91       	pop	r28
    1f22:	df 91       	pop	r29
    1f24:	08 95       	ret

00001f26 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1f26:	df 93       	push	r29
    1f28:	cf 93       	push	r28
    1f2a:	cd b7       	in	r28, 0x3d	; 61
    1f2c:	de b7       	in	r29, 0x3e	; 62
    1f2e:	2a 97       	sbiw	r28, 0x0a	; 10
    1f30:	0f b6       	in	r0, 0x3f	; 63
    1f32:	f8 94       	cli
    1f34:	de bf       	out	0x3e, r29	; 62
    1f36:	0f be       	out	0x3f, r0	; 63
    1f38:	cd bf       	out	0x3d, r28	; 61
    1f3a:	98 87       	std	Y+8, r25	; 0x08
    1f3c:	8f 83       	std	Y+7, r24	; 0x07
    1f3e:	7a 87       	std	Y+10, r23	; 0x0a
    1f40:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1f42:	8f 81       	ldd	r24, Y+7	; 0x07
    1f44:	98 85       	ldd	r25, Y+8	; 0x08
    1f46:	9a 83       	std	Y+2, r25	; 0x02
    1f48:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f4a:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f50:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f52:	88 23       	and	r24, r24
    1f54:	b1 f0       	breq	.+44     	; 0x1f82 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1f56:	e9 81       	ldd	r30, Y+1	; 0x01
    1f58:	fa 81       	ldd	r31, Y+2	; 0x02
    1f5a:	86 81       	ldd	r24, Z+6	; 0x06
    1f5c:	97 81       	ldd	r25, Z+7	; 0x07
    1f5e:	9c 83       	std	Y+4, r25	; 0x04
    1f60:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f62:	89 81       	ldd	r24, Y+1	; 0x01
    1f64:	9a 81       	ldd	r25, Y+2	; 0x02
    1f66:	29 85       	ldd	r18, Y+9	; 0x09
    1f68:	3a 85       	ldd	r19, Y+10	; 0x0a
    1f6a:	b9 01       	movw	r22, r18
    1f6c:	0e 94 da 10 	call	0x21b4	; 0x21b4 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1f70:	e9 81       	ldd	r30, Y+1	; 0x01
    1f72:	fa 81       	ldd	r31, Y+2	; 0x02
    1f74:	8b 81       	ldd	r24, Y+3	; 0x03
    1f76:	9c 81       	ldd	r25, Y+4	; 0x04
    1f78:	97 83       	std	Z+7, r25	; 0x07
    1f7a:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1f7c:	81 e0       	ldi	r24, 0x01	; 1
    1f7e:	8e 83       	std	Y+6, r24	; 0x06
    1f80:	01 c0       	rjmp	.+2      	; 0x1f84 <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1f82:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1f84:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1f86:	2a 96       	adiw	r28, 0x0a	; 10
    1f88:	0f b6       	in	r0, 0x3f	; 63
    1f8a:	f8 94       	cli
    1f8c:	de bf       	out	0x3e, r29	; 62
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	cd bf       	out	0x3d, r28	; 61
    1f92:	cf 91       	pop	r28
    1f94:	df 91       	pop	r29
    1f96:	08 95       	ret

00001f98 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1f98:	df 93       	push	r29
    1f9a:	cf 93       	push	r28
    1f9c:	00 d0       	rcall	.+0      	; 0x1f9e <uxQueueMessagesWaiting+0x6>
    1f9e:	0f 92       	push	r0
    1fa0:	cd b7       	in	r28, 0x3d	; 61
    1fa2:	de b7       	in	r29, 0x3e	; 62
    1fa4:	9b 83       	std	Y+3, r25	; 0x03
    1fa6:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1fa8:	0f b6       	in	r0, 0x3f	; 63
    1faa:	f8 94       	cli
    1fac:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1fae:	ea 81       	ldd	r30, Y+2	; 0x02
    1fb0:	fb 81       	ldd	r31, Y+3	; 0x03
    1fb2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fb4:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1fb6:	0f 90       	pop	r0
    1fb8:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1fba:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1fbc:	0f 90       	pop	r0
    1fbe:	0f 90       	pop	r0
    1fc0:	0f 90       	pop	r0
    1fc2:	cf 91       	pop	r28
    1fc4:	df 91       	pop	r29
    1fc6:	08 95       	ret

00001fc8 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1fc8:	df 93       	push	r29
    1fca:	cf 93       	push	r28
    1fcc:	00 d0       	rcall	.+0      	; 0x1fce <uxQueueSpacesAvailable+0x6>
    1fce:	00 d0       	rcall	.+0      	; 0x1fd0 <uxQueueSpacesAvailable+0x8>
    1fd0:	0f 92       	push	r0
    1fd2:	cd b7       	in	r28, 0x3d	; 61
    1fd4:	de b7       	in	r29, 0x3e	; 62
    1fd6:	9d 83       	std	Y+5, r25	; 0x05
    1fd8:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
    1fda:	8c 81       	ldd	r24, Y+4	; 0x04
    1fdc:	9d 81       	ldd	r25, Y+5	; 0x05
    1fde:	9a 83       	std	Y+2, r25	; 0x02
    1fe0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1fe2:	0f b6       	in	r0, 0x3f	; 63
    1fe4:	f8 94       	cli
    1fe6:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    1fea:	fa 81       	ldd	r31, Y+2	; 0x02
    1fec:	93 8d       	ldd	r25, Z+27	; 0x1b
    1fee:	e9 81       	ldd	r30, Y+1	; 0x01
    1ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ff2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ff4:	29 2f       	mov	r18, r25
    1ff6:	28 1b       	sub	r18, r24
    1ff8:	82 2f       	mov	r24, r18
    1ffa:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1ffc:	0f 90       	pop	r0
    1ffe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2000:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2002:	0f 90       	pop	r0
    2004:	0f 90       	pop	r0
    2006:	0f 90       	pop	r0
    2008:	0f 90       	pop	r0
    200a:	0f 90       	pop	r0
    200c:	cf 91       	pop	r28
    200e:	df 91       	pop	r29
    2010:	08 95       	ret

00002012 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2012:	df 93       	push	r29
    2014:	cf 93       	push	r28
    2016:	00 d0       	rcall	.+0      	; 0x2018 <uxQueueMessagesWaitingFromISR+0x6>
    2018:	0f 92       	push	r0
    201a:	cd b7       	in	r28, 0x3d	; 61
    201c:	de b7       	in	r29, 0x3e	; 62
    201e:	9b 83       	std	Y+3, r25	; 0x03
    2020:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2022:	ea 81       	ldd	r30, Y+2	; 0x02
    2024:	fb 81       	ldd	r31, Y+3	; 0x03
    2026:	82 8d       	ldd	r24, Z+26	; 0x1a
    2028:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    202a:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    202c:	0f 90       	pop	r0
    202e:	0f 90       	pop	r0
    2030:	0f 90       	pop	r0
    2032:	cf 91       	pop	r28
    2034:	df 91       	pop	r29
    2036:	08 95       	ret

00002038 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2038:	df 93       	push	r29
    203a:	cf 93       	push	r28
    203c:	00 d0       	rcall	.+0      	; 0x203e <vQueueDelete+0x6>
    203e:	00 d0       	rcall	.+0      	; 0x2040 <vQueueDelete+0x8>
    2040:	cd b7       	in	r28, 0x3d	; 61
    2042:	de b7       	in	r29, 0x3e	; 62
    2044:	9c 83       	std	Y+4, r25	; 0x04
    2046:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    2048:	8b 81       	ldd	r24, Y+3	; 0x03
    204a:	9c 81       	ldd	r25, Y+4	; 0x04
    204c:	9a 83       	std	Y+2, r25	; 0x02
    204e:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue );
    2050:	89 81       	ldd	r24, Y+1	; 0x01
    2052:	9a 81       	ldd	r25, Y+2	; 0x02
    2054:	0e 94 98 06 	call	0xd30	; 0xd30 <vPortFree>
}
    2058:	0f 90       	pop	r0
    205a:	0f 90       	pop	r0
    205c:	0f 90       	pop	r0
    205e:	0f 90       	pop	r0
    2060:	cf 91       	pop	r28
    2062:	df 91       	pop	r29
    2064:	08 95       	ret

00002066 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    2066:	df 93       	push	r29
    2068:	cf 93       	push	r28
    206a:	00 d0       	rcall	.+0      	; 0x206c <prvCopyDataToQueue+0x6>
    206c:	00 d0       	rcall	.+0      	; 0x206e <prvCopyDataToQueue+0x8>
    206e:	00 d0       	rcall	.+0      	; 0x2070 <prvCopyDataToQueue+0xa>
    2070:	cd b7       	in	r28, 0x3d	; 61
    2072:	de b7       	in	r29, 0x3e	; 62
    2074:	9b 83       	std	Y+3, r25	; 0x03
    2076:	8a 83       	std	Y+2, r24	; 0x02
    2078:	7d 83       	std	Y+5, r23	; 0x05
    207a:	6c 83       	std	Y+4, r22	; 0x04
    207c:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    207e:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2080:	ea 81       	ldd	r30, Y+2	; 0x02
    2082:	fb 81       	ldd	r31, Y+3	; 0x03
    2084:	84 8d       	ldd	r24, Z+28	; 0x1c
    2086:	88 23       	and	r24, r24
    2088:	09 f4       	brne	.+2      	; 0x208c <prvCopyDataToQueue+0x26>
    208a:	83 c0       	rjmp	.+262    	; 0x2192 <prvCopyDataToQueue+0x12c>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    208c:	8e 81       	ldd	r24, Y+6	; 0x06
    208e:	88 23       	and	r24, r24
    2090:	99 f5       	brne	.+102    	; 0x20f8 <prvCopyDataToQueue+0x92>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    2092:	ea 81       	ldd	r30, Y+2	; 0x02
    2094:	fb 81       	ldd	r31, Y+3	; 0x03
    2096:	64 81       	ldd	r22, Z+4	; 0x04
    2098:	75 81       	ldd	r23, Z+5	; 0x05
    209a:	ea 81       	ldd	r30, Y+2	; 0x02
    209c:	fb 81       	ldd	r31, Y+3	; 0x03
    209e:	84 8d       	ldd	r24, Z+28	; 0x1c
    20a0:	48 2f       	mov	r20, r24
    20a2:	50 e0       	ldi	r21, 0x00	; 0
    20a4:	2c 81       	ldd	r18, Y+4	; 0x04
    20a6:	3d 81       	ldd	r19, Y+5	; 0x05
    20a8:	cb 01       	movw	r24, r22
    20aa:	b9 01       	movw	r22, r18
    20ac:	0e 94 a6 34 	call	0x694c	; 0x694c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    20b0:	ea 81       	ldd	r30, Y+2	; 0x02
    20b2:	fb 81       	ldd	r31, Y+3	; 0x03
    20b4:	24 81       	ldd	r18, Z+4	; 0x04
    20b6:	35 81       	ldd	r19, Z+5	; 0x05
    20b8:	ea 81       	ldd	r30, Y+2	; 0x02
    20ba:	fb 81       	ldd	r31, Y+3	; 0x03
    20bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    20be:	88 2f       	mov	r24, r24
    20c0:	90 e0       	ldi	r25, 0x00	; 0
    20c2:	82 0f       	add	r24, r18
    20c4:	93 1f       	adc	r25, r19
    20c6:	ea 81       	ldd	r30, Y+2	; 0x02
    20c8:	fb 81       	ldd	r31, Y+3	; 0x03
    20ca:	95 83       	std	Z+5, r25	; 0x05
    20cc:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    20ce:	ea 81       	ldd	r30, Y+2	; 0x02
    20d0:	fb 81       	ldd	r31, Y+3	; 0x03
    20d2:	24 81       	ldd	r18, Z+4	; 0x04
    20d4:	35 81       	ldd	r19, Z+5	; 0x05
    20d6:	ea 81       	ldd	r30, Y+2	; 0x02
    20d8:	fb 81       	ldd	r31, Y+3	; 0x03
    20da:	82 81       	ldd	r24, Z+2	; 0x02
    20dc:	93 81       	ldd	r25, Z+3	; 0x03
    20de:	28 17       	cp	r18, r24
    20e0:	39 07       	cpc	r19, r25
    20e2:	08 f4       	brcc	.+2      	; 0x20e6 <prvCopyDataToQueue+0x80>
    20e4:	56 c0       	rjmp	.+172    	; 0x2192 <prvCopyDataToQueue+0x12c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    20e6:	ea 81       	ldd	r30, Y+2	; 0x02
    20e8:	fb 81       	ldd	r31, Y+3	; 0x03
    20ea:	80 81       	ld	r24, Z
    20ec:	91 81       	ldd	r25, Z+1	; 0x01
    20ee:	ea 81       	ldd	r30, Y+2	; 0x02
    20f0:	fb 81       	ldd	r31, Y+3	; 0x03
    20f2:	95 83       	std	Z+5, r25	; 0x05
    20f4:	84 83       	std	Z+4, r24	; 0x04
    20f6:	4d c0       	rjmp	.+154    	; 0x2192 <prvCopyDataToQueue+0x12c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20f8:	ea 81       	ldd	r30, Y+2	; 0x02
    20fa:	fb 81       	ldd	r31, Y+3	; 0x03
    20fc:	66 81       	ldd	r22, Z+6	; 0x06
    20fe:	77 81       	ldd	r23, Z+7	; 0x07
    2100:	ea 81       	ldd	r30, Y+2	; 0x02
    2102:	fb 81       	ldd	r31, Y+3	; 0x03
    2104:	84 8d       	ldd	r24, Z+28	; 0x1c
    2106:	48 2f       	mov	r20, r24
    2108:	50 e0       	ldi	r21, 0x00	; 0
    210a:	2c 81       	ldd	r18, Y+4	; 0x04
    210c:	3d 81       	ldd	r19, Y+5	; 0x05
    210e:	cb 01       	movw	r24, r22
    2110:	b9 01       	movw	r22, r18
    2112:	0e 94 a6 34 	call	0x694c	; 0x694c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    2116:	ea 81       	ldd	r30, Y+2	; 0x02
    2118:	fb 81       	ldd	r31, Y+3	; 0x03
    211a:	26 81       	ldd	r18, Z+6	; 0x06
    211c:	37 81       	ldd	r19, Z+7	; 0x07
    211e:	ea 81       	ldd	r30, Y+2	; 0x02
    2120:	fb 81       	ldd	r31, Y+3	; 0x03
    2122:	84 8d       	ldd	r24, Z+28	; 0x1c
    2124:	88 2f       	mov	r24, r24
    2126:	90 e0       	ldi	r25, 0x00	; 0
    2128:	90 95       	com	r25
    212a:	81 95       	neg	r24
    212c:	9f 4f       	sbci	r25, 0xFF	; 255
    212e:	82 0f       	add	r24, r18
    2130:	93 1f       	adc	r25, r19
    2132:	ea 81       	ldd	r30, Y+2	; 0x02
    2134:	fb 81       	ldd	r31, Y+3	; 0x03
    2136:	97 83       	std	Z+7, r25	; 0x07
    2138:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    213a:	ea 81       	ldd	r30, Y+2	; 0x02
    213c:	fb 81       	ldd	r31, Y+3	; 0x03
    213e:	26 81       	ldd	r18, Z+6	; 0x06
    2140:	37 81       	ldd	r19, Z+7	; 0x07
    2142:	ea 81       	ldd	r30, Y+2	; 0x02
    2144:	fb 81       	ldd	r31, Y+3	; 0x03
    2146:	80 81       	ld	r24, Z
    2148:	91 81       	ldd	r25, Z+1	; 0x01
    214a:	28 17       	cp	r18, r24
    214c:	39 07       	cpc	r19, r25
    214e:	90 f4       	brcc	.+36     	; 0x2174 <prvCopyDataToQueue+0x10e>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2150:	ea 81       	ldd	r30, Y+2	; 0x02
    2152:	fb 81       	ldd	r31, Y+3	; 0x03
    2154:	22 81       	ldd	r18, Z+2	; 0x02
    2156:	33 81       	ldd	r19, Z+3	; 0x03
    2158:	ea 81       	ldd	r30, Y+2	; 0x02
    215a:	fb 81       	ldd	r31, Y+3	; 0x03
    215c:	84 8d       	ldd	r24, Z+28	; 0x1c
    215e:	88 2f       	mov	r24, r24
    2160:	90 e0       	ldi	r25, 0x00	; 0
    2162:	90 95       	com	r25
    2164:	81 95       	neg	r24
    2166:	9f 4f       	sbci	r25, 0xFF	; 255
    2168:	82 0f       	add	r24, r18
    216a:	93 1f       	adc	r25, r19
    216c:	ea 81       	ldd	r30, Y+2	; 0x02
    216e:	fb 81       	ldd	r31, Y+3	; 0x03
    2170:	97 83       	std	Z+7, r25	; 0x07
    2172:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    2174:	8e 81       	ldd	r24, Y+6	; 0x06
    2176:	82 30       	cpi	r24, 0x02	; 2
    2178:	61 f4       	brne	.+24     	; 0x2192 <prvCopyDataToQueue+0x12c>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    217a:	ea 81       	ldd	r30, Y+2	; 0x02
    217c:	fb 81       	ldd	r31, Y+3	; 0x03
    217e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2180:	88 23       	and	r24, r24
    2182:	39 f0       	breq	.+14     	; 0x2192 <prvCopyDataToQueue+0x12c>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    2184:	ea 81       	ldd	r30, Y+2	; 0x02
    2186:	fb 81       	ldd	r31, Y+3	; 0x03
    2188:	82 8d       	ldd	r24, Z+26	; 0x1a
    218a:	81 50       	subi	r24, 0x01	; 1
    218c:	ea 81       	ldd	r30, Y+2	; 0x02
    218e:	fb 81       	ldd	r31, Y+3	; 0x03
    2190:	82 8f       	std	Z+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    2192:	ea 81       	ldd	r30, Y+2	; 0x02
    2194:	fb 81       	ldd	r31, Y+3	; 0x03
    2196:	82 8d       	ldd	r24, Z+26	; 0x1a
    2198:	8f 5f       	subi	r24, 0xFF	; 255
    219a:	ea 81       	ldd	r30, Y+2	; 0x02
    219c:	fb 81       	ldd	r31, Y+3	; 0x03
    219e:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    21a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    21a2:	26 96       	adiw	r28, 0x06	; 6
    21a4:	0f b6       	in	r0, 0x3f	; 63
    21a6:	f8 94       	cli
    21a8:	de bf       	out	0x3e, r29	; 62
    21aa:	0f be       	out	0x3f, r0	; 63
    21ac:	cd bf       	out	0x3d, r28	; 61
    21ae:	cf 91       	pop	r28
    21b0:	df 91       	pop	r29
    21b2:	08 95       	ret

000021b4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    21b4:	df 93       	push	r29
    21b6:	cf 93       	push	r28
    21b8:	00 d0       	rcall	.+0      	; 0x21ba <prvCopyDataFromQueue+0x6>
    21ba:	00 d0       	rcall	.+0      	; 0x21bc <prvCopyDataFromQueue+0x8>
    21bc:	cd b7       	in	r28, 0x3d	; 61
    21be:	de b7       	in	r29, 0x3e	; 62
    21c0:	9a 83       	std	Y+2, r25	; 0x02
    21c2:	89 83       	std	Y+1, r24	; 0x01
    21c4:	7c 83       	std	Y+4, r23	; 0x04
    21c6:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    21c8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ca:	fa 81       	ldd	r31, Y+2	; 0x02
    21cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    21ce:	88 23       	and	r24, r24
    21d0:	89 f1       	breq	.+98     	; 0x2234 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    21d2:	e9 81       	ldd	r30, Y+1	; 0x01
    21d4:	fa 81       	ldd	r31, Y+2	; 0x02
    21d6:	26 81       	ldd	r18, Z+6	; 0x06
    21d8:	37 81       	ldd	r19, Z+7	; 0x07
    21da:	e9 81       	ldd	r30, Y+1	; 0x01
    21dc:	fa 81       	ldd	r31, Y+2	; 0x02
    21de:	84 8d       	ldd	r24, Z+28	; 0x1c
    21e0:	88 2f       	mov	r24, r24
    21e2:	90 e0       	ldi	r25, 0x00	; 0
    21e4:	82 0f       	add	r24, r18
    21e6:	93 1f       	adc	r25, r19
    21e8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ea:	fa 81       	ldd	r31, Y+2	; 0x02
    21ec:	97 83       	std	Z+7, r25	; 0x07
    21ee:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    21f0:	e9 81       	ldd	r30, Y+1	; 0x01
    21f2:	fa 81       	ldd	r31, Y+2	; 0x02
    21f4:	26 81       	ldd	r18, Z+6	; 0x06
    21f6:	37 81       	ldd	r19, Z+7	; 0x07
    21f8:	e9 81       	ldd	r30, Y+1	; 0x01
    21fa:	fa 81       	ldd	r31, Y+2	; 0x02
    21fc:	82 81       	ldd	r24, Z+2	; 0x02
    21fe:	93 81       	ldd	r25, Z+3	; 0x03
    2200:	28 17       	cp	r18, r24
    2202:	39 07       	cpc	r19, r25
    2204:	40 f0       	brcs	.+16     	; 0x2216 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2206:	e9 81       	ldd	r30, Y+1	; 0x01
    2208:	fa 81       	ldd	r31, Y+2	; 0x02
    220a:	80 81       	ld	r24, Z
    220c:	91 81       	ldd	r25, Z+1	; 0x01
    220e:	e9 81       	ldd	r30, Y+1	; 0x01
    2210:	fa 81       	ldd	r31, Y+2	; 0x02
    2212:	97 83       	std	Z+7, r25	; 0x07
    2214:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2216:	e9 81       	ldd	r30, Y+1	; 0x01
    2218:	fa 81       	ldd	r31, Y+2	; 0x02
    221a:	46 81       	ldd	r20, Z+6	; 0x06
    221c:	57 81       	ldd	r21, Z+7	; 0x07
    221e:	e9 81       	ldd	r30, Y+1	; 0x01
    2220:	fa 81       	ldd	r31, Y+2	; 0x02
    2222:	84 8d       	ldd	r24, Z+28	; 0x1c
    2224:	28 2f       	mov	r18, r24
    2226:	30 e0       	ldi	r19, 0x00	; 0
    2228:	8b 81       	ldd	r24, Y+3	; 0x03
    222a:	9c 81       	ldd	r25, Y+4	; 0x04
    222c:	ba 01       	movw	r22, r20
    222e:	a9 01       	movw	r20, r18
    2230:	0e 94 a6 34 	call	0x694c	; 0x694c <memcpy>
	}
}
    2234:	0f 90       	pop	r0
    2236:	0f 90       	pop	r0
    2238:	0f 90       	pop	r0
    223a:	0f 90       	pop	r0
    223c:	cf 91       	pop	r28
    223e:	df 91       	pop	r29
    2240:	08 95       	ret

00002242 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2242:	df 93       	push	r29
    2244:	cf 93       	push	r28
    2246:	00 d0       	rcall	.+0      	; 0x2248 <prvUnlockQueue+0x6>
    2248:	cd b7       	in	r28, 0x3d	; 61
    224a:	de b7       	in	r29, 0x3e	; 62
    224c:	9a 83       	std	Y+2, r25	; 0x02
    224e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2250:	0f b6       	in	r0, 0x3f	; 63
    2252:	f8 94       	cli
    2254:	0f 92       	push	r0
    2256:	15 c0       	rjmp	.+42     	; 0x2282 <prvUnlockQueue+0x40>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2258:	e9 81       	ldd	r30, Y+1	; 0x01
    225a:	fa 81       	ldd	r31, Y+2	; 0x02
    225c:	81 89       	ldd	r24, Z+17	; 0x11
    225e:	88 23       	and	r24, r24
    2260:	a9 f0       	breq	.+42     	; 0x228c <prvUnlockQueue+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2262:	89 81       	ldd	r24, Y+1	; 0x01
    2264:	9a 81       	ldd	r25, Y+2	; 0x02
    2266:	41 96       	adiw	r24, 0x11	; 17
    2268:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    226c:	88 23       	and	r24, r24
    226e:	11 f0       	breq	.+4      	; 0x2274 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2270:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2274:	e9 81       	ldd	r30, Y+1	; 0x01
    2276:	fa 81       	ldd	r31, Y+2	; 0x02
    2278:	86 8d       	ldd	r24, Z+30	; 0x1e
    227a:	81 50       	subi	r24, 0x01	; 1
    227c:	e9 81       	ldd	r30, Y+1	; 0x01
    227e:	fa 81       	ldd	r31, Y+2	; 0x02
    2280:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2282:	e9 81       	ldd	r30, Y+1	; 0x01
    2284:	fa 81       	ldd	r31, Y+2	; 0x02
    2286:	86 8d       	ldd	r24, Z+30	; 0x1e
    2288:	18 16       	cp	r1, r24
    228a:	34 f3       	brlt	.-52     	; 0x2258 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    228c:	e9 81       	ldd	r30, Y+1	; 0x01
    228e:	fa 81       	ldd	r31, Y+2	; 0x02
    2290:	8f ef       	ldi	r24, 0xFF	; 255
    2292:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2294:	0f 90       	pop	r0
    2296:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2298:	0f b6       	in	r0, 0x3f	; 63
    229a:	f8 94       	cli
    229c:	0f 92       	push	r0
    229e:	15 c0       	rjmp	.+42     	; 0x22ca <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22a0:	e9 81       	ldd	r30, Y+1	; 0x01
    22a2:	fa 81       	ldd	r31, Y+2	; 0x02
    22a4:	80 85       	ldd	r24, Z+8	; 0x08
    22a6:	88 23       	and	r24, r24
    22a8:	a9 f0       	breq	.+42     	; 0x22d4 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22aa:	89 81       	ldd	r24, Y+1	; 0x01
    22ac:	9a 81       	ldd	r25, Y+2	; 0x02
    22ae:	08 96       	adiw	r24, 0x08	; 8
    22b0:	0e 94 b0 16 	call	0x2d60	; 0x2d60 <xTaskRemoveFromEventList>
    22b4:	88 23       	and	r24, r24
    22b6:	11 f0       	breq	.+4      	; 0x22bc <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    22b8:	0e 94 fc 17 	call	0x2ff8	; 0x2ff8 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    22bc:	e9 81       	ldd	r30, Y+1	; 0x01
    22be:	fa 81       	ldd	r31, Y+2	; 0x02
    22c0:	85 8d       	ldd	r24, Z+29	; 0x1d
    22c2:	81 50       	subi	r24, 0x01	; 1
    22c4:	e9 81       	ldd	r30, Y+1	; 0x01
    22c6:	fa 81       	ldd	r31, Y+2	; 0x02
    22c8:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    22ca:	e9 81       	ldd	r30, Y+1	; 0x01
    22cc:	fa 81       	ldd	r31, Y+2	; 0x02
    22ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    22d0:	18 16       	cp	r1, r24
    22d2:	34 f3       	brlt	.-52     	; 0x22a0 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    22d4:	e9 81       	ldd	r30, Y+1	; 0x01
    22d6:	fa 81       	ldd	r31, Y+2	; 0x02
    22d8:	8f ef       	ldi	r24, 0xFF	; 255
    22da:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    22dc:	0f 90       	pop	r0
    22de:	0f be       	out	0x3f, r0	; 63
}
    22e0:	0f 90       	pop	r0
    22e2:	0f 90       	pop	r0
    22e4:	cf 91       	pop	r28
    22e6:	df 91       	pop	r29
    22e8:	08 95       	ret

000022ea <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    22ea:	df 93       	push	r29
    22ec:	cf 93       	push	r28
    22ee:	00 d0       	rcall	.+0      	; 0x22f0 <prvIsQueueEmpty+0x6>
    22f0:	0f 92       	push	r0
    22f2:	cd b7       	in	r28, 0x3d	; 61
    22f4:	de b7       	in	r29, 0x3e	; 62
    22f6:	9b 83       	std	Y+3, r25	; 0x03
    22f8:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    22fa:	0f b6       	in	r0, 0x3f	; 63
    22fc:	f8 94       	cli
    22fe:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2300:	ea 81       	ldd	r30, Y+2	; 0x02
    2302:	fb 81       	ldd	r31, Y+3	; 0x03
    2304:	82 8d       	ldd	r24, Z+26	; 0x1a
    2306:	88 23       	and	r24, r24
    2308:	19 f4       	brne	.+6      	; 0x2310 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    230a:	81 e0       	ldi	r24, 0x01	; 1
    230c:	89 83       	std	Y+1, r24	; 0x01
    230e:	01 c0       	rjmp	.+2      	; 0x2312 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2310:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2312:	0f 90       	pop	r0
    2314:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2316:	89 81       	ldd	r24, Y+1	; 0x01
}
    2318:	0f 90       	pop	r0
    231a:	0f 90       	pop	r0
    231c:	0f 90       	pop	r0
    231e:	cf 91       	pop	r28
    2320:	df 91       	pop	r29
    2322:	08 95       	ret

00002324 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2324:	df 93       	push	r29
    2326:	cf 93       	push	r28
    2328:	00 d0       	rcall	.+0      	; 0x232a <xQueueIsQueueEmptyFromISR+0x6>
    232a:	0f 92       	push	r0
    232c:	cd b7       	in	r28, 0x3d	; 61
    232e:	de b7       	in	r29, 0x3e	; 62
    2330:	9b 83       	std	Y+3, r25	; 0x03
    2332:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2334:	ea 81       	ldd	r30, Y+2	; 0x02
    2336:	fb 81       	ldd	r31, Y+3	; 0x03
    2338:	82 8d       	ldd	r24, Z+26	; 0x1a
    233a:	88 23       	and	r24, r24
    233c:	19 f4       	brne	.+6      	; 0x2344 <xQueueIsQueueEmptyFromISR+0x20>
	{
		xReturn = pdTRUE;
    233e:	81 e0       	ldi	r24, 0x01	; 1
    2340:	89 83       	std	Y+1, r24	; 0x01
    2342:	01 c0       	rjmp	.+2      	; 0x2346 <xQueueIsQueueEmptyFromISR+0x22>
	}
	else
	{
		xReturn = pdFALSE;
    2344:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2346:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2348:	0f 90       	pop	r0
    234a:	0f 90       	pop	r0
    234c:	0f 90       	pop	r0
    234e:	cf 91       	pop	r28
    2350:	df 91       	pop	r29
    2352:	08 95       	ret

00002354 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2354:	df 93       	push	r29
    2356:	cf 93       	push	r28
    2358:	00 d0       	rcall	.+0      	; 0x235a <prvIsQueueFull+0x6>
    235a:	0f 92       	push	r0
    235c:	cd b7       	in	r28, 0x3d	; 61
    235e:	de b7       	in	r29, 0x3e	; 62
    2360:	9b 83       	std	Y+3, r25	; 0x03
    2362:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2364:	0f b6       	in	r0, 0x3f	; 63
    2366:	f8 94       	cli
    2368:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    236a:	ea 81       	ldd	r30, Y+2	; 0x02
    236c:	fb 81       	ldd	r31, Y+3	; 0x03
    236e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2370:	ea 81       	ldd	r30, Y+2	; 0x02
    2372:	fb 81       	ldd	r31, Y+3	; 0x03
    2374:	83 8d       	ldd	r24, Z+27	; 0x1b
    2376:	98 17       	cp	r25, r24
    2378:	19 f4       	brne	.+6      	; 0x2380 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    237a:	81 e0       	ldi	r24, 0x01	; 1
    237c:	89 83       	std	Y+1, r24	; 0x01
    237e:	01 c0       	rjmp	.+2      	; 0x2382 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2380:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2382:	0f 90       	pop	r0
    2384:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2386:	89 81       	ldd	r24, Y+1	; 0x01
}
    2388:	0f 90       	pop	r0
    238a:	0f 90       	pop	r0
    238c:	0f 90       	pop	r0
    238e:	cf 91       	pop	r28
    2390:	df 91       	pop	r29
    2392:	08 95       	ret

00002394 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2394:	df 93       	push	r29
    2396:	cf 93       	push	r28
    2398:	00 d0       	rcall	.+0      	; 0x239a <xQueueIsQueueFullFromISR+0x6>
    239a:	0f 92       	push	r0
    239c:	cd b7       	in	r28, 0x3d	; 61
    239e:	de b7       	in	r29, 0x3e	; 62
    23a0:	9b 83       	std	Y+3, r25	; 0x03
    23a2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    23a4:	ea 81       	ldd	r30, Y+2	; 0x02
    23a6:	fb 81       	ldd	r31, Y+3	; 0x03
    23a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    23aa:	ea 81       	ldd	r30, Y+2	; 0x02
    23ac:	fb 81       	ldd	r31, Y+3	; 0x03
    23ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    23b0:	98 17       	cp	r25, r24
    23b2:	19 f4       	brne	.+6      	; 0x23ba <xQueueIsQueueFullFromISR+0x26>
	{
		xReturn = pdTRUE;
    23b4:	81 e0       	ldi	r24, 0x01	; 1
    23b6:	89 83       	std	Y+1, r24	; 0x01
    23b8:	01 c0       	rjmp	.+2      	; 0x23bc <xQueueIsQueueFullFromISR+0x28>
	}
	else
	{
		xReturn = pdFALSE;
    23ba:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    23bc:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    23be:	0f 90       	pop	r0
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0
    23c4:	cf 91       	pop	r28
    23c6:	df 91       	pop	r29
    23c8:	08 95       	ret

000023ca <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    23ca:	af 92       	push	r10
    23cc:	bf 92       	push	r11
    23ce:	cf 92       	push	r12
    23d0:	df 92       	push	r13
    23d2:	ef 92       	push	r14
    23d4:	ff 92       	push	r15
    23d6:	0f 93       	push	r16
    23d8:	1f 93       	push	r17
    23da:	df 93       	push	r29
    23dc:	cf 93       	push	r28
    23de:	cd b7       	in	r28, 0x3d	; 61
    23e0:	de b7       	in	r29, 0x3e	; 62
    23e2:	64 97       	sbiw	r28, 0x14	; 20
    23e4:	0f b6       	in	r0, 0x3f	; 63
    23e6:	f8 94       	cli
    23e8:	de bf       	out	0x3e, r29	; 62
    23ea:	0f be       	out	0x3f, r0	; 63
    23ec:	cd bf       	out	0x3d, r28	; 61
    23ee:	9f 83       	std	Y+7, r25	; 0x07
    23f0:	8e 83       	std	Y+6, r24	; 0x06
    23f2:	79 87       	std	Y+9, r23	; 0x09
    23f4:	68 87       	std	Y+8, r22	; 0x08
    23f6:	5b 87       	std	Y+11, r21	; 0x0b
    23f8:	4a 87       	std	Y+10, r20	; 0x0a
    23fa:	3d 87       	std	Y+13, r19	; 0x0d
    23fc:	2c 87       	std	Y+12, r18	; 0x0c
    23fe:	0e 87       	std	Y+14, r16	; 0x0e
    2400:	f8 8a       	std	Y+16, r15	; 0x10
    2402:	ef 86       	std	Y+15, r14	; 0x0f
    2404:	da 8a       	std	Y+18, r13	; 0x12
    2406:	c9 8a       	std	Y+17, r12	; 0x11
    2408:	bc 8a       	std	Y+20, r11	; 0x14
    240a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    240c:	8a 85       	ldd	r24, Y+10	; 0x0a
    240e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2410:	29 89       	ldd	r18, Y+17	; 0x11
    2412:	3a 89       	ldd	r19, Y+18	; 0x12
    2414:	b9 01       	movw	r22, r18
    2416:	0e 94 57 19 	call	0x32ae	; 0x32ae <prvAllocateTCBAndStack>
    241a:	9c 83       	std	Y+4, r25	; 0x04
    241c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    241e:	8b 81       	ldd	r24, Y+3	; 0x03
    2420:	9c 81       	ldd	r25, Y+4	; 0x04
    2422:	00 97       	sbiw	r24, 0x00	; 0
    2424:	09 f4       	brne	.+2      	; 0x2428 <xTaskGenericCreate+0x5e>
    2426:	8d c0       	rjmp	.+282    	; 0x2542 <xTaskGenericCreate+0x178>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    2428:	eb 81       	ldd	r30, Y+3	; 0x03
    242a:	fc 81       	ldd	r31, Y+4	; 0x04
    242c:	27 89       	ldd	r18, Z+23	; 0x17
    242e:	30 8d       	ldd	r19, Z+24	; 0x18
    2430:	8a 85       	ldd	r24, Y+10	; 0x0a
    2432:	9b 85       	ldd	r25, Y+11	; 0x0b
    2434:	01 97       	sbiw	r24, 0x01	; 1
    2436:	82 0f       	add	r24, r18
    2438:	93 1f       	adc	r25, r19
    243a:	9a 83       	std	Y+2, r25	; 0x02
    243c:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    243e:	8b 81       	ldd	r24, Y+3	; 0x03
    2440:	9c 81       	ldd	r25, Y+4	; 0x04
    2442:	28 85       	ldd	r18, Y+8	; 0x08
    2444:	39 85       	ldd	r19, Y+9	; 0x09
    2446:	eb 89       	ldd	r30, Y+19	; 0x13
    2448:	fc 89       	ldd	r31, Y+20	; 0x14
    244a:	aa 85       	ldd	r26, Y+10	; 0x0a
    244c:	bb 85       	ldd	r27, Y+11	; 0x0b
    244e:	b9 01       	movw	r22, r18
    2450:	4e 85       	ldd	r20, Y+14	; 0x0e
    2452:	9f 01       	movw	r18, r30
    2454:	8d 01       	movw	r16, r26
    2456:	0e 94 16 18 	call	0x302c	; 0x302c <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    245a:	89 81       	ldd	r24, Y+1	; 0x01
    245c:	9a 81       	ldd	r25, Y+2	; 0x02
    245e:	2e 81       	ldd	r18, Y+6	; 0x06
    2460:	3f 81       	ldd	r19, Y+7	; 0x07
    2462:	4c 85       	ldd	r20, Y+12	; 0x0c
    2464:	5d 85       	ldd	r21, Y+13	; 0x0d
    2466:	b9 01       	movw	r22, r18
    2468:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <pxPortInitialiseStack>
    246c:	eb 81       	ldd	r30, Y+3	; 0x03
    246e:	fc 81       	ldd	r31, Y+4	; 0x04
    2470:	91 83       	std	Z+1, r25	; 0x01
    2472:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    2474:	8f 85       	ldd	r24, Y+15	; 0x0f
    2476:	98 89       	ldd	r25, Y+16	; 0x10
    2478:	00 97       	sbiw	r24, 0x00	; 0
    247a:	31 f0       	breq	.+12     	; 0x2488 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    247c:	ef 85       	ldd	r30, Y+15	; 0x0f
    247e:	f8 89       	ldd	r31, Y+16	; 0x10
    2480:	8b 81       	ldd	r24, Y+3	; 0x03
    2482:	9c 81       	ldd	r25, Y+4	; 0x04
    2484:	91 83       	std	Z+1, r25	; 0x01
    2486:	80 83       	st	Z, r24
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    2488:	0f b6       	in	r0, 0x3f	; 63
    248a:	f8 94       	cli
    248c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    248e:	80 91 55 04 	lds	r24, 0x0455
    2492:	8f 5f       	subi	r24, 0xFF	; 255
    2494:	80 93 55 04 	sts	0x0455, r24
			if( pxCurrentTCB == NULL )
    2498:	80 91 52 04 	lds	r24, 0x0452
    249c:	90 91 53 04 	lds	r25, 0x0453
    24a0:	00 97       	sbiw	r24, 0x00	; 0
    24a2:	69 f4       	brne	.+26     	; 0x24be <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    24a4:	8b 81       	ldd	r24, Y+3	; 0x03
    24a6:	9c 81       	ldd	r25, Y+4	; 0x04
    24a8:	90 93 53 04 	sts	0x0453, r25
    24ac:	80 93 52 04 	sts	0x0452, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    24b0:	80 91 55 04 	lds	r24, 0x0455
    24b4:	81 30       	cpi	r24, 0x01	; 1
    24b6:	a9 f4       	brne	.+42     	; 0x24e2 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    24b8:	0e 94 92 18 	call	0x3124	; 0x3124 <prvInitialiseTaskLists>
    24bc:	12 c0       	rjmp	.+36     	; 0x24e2 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    24be:	80 91 59 04 	lds	r24, 0x0459
    24c2:	88 23       	and	r24, r24
    24c4:	71 f4       	brne	.+28     	; 0x24e2 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    24c6:	e0 91 52 04 	lds	r30, 0x0452
    24ca:	f0 91 53 04 	lds	r31, 0x0453
    24ce:	96 89       	ldd	r25, Z+22	; 0x16
    24d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    24d2:	89 17       	cp	r24, r25
    24d4:	30 f0       	brcs	.+12     	; 0x24e2 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    24d6:	8b 81       	ldd	r24, Y+3	; 0x03
    24d8:	9c 81       	ldd	r25, Y+4	; 0x04
    24da:	90 93 53 04 	sts	0x0453, r25
    24de:	80 93 52 04 	sts	0x0452, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    24e2:	80 91 5d 04 	lds	r24, 0x045D
    24e6:	8f 5f       	subi	r24, 0xFF	; 255
    24e8:	80 93 5d 04 	sts	0x045D, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    24ec:	eb 81       	ldd	r30, Y+3	; 0x03
    24ee:	fc 81       	ldd	r31, Y+4	; 0x04
    24f0:	96 89       	ldd	r25, Z+22	; 0x16
    24f2:	80 91 58 04 	lds	r24, 0x0458
    24f6:	89 17       	cp	r24, r25
    24f8:	28 f4       	brcc	.+10     	; 0x2504 <xTaskGenericCreate+0x13a>
    24fa:	eb 81       	ldd	r30, Y+3	; 0x03
    24fc:	fc 81       	ldd	r31, Y+4	; 0x04
    24fe:	86 89       	ldd	r24, Z+22	; 0x16
    2500:	80 93 58 04 	sts	0x0458, r24
    2504:	eb 81       	ldd	r30, Y+3	; 0x03
    2506:	fc 81       	ldd	r31, Y+4	; 0x04
    2508:	86 89       	ldd	r24, Z+22	; 0x16
    250a:	28 2f       	mov	r18, r24
    250c:	30 e0       	ldi	r19, 0x00	; 0
    250e:	c9 01       	movw	r24, r18
    2510:	88 0f       	add	r24, r24
    2512:	99 1f       	adc	r25, r25
    2514:	88 0f       	add	r24, r24
    2516:	99 1f       	adc	r25, r25
    2518:	88 0f       	add	r24, r24
    251a:	99 1f       	adc	r25, r25
    251c:	82 0f       	add	r24, r18
    251e:	93 1f       	adc	r25, r19
    2520:	ac 01       	movw	r20, r24
    2522:	4f 59       	subi	r20, 0x9F	; 159
    2524:	5b 4f       	sbci	r21, 0xFB	; 251
    2526:	8b 81       	ldd	r24, Y+3	; 0x03
    2528:	9c 81       	ldd	r25, Y+4	; 0x04
    252a:	9c 01       	movw	r18, r24
    252c:	2e 5f       	subi	r18, 0xFE	; 254
    252e:	3f 4f       	sbci	r19, 0xFF	; 255
    2530:	ca 01       	movw	r24, r20
    2532:	b9 01       	movw	r22, r18
    2534:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>

			xReturn = pdPASS;
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	8d 83       	std	Y+5, r24	; 0x05
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    253c:	0f 90       	pop	r0
    253e:	0f be       	out	0x3f, r0	; 63
    2540:	02 c0       	rjmp	.+4      	; 0x2546 <xTaskGenericCreate+0x17c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2542:	8f ef       	ldi	r24, 0xFF	; 255
    2544:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2546:	8d 81       	ldd	r24, Y+5	; 0x05
    2548:	81 30       	cpi	r24, 0x01	; 1
    254a:	71 f4       	brne	.+28     	; 0x2568 <xTaskGenericCreate+0x19e>
	{
		if( xSchedulerRunning != pdFALSE )
    254c:	80 91 59 04 	lds	r24, 0x0459
    2550:	88 23       	and	r24, r24
    2552:	51 f0       	breq	.+20     	; 0x2568 <xTaskGenericCreate+0x19e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2554:	e0 91 52 04 	lds	r30, 0x0452
    2558:	f0 91 53 04 	lds	r31, 0x0453
    255c:	96 89       	ldd	r25, Z+22	; 0x16
    255e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2560:	98 17       	cp	r25, r24
    2562:	10 f4       	brcc	.+4      	; 0x2568 <xTaskGenericCreate+0x19e>
			{
				taskYIELD_IF_USING_PREEMPTION();
    2564:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    2568:	8d 81       	ldd	r24, Y+5	; 0x05
}
    256a:	64 96       	adiw	r28, 0x14	; 20
    256c:	0f b6       	in	r0, 0x3f	; 63
    256e:	f8 94       	cli
    2570:	de bf       	out	0x3e, r29	; 62
    2572:	0f be       	out	0x3f, r0	; 63
    2574:	cd bf       	out	0x3d, r28	; 61
    2576:	cf 91       	pop	r28
    2578:	df 91       	pop	r29
    257a:	1f 91       	pop	r17
    257c:	0f 91       	pop	r16
    257e:	ff 90       	pop	r15
    2580:	ef 90       	pop	r14
    2582:	df 90       	pop	r13
    2584:	cf 90       	pop	r12
    2586:	bf 90       	pop	r11
    2588:	af 90       	pop	r10
    258a:	08 95       	ret

0000258c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    258c:	df 93       	push	r29
    258e:	cf 93       	push	r28
    2590:	00 d0       	rcall	.+0      	; 0x2592 <vTaskDelete+0x6>
    2592:	00 d0       	rcall	.+0      	; 0x2594 <vTaskDelete+0x8>
    2594:	00 d0       	rcall	.+0      	; 0x2596 <vTaskDelete+0xa>
    2596:	cd b7       	in	r28, 0x3d	; 61
    2598:	de b7       	in	r29, 0x3e	; 62
    259a:	9c 83       	std	Y+4, r25	; 0x04
    259c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    259e:	0f b6       	in	r0, 0x3f	; 63
    25a0:	f8 94       	cli
    25a2:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    25a4:	8b 81       	ldd	r24, Y+3	; 0x03
    25a6:	9c 81       	ldd	r25, Y+4	; 0x04
    25a8:	00 97       	sbiw	r24, 0x00	; 0
    25aa:	39 f4       	brne	.+14     	; 0x25ba <vTaskDelete+0x2e>
    25ac:	80 91 52 04 	lds	r24, 0x0452
    25b0:	90 91 53 04 	lds	r25, 0x0453
    25b4:	9e 83       	std	Y+6, r25	; 0x06
    25b6:	8d 83       	std	Y+5, r24	; 0x05
    25b8:	04 c0       	rjmp	.+8      	; 0x25c2 <vTaskDelete+0x36>
    25ba:	8b 81       	ldd	r24, Y+3	; 0x03
    25bc:	9c 81       	ldd	r25, Y+4	; 0x04
    25be:	9e 83       	std	Y+6, r25	; 0x06
    25c0:	8d 83       	std	Y+5, r24	; 0x05
    25c2:	8d 81       	ldd	r24, Y+5	; 0x05
    25c4:	9e 81       	ldd	r25, Y+6	; 0x06
    25c6:	9a 83       	std	Y+2, r25	; 0x02
    25c8:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    25ca:	89 81       	ldd	r24, Y+1	; 0x01
    25cc:	9a 81       	ldd	r25, Y+2	; 0x02
    25ce:	02 96       	adiw	r24, 0x02	; 2
    25d0:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    25d4:	e9 81       	ldd	r30, Y+1	; 0x01
    25d6:	fa 81       	ldd	r31, Y+2	; 0x02
    25d8:	84 89       	ldd	r24, Z+20	; 0x14
    25da:	95 89       	ldd	r25, Z+21	; 0x15
    25dc:	00 97       	sbiw	r24, 0x00	; 0
    25de:	29 f0       	breq	.+10     	; 0x25ea <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    25e0:	89 81       	ldd	r24, Y+1	; 0x01
    25e2:	9a 81       	ldd	r25, Y+2	; 0x02
    25e4:	0c 96       	adiw	r24, 0x0c	; 12
    25e6:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    25ea:	89 81       	ldd	r24, Y+1	; 0x01
    25ec:	9a 81       	ldd	r25, Y+2	; 0x02
    25ee:	9c 01       	movw	r18, r24
    25f0:	2e 5f       	subi	r18, 0xFE	; 254
    25f2:	3f 4f       	sbci	r19, 0xFF	; 255
    25f4:	84 ea       	ldi	r24, 0xA4	; 164
    25f6:	94 e0       	ldi	r25, 0x04	; 4
    25f8:	b9 01       	movw	r22, r18
    25fa:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    25fe:	80 91 54 04 	lds	r24, 0x0454
    2602:	8f 5f       	subi	r24, 0xFF	; 255
    2604:	80 93 54 04 	sts	0x0454, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2608:	80 91 5d 04 	lds	r24, 0x045D
    260c:	8f 5f       	subi	r24, 0xFF	; 255
    260e:	80 93 5d 04 	sts	0x045D, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2612:	0f 90       	pop	r0
    2614:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2616:	80 91 59 04 	lds	r24, 0x0459
    261a:	88 23       	and	r24, r24
    261c:	99 f0       	breq	.+38     	; 0x2644 <vTaskDelete+0xb8>
		{
			if( pxTCB == pxCurrentTCB )
    261e:	20 91 52 04 	lds	r18, 0x0452
    2622:	30 91 53 04 	lds	r19, 0x0453
    2626:	89 81       	ldd	r24, Y+1	; 0x01
    2628:	9a 81       	ldd	r25, Y+2	; 0x02
    262a:	82 17       	cp	r24, r18
    262c:	93 07       	cpc	r25, r19
    262e:	19 f4       	brne	.+6      	; 0x2636 <vTaskDelete+0xaa>
				in which Windows specific clean up operations are performed,
				after which it is not possible to yield away from this task -
				hence xYieldPending is used to latch that a context switch is
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
				portYIELD_WITHIN_API();
    2630:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    2634:	07 c0       	rjmp	.+14     	; 0x2644 <vTaskDelete+0xb8>
			}
			else
			{
				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				taskENTER_CRITICAL();
    2636:	0f b6       	in	r0, 0x3f	; 63
    2638:	f8 94       	cli
    263a:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    263c:	0e 94 b5 19 	call	0x336a	; 0x336a <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    2640:	0f 90       	pop	r0
    2642:	0f be       	out	0x3f, r0	; 63
			}
		}
	}
    2644:	26 96       	adiw	r28, 0x06	; 6
    2646:	0f b6       	in	r0, 0x3f	; 63
    2648:	f8 94       	cli
    264a:	de bf       	out	0x3e, r29	; 62
    264c:	0f be       	out	0x3f, r0	; 63
    264e:	cd bf       	out	0x3d, r28	; 61
    2650:	cf 91       	pop	r28
    2652:	df 91       	pop	r29
    2654:	08 95       	ret

00002656 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2656:	df 93       	push	r29
    2658:	cf 93       	push	r28
    265a:	cd b7       	in	r28, 0x3d	; 61
    265c:	de b7       	in	r29, 0x3e	; 62
    265e:	2a 97       	sbiw	r28, 0x0a	; 10
    2660:	0f b6       	in	r0, 0x3f	; 63
    2662:	f8 94       	cli
    2664:	de bf       	out	0x3e, r29	; 62
    2666:	0f be       	out	0x3f, r0	; 63
    2668:	cd bf       	out	0x3d, r28	; 61
    266a:	98 87       	std	Y+8, r25	; 0x08
    266c:	8f 83       	std	Y+7, r24	; 0x07
    266e:	7a 87       	std	Y+10, r23	; 0x0a
    2670:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2672:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2674:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2678:	80 91 56 04 	lds	r24, 0x0456
    267c:	90 91 57 04 	lds	r25, 0x0457
    2680:	9a 83       	std	Y+2, r25	; 0x02
    2682:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2684:	ef 81       	ldd	r30, Y+7	; 0x07
    2686:	f8 85       	ldd	r31, Y+8	; 0x08
    2688:	20 81       	ld	r18, Z
    268a:	31 81       	ldd	r19, Z+1	; 0x01
    268c:	89 85       	ldd	r24, Y+9	; 0x09
    268e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2690:	82 0f       	add	r24, r18
    2692:	93 1f       	adc	r25, r19
    2694:	9e 83       	std	Y+6, r25	; 0x06
    2696:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2698:	ef 81       	ldd	r30, Y+7	; 0x07
    269a:	f8 85       	ldd	r31, Y+8	; 0x08
    269c:	20 81       	ld	r18, Z
    269e:	31 81       	ldd	r19, Z+1	; 0x01
    26a0:	89 81       	ldd	r24, Y+1	; 0x01
    26a2:	9a 81       	ldd	r25, Y+2	; 0x02
    26a4:	82 17       	cp	r24, r18
    26a6:	93 07       	cpc	r25, r19
    26a8:	98 f4       	brcc	.+38     	; 0x26d0 <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    26aa:	ef 81       	ldd	r30, Y+7	; 0x07
    26ac:	f8 85       	ldd	r31, Y+8	; 0x08
    26ae:	20 81       	ld	r18, Z
    26b0:	31 81       	ldd	r19, Z+1	; 0x01
    26b2:	8d 81       	ldd	r24, Y+5	; 0x05
    26b4:	9e 81       	ldd	r25, Y+6	; 0x06
    26b6:	82 17       	cp	r24, r18
    26b8:	93 07       	cpc	r25, r19
    26ba:	e0 f4       	brcc	.+56     	; 0x26f4 <vTaskDelayUntil+0x9e>
    26bc:	2d 81       	ldd	r18, Y+5	; 0x05
    26be:	3e 81       	ldd	r19, Y+6	; 0x06
    26c0:	89 81       	ldd	r24, Y+1	; 0x01
    26c2:	9a 81       	ldd	r25, Y+2	; 0x02
    26c4:	82 17       	cp	r24, r18
    26c6:	93 07       	cpc	r25, r19
    26c8:	a8 f4       	brcc	.+42     	; 0x26f4 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    26ca:	81 e0       	ldi	r24, 0x01	; 1
    26cc:	8b 83       	std	Y+3, r24	; 0x03
    26ce:	12 c0       	rjmp	.+36     	; 0x26f4 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    26d0:	ef 81       	ldd	r30, Y+7	; 0x07
    26d2:	f8 85       	ldd	r31, Y+8	; 0x08
    26d4:	20 81       	ld	r18, Z
    26d6:	31 81       	ldd	r19, Z+1	; 0x01
    26d8:	8d 81       	ldd	r24, Y+5	; 0x05
    26da:	9e 81       	ldd	r25, Y+6	; 0x06
    26dc:	82 17       	cp	r24, r18
    26de:	93 07       	cpc	r25, r19
    26e0:	38 f0       	brcs	.+14     	; 0x26f0 <vTaskDelayUntil+0x9a>
    26e2:	2d 81       	ldd	r18, Y+5	; 0x05
    26e4:	3e 81       	ldd	r19, Y+6	; 0x06
    26e6:	89 81       	ldd	r24, Y+1	; 0x01
    26e8:	9a 81       	ldd	r25, Y+2	; 0x02
    26ea:	82 17       	cp	r24, r18
    26ec:	93 07       	cpc	r25, r19
    26ee:	10 f4       	brcc	.+4      	; 0x26f4 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    26f0:	81 e0       	ldi	r24, 0x01	; 1
    26f2:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    26f4:	ef 81       	ldd	r30, Y+7	; 0x07
    26f6:	f8 85       	ldd	r31, Y+8	; 0x08
    26f8:	8d 81       	ldd	r24, Y+5	; 0x05
    26fa:	9e 81       	ldd	r25, Y+6	; 0x06
    26fc:	91 83       	std	Z+1, r25	; 0x01
    26fe:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2700:	8b 81       	ldd	r24, Y+3	; 0x03
    2702:	88 23       	and	r24, r24
    2704:	59 f0       	breq	.+22     	; 0x271c <vTaskDelayUntil+0xc6>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2706:	80 91 52 04 	lds	r24, 0x0452
    270a:	90 91 53 04 	lds	r25, 0x0453
    270e:	02 96       	adiw	r24, 0x02	; 2
    2710:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2714:	8d 81       	ldd	r24, Y+5	; 0x05
    2716:	9e 81       	ldd	r25, Y+6	; 0x06
    2718:	0e 94 0e 19 	call	0x321c	; 0x321c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    271c:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    2720:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2722:	8c 81       	ldd	r24, Y+4	; 0x04
    2724:	88 23       	and	r24, r24
    2726:	11 f4       	brne	.+4      	; 0x272c <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2728:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    272c:	2a 96       	adiw	r28, 0x0a	; 10
    272e:	0f b6       	in	r0, 0x3f	; 63
    2730:	f8 94       	cli
    2732:	de bf       	out	0x3e, r29	; 62
    2734:	0f be       	out	0x3f, r0	; 63
    2736:	cd bf       	out	0x3d, r28	; 61
    2738:	cf 91       	pop	r28
    273a:	df 91       	pop	r29
    273c:	08 95       	ret

0000273e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    273e:	df 93       	push	r29
    2740:	cf 93       	push	r28
    2742:	00 d0       	rcall	.+0      	; 0x2744 <vTaskDelay+0x6>
    2744:	00 d0       	rcall	.+0      	; 0x2746 <vTaskDelay+0x8>
    2746:	0f 92       	push	r0
    2748:	cd b7       	in	r28, 0x3d	; 61
    274a:	de b7       	in	r29, 0x3e	; 62
    274c:	9d 83       	std	Y+5, r25	; 0x05
    274e:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    2750:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2752:	8c 81       	ldd	r24, Y+4	; 0x04
    2754:	9d 81       	ldd	r25, Y+5	; 0x05
    2756:	00 97       	sbiw	r24, 0x00	; 0
    2758:	d1 f0       	breq	.+52     	; 0x278e <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    275a:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    275e:	20 91 56 04 	lds	r18, 0x0456
    2762:	30 91 57 04 	lds	r19, 0x0457
    2766:	8c 81       	ldd	r24, Y+4	; 0x04
    2768:	9d 81       	ldd	r25, Y+5	; 0x05
    276a:	82 0f       	add	r24, r18
    276c:	93 1f       	adc	r25, r19
    276e:	9b 83       	std	Y+3, r25	; 0x03
    2770:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2772:	80 91 52 04 	lds	r24, 0x0452
    2776:	90 91 53 04 	lds	r25, 0x0453
    277a:	02 96       	adiw	r24, 0x02	; 2
    277c:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2780:	8a 81       	ldd	r24, Y+2	; 0x02
    2782:	9b 81       	ldd	r25, Y+3	; 0x03
    2784:	0e 94 0e 19 	call	0x321c	; 0x321c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2788:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>
    278c:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    278e:	89 81       	ldd	r24, Y+1	; 0x01
    2790:	88 23       	and	r24, r24
    2792:	11 f4       	brne	.+4      	; 0x2798 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2794:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2798:	0f 90       	pop	r0
    279a:	0f 90       	pop	r0
    279c:	0f 90       	pop	r0
    279e:	0f 90       	pop	r0
    27a0:	0f 90       	pop	r0
    27a2:	cf 91       	pop	r28
    27a4:	df 91       	pop	r29
    27a6:	08 95       	ret

000027a8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    27a8:	af 92       	push	r10
    27aa:	bf 92       	push	r11
    27ac:	cf 92       	push	r12
    27ae:	df 92       	push	r13
    27b0:	ef 92       	push	r14
    27b2:	ff 92       	push	r15
    27b4:	0f 93       	push	r16
    27b6:	df 93       	push	r29
    27b8:	cf 93       	push	r28
    27ba:	0f 92       	push	r0
    27bc:	cd b7       	in	r28, 0x3d	; 61
    27be:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    27c0:	86 e0       	ldi	r24, 0x06	; 6
    27c2:	98 e1       	ldi	r25, 0x18	; 24
    27c4:	20 e6       	ldi	r18, 0x60	; 96
    27c6:	30 e0       	ldi	r19, 0x00	; 0
    27c8:	b9 01       	movw	r22, r18
    27ca:	44 e6       	ldi	r20, 0x64	; 100
    27cc:	50 e0       	ldi	r21, 0x00	; 0
    27ce:	20 e0       	ldi	r18, 0x00	; 0
    27d0:	30 e0       	ldi	r19, 0x00	; 0
    27d2:	00 e0       	ldi	r16, 0x00	; 0
    27d4:	ee 24       	eor	r14, r14
    27d6:	ff 24       	eor	r15, r15
    27d8:	cc 24       	eor	r12, r12
    27da:	dd 24       	eor	r13, r13
    27dc:	aa 24       	eor	r10, r10
    27de:	bb 24       	eor	r11, r11
    27e0:	0e 94 e5 11 	call	0x23ca	; 0x23ca <xTaskGenericCreate>
    27e4:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    27e6:	89 81       	ldd	r24, Y+1	; 0x01
    27e8:	81 30       	cpi	r24, 0x01	; 1
    27ea:	81 f4       	brne	.+32     	; 0x280c <vTaskStartScheduler+0x64>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    27ec:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    27ee:	8f ef       	ldi	r24, 0xFF	; 255
    27f0:	9f ef       	ldi	r25, 0xFF	; 255
    27f2:	90 93 5f 04 	sts	0x045F, r25
    27f6:	80 93 5e 04 	sts	0x045E, r24
		xSchedulerRunning = pdTRUE;
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	80 93 59 04 	sts	0x0459, r24
		xTickCount = ( TickType_t ) 0U;
    2800:	10 92 57 04 	sts	0x0457, r1
    2804:	10 92 56 04 	sts	0x0456, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2808:	0e 94 ee 0a 	call	0x15dc	; 0x15dc <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    280c:	0f 90       	pop	r0
    280e:	cf 91       	pop	r28
    2810:	df 91       	pop	r29
    2812:	0f 91       	pop	r16
    2814:	ff 90       	pop	r15
    2816:	ef 90       	pop	r14
    2818:	df 90       	pop	r13
    281a:	cf 90       	pop	r12
    281c:	bf 90       	pop	r11
    281e:	af 90       	pop	r10
    2820:	08 95       	ret

00002822 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2822:	df 93       	push	r29
    2824:	cf 93       	push	r28
    2826:	cd b7       	in	r28, 0x3d	; 61
    2828:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    282a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    282c:	10 92 59 04 	sts	0x0459, r1
	vPortEndScheduler();
    2830:	0e 94 23 0b 	call	0x1646	; 0x1646 <vPortEndScheduler>
}
    2834:	cf 91       	pop	r28
    2836:	df 91       	pop	r29
    2838:	08 95       	ret

0000283a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    283a:	df 93       	push	r29
    283c:	cf 93       	push	r28
    283e:	cd b7       	in	r28, 0x3d	; 61
    2840:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2842:	80 91 60 04 	lds	r24, 0x0460
    2846:	8f 5f       	subi	r24, 0xFF	; 255
    2848:	80 93 60 04 	sts	0x0460, r24
}
    284c:	cf 91       	pop	r28
    284e:	df 91       	pop	r29
    2850:	08 95       	ret

00002852 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2852:	df 93       	push	r29
    2854:	cf 93       	push	r28
    2856:	00 d0       	rcall	.+0      	; 0x2858 <xTaskResumeAll+0x6>
    2858:	0f 92       	push	r0
    285a:	cd b7       	in	r28, 0x3d	; 61
    285c:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    285e:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2860:	0f b6       	in	r0, 0x3f	; 63
    2862:	f8 94       	cli
    2864:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2866:	80 91 60 04 	lds	r24, 0x0460
    286a:	81 50       	subi	r24, 0x01	; 1
    286c:	80 93 60 04 	sts	0x0460, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2870:	80 91 60 04 	lds	r24, 0x0460
    2874:	88 23       	and	r24, r24
    2876:	09 f0       	breq	.+2      	; 0x287a <xTaskResumeAll+0x28>
    2878:	6d c0       	rjmp	.+218    	; 0x2954 <xTaskResumeAll+0x102>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    287a:	80 91 55 04 	lds	r24, 0x0455
    287e:	88 23       	and	r24, r24
    2880:	09 f4       	brne	.+2      	; 0x2884 <xTaskResumeAll+0x32>
    2882:	68 c0       	rjmp	.+208    	; 0x2954 <xTaskResumeAll+0x102>
    2884:	45 c0       	rjmp	.+138    	; 0x2910 <xTaskResumeAll+0xbe>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2886:	e0 91 a0 04 	lds	r30, 0x04A0
    288a:	f0 91 a1 04 	lds	r31, 0x04A1
    288e:	86 81       	ldd	r24, Z+6	; 0x06
    2890:	97 81       	ldd	r25, Z+7	; 0x07
    2892:	9b 83       	std	Y+3, r25	; 0x03
    2894:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2896:	8a 81       	ldd	r24, Y+2	; 0x02
    2898:	9b 81       	ldd	r25, Y+3	; 0x03
    289a:	0c 96       	adiw	r24, 0x0c	; 12
    289c:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    28a0:	8a 81       	ldd	r24, Y+2	; 0x02
    28a2:	9b 81       	ldd	r25, Y+3	; 0x03
    28a4:	02 96       	adiw	r24, 0x02	; 2
    28a6:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    28aa:	ea 81       	ldd	r30, Y+2	; 0x02
    28ac:	fb 81       	ldd	r31, Y+3	; 0x03
    28ae:	96 89       	ldd	r25, Z+22	; 0x16
    28b0:	80 91 58 04 	lds	r24, 0x0458
    28b4:	89 17       	cp	r24, r25
    28b6:	28 f4       	brcc	.+10     	; 0x28c2 <xTaskResumeAll+0x70>
    28b8:	ea 81       	ldd	r30, Y+2	; 0x02
    28ba:	fb 81       	ldd	r31, Y+3	; 0x03
    28bc:	86 89       	ldd	r24, Z+22	; 0x16
    28be:	80 93 58 04 	sts	0x0458, r24
    28c2:	ea 81       	ldd	r30, Y+2	; 0x02
    28c4:	fb 81       	ldd	r31, Y+3	; 0x03
    28c6:	86 89       	ldd	r24, Z+22	; 0x16
    28c8:	28 2f       	mov	r18, r24
    28ca:	30 e0       	ldi	r19, 0x00	; 0
    28cc:	c9 01       	movw	r24, r18
    28ce:	88 0f       	add	r24, r24
    28d0:	99 1f       	adc	r25, r25
    28d2:	88 0f       	add	r24, r24
    28d4:	99 1f       	adc	r25, r25
    28d6:	88 0f       	add	r24, r24
    28d8:	99 1f       	adc	r25, r25
    28da:	82 0f       	add	r24, r18
    28dc:	93 1f       	adc	r25, r19
    28de:	ac 01       	movw	r20, r24
    28e0:	4f 59       	subi	r20, 0x9F	; 159
    28e2:	5b 4f       	sbci	r21, 0xFB	; 251
    28e4:	8a 81       	ldd	r24, Y+2	; 0x02
    28e6:	9b 81       	ldd	r25, Y+3	; 0x03
    28e8:	9c 01       	movw	r18, r24
    28ea:	2e 5f       	subi	r18, 0xFE	; 254
    28ec:	3f 4f       	sbci	r19, 0xFF	; 255
    28ee:	ca 01       	movw	r24, r20
    28f0:	b9 01       	movw	r22, r18
    28f2:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    28f6:	ea 81       	ldd	r30, Y+2	; 0x02
    28f8:	fb 81       	ldd	r31, Y+3	; 0x03
    28fa:	96 89       	ldd	r25, Z+22	; 0x16
    28fc:	e0 91 52 04 	lds	r30, 0x0452
    2900:	f0 91 53 04 	lds	r31, 0x0453
    2904:	86 89       	ldd	r24, Z+22	; 0x16
    2906:	98 17       	cp	r25, r24
    2908:	18 f0       	brcs	.+6      	; 0x2910 <xTaskResumeAll+0xbe>
					{
						xYieldPending = pdTRUE;
    290a:	81 e0       	ldi	r24, 0x01	; 1
    290c:	80 93 5b 04 	sts	0x045B, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2910:	80 91 9b 04 	lds	r24, 0x049B
    2914:	88 23       	and	r24, r24
    2916:	09 f0       	breq	.+2      	; 0x291a <xTaskResumeAll+0xc8>
    2918:	b6 cf       	rjmp	.-148    	; 0x2886 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    291a:	80 91 5a 04 	lds	r24, 0x045A
    291e:	88 23       	and	r24, r24
    2920:	89 f0       	breq	.+34     	; 0x2944 <xTaskResumeAll+0xf2>
    2922:	0c c0       	rjmp	.+24     	; 0x293c <xTaskResumeAll+0xea>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    2924:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskIncrementTick>
    2928:	88 23       	and	r24, r24
    292a:	19 f0       	breq	.+6      	; 0x2932 <xTaskResumeAll+0xe0>
						{
							xYieldPending = pdTRUE;
    292c:	81 e0       	ldi	r24, 0x01	; 1
    292e:	80 93 5b 04 	sts	0x045B, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2932:	80 91 5a 04 	lds	r24, 0x045A
    2936:	81 50       	subi	r24, 0x01	; 1
    2938:	80 93 5a 04 	sts	0x045A, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    293c:	80 91 5a 04 	lds	r24, 0x045A
    2940:	88 23       	and	r24, r24
    2942:	81 f7       	brne	.-32     	; 0x2924 <xTaskResumeAll+0xd2>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    2944:	80 91 5b 04 	lds	r24, 0x045B
    2948:	81 30       	cpi	r24, 0x01	; 1
    294a:	21 f4       	brne	.+8      	; 0x2954 <xTaskResumeAll+0x102>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2950:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2954:	0f 90       	pop	r0
    2956:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2958:	89 81       	ldd	r24, Y+1	; 0x01
}
    295a:	0f 90       	pop	r0
    295c:	0f 90       	pop	r0
    295e:	0f 90       	pop	r0
    2960:	cf 91       	pop	r28
    2962:	df 91       	pop	r29
    2964:	08 95       	ret

00002966 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    2966:	df 93       	push	r29
    2968:	cf 93       	push	r28
    296a:	00 d0       	rcall	.+0      	; 0x296c <xTaskGetTickCount+0x6>
    296c:	cd b7       	in	r28, 0x3d	; 61
    296e:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    2970:	0f b6       	in	r0, 0x3f	; 63
    2972:	f8 94       	cli
    2974:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2976:	80 91 56 04 	lds	r24, 0x0456
    297a:	90 91 57 04 	lds	r25, 0x0457
    297e:	9a 83       	std	Y+2, r25	; 0x02
    2980:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    2982:	0f 90       	pop	r0
    2984:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2986:	89 81       	ldd	r24, Y+1	; 0x01
    2988:	9a 81       	ldd	r25, Y+2	; 0x02
}
    298a:	0f 90       	pop	r0
    298c:	0f 90       	pop	r0
    298e:	cf 91       	pop	r28
    2990:	df 91       	pop	r29
    2992:	08 95       	ret

00002994 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    2994:	df 93       	push	r29
    2996:	cf 93       	push	r28
    2998:	00 d0       	rcall	.+0      	; 0x299a <xTaskGetTickCountFromISR+0x6>
    299a:	0f 92       	push	r0
    299c:	cd b7       	in	r28, 0x3d	; 61
    299e:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    29a0:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    29a2:	80 91 56 04 	lds	r24, 0x0456
    29a6:	90 91 57 04 	lds	r25, 0x0457
    29aa:	9b 83       	std	Y+3, r25	; 0x03
    29ac:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    29ae:	8a 81       	ldd	r24, Y+2	; 0x02
    29b0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    29b2:	0f 90       	pop	r0
    29b4:	0f 90       	pop	r0
    29b6:	0f 90       	pop	r0
    29b8:	cf 91       	pop	r28
    29ba:	df 91       	pop	r29
    29bc:	08 95       	ret

000029be <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    29be:	df 93       	push	r29
    29c0:	cf 93       	push	r28
    29c2:	cd b7       	in	r28, 0x3d	; 61
    29c4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    29c6:	80 91 55 04 	lds	r24, 0x0455
}
    29ca:	cf 91       	pop	r28
    29cc:	df 91       	pop	r29
    29ce:	08 95       	ret

000029d0 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    29d0:	df 93       	push	r29
    29d2:	cf 93       	push	r28
    29d4:	cd b7       	in	r28, 0x3d	; 61
    29d6:	de b7       	in	r29, 0x3e	; 62
    29d8:	29 97       	sbiw	r28, 0x09	; 9
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	de bf       	out	0x3e, r29	; 62
    29e0:	0f be       	out	0x3f, r0	; 63
    29e2:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    29e4:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    29e6:	80 91 60 04 	lds	r24, 0x0460
    29ea:	88 23       	and	r24, r24
    29ec:	09 f0       	breq	.+2      	; 0x29f0 <xTaskIncrementTick+0x20>
    29ee:	c2 c0       	rjmp	.+388    	; 0x2b74 <xTaskIncrementTick+0x1a4>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    29f0:	80 91 56 04 	lds	r24, 0x0456
    29f4:	90 91 57 04 	lds	r25, 0x0457
    29f8:	01 96       	adiw	r24, 0x01	; 1
    29fa:	90 93 57 04 	sts	0x0457, r25
    29fe:	80 93 56 04 	sts	0x0456, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2a02:	80 91 56 04 	lds	r24, 0x0456
    2a06:	90 91 57 04 	lds	r25, 0x0457
    2a0a:	9c 83       	std	Y+4, r25	; 0x04
    2a0c:	8b 83       	std	Y+3, r24	; 0x03

			if( xConstTickCount == ( TickType_t ) 0U )
    2a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a10:	9c 81       	ldd	r25, Y+4	; 0x04
    2a12:	00 97       	sbiw	r24, 0x00	; 0
    2a14:	d9 f4       	brne	.+54     	; 0x2a4c <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    2a16:	80 91 97 04 	lds	r24, 0x0497
    2a1a:	90 91 98 04 	lds	r25, 0x0498
    2a1e:	9a 83       	std	Y+2, r25	; 0x02
    2a20:	89 83       	std	Y+1, r24	; 0x01
    2a22:	80 91 99 04 	lds	r24, 0x0499
    2a26:	90 91 9a 04 	lds	r25, 0x049A
    2a2a:	90 93 98 04 	sts	0x0498, r25
    2a2e:	80 93 97 04 	sts	0x0497, r24
    2a32:	89 81       	ldd	r24, Y+1	; 0x01
    2a34:	9a 81       	ldd	r25, Y+2	; 0x02
    2a36:	90 93 9a 04 	sts	0x049A, r25
    2a3a:	80 93 99 04 	sts	0x0499, r24
    2a3e:	80 91 5c 04 	lds	r24, 0x045C
    2a42:	8f 5f       	subi	r24, 0xFF	; 255
    2a44:	80 93 5c 04 	sts	0x045C, r24
    2a48:	0e 94 b5 19 	call	0x336a	; 0x336a <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    2a4c:	20 91 5e 04 	lds	r18, 0x045E
    2a50:	30 91 5f 04 	lds	r19, 0x045F
    2a54:	8b 81       	ldd	r24, Y+3	; 0x03
    2a56:	9c 81       	ldd	r25, Y+4	; 0x04
    2a58:	82 17       	cp	r24, r18
    2a5a:	93 07       	cpc	r25, r19
    2a5c:	08 f4       	brcc	.+2      	; 0x2a60 <xTaskIncrementTick+0x90>
    2a5e:	71 c0       	rjmp	.+226    	; 0x2b42 <xTaskIncrementTick+0x172>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2a60:	e0 91 97 04 	lds	r30, 0x0497
    2a64:	f0 91 98 04 	lds	r31, 0x0498
    2a68:	80 81       	ld	r24, Z
    2a6a:	88 23       	and	r24, r24
    2a6c:	39 f4       	brne	.+14     	; 0x2a7c <xTaskIncrementTick+0xac>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    2a6e:	8f ef       	ldi	r24, 0xFF	; 255
    2a70:	9f ef       	ldi	r25, 0xFF	; 255
    2a72:	90 93 5f 04 	sts	0x045F, r25
    2a76:	80 93 5e 04 	sts	0x045E, r24
    2a7a:	63 c0       	rjmp	.+198    	; 0x2b42 <xTaskIncrementTick+0x172>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2a7c:	e0 91 97 04 	lds	r30, 0x0497
    2a80:	f0 91 98 04 	lds	r31, 0x0498
    2a84:	05 80       	ldd	r0, Z+5	; 0x05
    2a86:	f6 81       	ldd	r31, Z+6	; 0x06
    2a88:	e0 2d       	mov	r30, r0
    2a8a:	86 81       	ldd	r24, Z+6	; 0x06
    2a8c:	97 81       	ldd	r25, Z+7	; 0x07
    2a8e:	99 87       	std	Y+9, r25	; 0x09
    2a90:	88 87       	std	Y+8, r24	; 0x08
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2a92:	e8 85       	ldd	r30, Y+8	; 0x08
    2a94:	f9 85       	ldd	r31, Y+9	; 0x09
    2a96:	82 81       	ldd	r24, Z+2	; 0x02
    2a98:	93 81       	ldd	r25, Z+3	; 0x03
    2a9a:	9f 83       	std	Y+7, r25	; 0x07
    2a9c:	8e 83       	std	Y+6, r24	; 0x06

						if( xConstTickCount < xItemValue )
    2a9e:	2b 81       	ldd	r18, Y+3	; 0x03
    2aa0:	3c 81       	ldd	r19, Y+4	; 0x04
    2aa2:	8e 81       	ldd	r24, Y+6	; 0x06
    2aa4:	9f 81       	ldd	r25, Y+7	; 0x07
    2aa6:	28 17       	cp	r18, r24
    2aa8:	39 07       	cpc	r19, r25
    2aaa:	38 f4       	brcc	.+14     	; 0x2aba <xTaskIncrementTick+0xea>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    2aac:	8e 81       	ldd	r24, Y+6	; 0x06
    2aae:	9f 81       	ldd	r25, Y+7	; 0x07
    2ab0:	90 93 5f 04 	sts	0x045F, r25
    2ab4:	80 93 5e 04 	sts	0x045E, r24
    2ab8:	44 c0       	rjmp	.+136    	; 0x2b42 <xTaskIncrementTick+0x172>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2aba:	88 85       	ldd	r24, Y+8	; 0x08
    2abc:	99 85       	ldd	r25, Y+9	; 0x09
    2abe:	02 96       	adiw	r24, 0x02	; 2
    2ac0:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2ac4:	e8 85       	ldd	r30, Y+8	; 0x08
    2ac6:	f9 85       	ldd	r31, Y+9	; 0x09
    2ac8:	84 89       	ldd	r24, Z+20	; 0x14
    2aca:	95 89       	ldd	r25, Z+21	; 0x15
    2acc:	00 97       	sbiw	r24, 0x00	; 0
    2ace:	29 f0       	breq	.+10     	; 0x2ada <xTaskIncrementTick+0x10a>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2ad0:	88 85       	ldd	r24, Y+8	; 0x08
    2ad2:	99 85       	ldd	r25, Y+9	; 0x09
    2ad4:	0c 96       	adiw	r24, 0x0c	; 12
    2ad6:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    2ada:	e8 85       	ldd	r30, Y+8	; 0x08
    2adc:	f9 85       	ldd	r31, Y+9	; 0x09
    2ade:	96 89       	ldd	r25, Z+22	; 0x16
    2ae0:	80 91 58 04 	lds	r24, 0x0458
    2ae4:	89 17       	cp	r24, r25
    2ae6:	28 f4       	brcc	.+10     	; 0x2af2 <xTaskIncrementTick+0x122>
    2ae8:	e8 85       	ldd	r30, Y+8	; 0x08
    2aea:	f9 85       	ldd	r31, Y+9	; 0x09
    2aec:	86 89       	ldd	r24, Z+22	; 0x16
    2aee:	80 93 58 04 	sts	0x0458, r24
    2af2:	e8 85       	ldd	r30, Y+8	; 0x08
    2af4:	f9 85       	ldd	r31, Y+9	; 0x09
    2af6:	86 89       	ldd	r24, Z+22	; 0x16
    2af8:	28 2f       	mov	r18, r24
    2afa:	30 e0       	ldi	r19, 0x00	; 0
    2afc:	c9 01       	movw	r24, r18
    2afe:	88 0f       	add	r24, r24
    2b00:	99 1f       	adc	r25, r25
    2b02:	88 0f       	add	r24, r24
    2b04:	99 1f       	adc	r25, r25
    2b06:	88 0f       	add	r24, r24
    2b08:	99 1f       	adc	r25, r25
    2b0a:	82 0f       	add	r24, r18
    2b0c:	93 1f       	adc	r25, r19
    2b0e:	ac 01       	movw	r20, r24
    2b10:	4f 59       	subi	r20, 0x9F	; 159
    2b12:	5b 4f       	sbci	r21, 0xFB	; 251
    2b14:	88 85       	ldd	r24, Y+8	; 0x08
    2b16:	99 85       	ldd	r25, Y+9	; 0x09
    2b18:	9c 01       	movw	r18, r24
    2b1a:	2e 5f       	subi	r18, 0xFE	; 254
    2b1c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b1e:	ca 01       	movw	r24, r20
    2b20:	b9 01       	movw	r22, r18
    2b22:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2b26:	e8 85       	ldd	r30, Y+8	; 0x08
    2b28:	f9 85       	ldd	r31, Y+9	; 0x09
    2b2a:	96 89       	ldd	r25, Z+22	; 0x16
    2b2c:	e0 91 52 04 	lds	r30, 0x0452
    2b30:	f0 91 53 04 	lds	r31, 0x0453
    2b34:	86 89       	ldd	r24, Z+22	; 0x16
    2b36:	98 17       	cp	r25, r24
    2b38:	08 f4       	brcc	.+2      	; 0x2b3c <xTaskIncrementTick+0x16c>
    2b3a:	92 cf       	rjmp	.-220    	; 0x2a60 <xTaskIncrementTick+0x90>
							{
								xSwitchRequired = pdTRUE;
    2b3c:	81 e0       	ldi	r24, 0x01	; 1
    2b3e:	8d 83       	std	Y+5, r24	; 0x05
    2b40:	8f cf       	rjmp	.-226    	; 0x2a60 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    2b42:	e0 91 52 04 	lds	r30, 0x0452
    2b46:	f0 91 53 04 	lds	r31, 0x0453
    2b4a:	86 89       	ldd	r24, Z+22	; 0x16
    2b4c:	28 2f       	mov	r18, r24
    2b4e:	30 e0       	ldi	r19, 0x00	; 0
    2b50:	c9 01       	movw	r24, r18
    2b52:	88 0f       	add	r24, r24
    2b54:	99 1f       	adc	r25, r25
    2b56:	88 0f       	add	r24, r24
    2b58:	99 1f       	adc	r25, r25
    2b5a:	88 0f       	add	r24, r24
    2b5c:	99 1f       	adc	r25, r25
    2b5e:	82 0f       	add	r24, r18
    2b60:	93 1f       	adc	r25, r19
    2b62:	fc 01       	movw	r30, r24
    2b64:	ef 59       	subi	r30, 0x9F	; 159
    2b66:	fb 4f       	sbci	r31, 0xFB	; 251
    2b68:	80 81       	ld	r24, Z
    2b6a:	82 30       	cpi	r24, 0x02	; 2
    2b6c:	40 f0       	brcs	.+16     	; 0x2b7e <xTaskIncrementTick+0x1ae>
			{
				xSwitchRequired = pdTRUE;
    2b6e:	81 e0       	ldi	r24, 0x01	; 1
    2b70:	8d 83       	std	Y+5, r24	; 0x05
    2b72:	05 c0       	rjmp	.+10     	; 0x2b7e <xTaskIncrementTick+0x1ae>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2b74:	80 91 5a 04 	lds	r24, 0x045A
    2b78:	8f 5f       	subi	r24, 0xFF	; 255
    2b7a:	80 93 5a 04 	sts	0x045A, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2b7e:	80 91 5b 04 	lds	r24, 0x045B
    2b82:	88 23       	and	r24, r24
    2b84:	11 f0       	breq	.+4      	; 0x2b8a <xTaskIncrementTick+0x1ba>
		{
			xSwitchRequired = pdTRUE;
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2b8a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2b8c:	29 96       	adiw	r28, 0x09	; 9
    2b8e:	0f b6       	in	r0, 0x3f	; 63
    2b90:	f8 94       	cli
    2b92:	de bf       	out	0x3e, r29	; 62
    2b94:	0f be       	out	0x3f, r0	; 63
    2b96:	cd bf       	out	0x3d, r28	; 61
    2b98:	cf 91       	pop	r28
    2b9a:	df 91       	pop	r29
    2b9c:	08 95       	ret

00002b9e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2b9e:	df 93       	push	r29
    2ba0:	cf 93       	push	r28
    2ba2:	00 d0       	rcall	.+0      	; 0x2ba4 <vTaskSwitchContext+0x6>
    2ba4:	cd b7       	in	r28, 0x3d	; 61
    2ba6:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2ba8:	80 91 60 04 	lds	r24, 0x0460
    2bac:	88 23       	and	r24, r24
    2bae:	21 f0       	breq	.+8      	; 0x2bb8 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2bb0:	81 e0       	ldi	r24, 0x01	; 1
    2bb2:	80 93 5b 04 	sts	0x045B, r24
    2bb6:	57 c0       	rjmp	.+174    	; 0x2c66 <vTaskSwitchContext+0xc8>
	}
	else
	{
		xYieldPending = pdFALSE;
    2bb8:	10 92 5b 04 	sts	0x045B, r1
    2bbc:	05 c0       	rjmp	.+10     	; 0x2bc8 <vTaskSwitchContext+0x2a>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2bbe:	80 91 58 04 	lds	r24, 0x0458
    2bc2:	81 50       	subi	r24, 0x01	; 1
    2bc4:	80 93 58 04 	sts	0x0458, r24
    2bc8:	80 91 58 04 	lds	r24, 0x0458
    2bcc:	28 2f       	mov	r18, r24
    2bce:	30 e0       	ldi	r19, 0x00	; 0
    2bd0:	c9 01       	movw	r24, r18
    2bd2:	88 0f       	add	r24, r24
    2bd4:	99 1f       	adc	r25, r25
    2bd6:	88 0f       	add	r24, r24
    2bd8:	99 1f       	adc	r25, r25
    2bda:	88 0f       	add	r24, r24
    2bdc:	99 1f       	adc	r25, r25
    2bde:	82 0f       	add	r24, r18
    2be0:	93 1f       	adc	r25, r19
    2be2:	fc 01       	movw	r30, r24
    2be4:	ef 59       	subi	r30, 0x9F	; 159
    2be6:	fb 4f       	sbci	r31, 0xFB	; 251
    2be8:	80 81       	ld	r24, Z
    2bea:	88 23       	and	r24, r24
    2bec:	41 f3       	breq	.-48     	; 0x2bbe <vTaskSwitchContext+0x20>
    2bee:	80 91 58 04 	lds	r24, 0x0458
    2bf2:	28 2f       	mov	r18, r24
    2bf4:	30 e0       	ldi	r19, 0x00	; 0
    2bf6:	c9 01       	movw	r24, r18
    2bf8:	88 0f       	add	r24, r24
    2bfa:	99 1f       	adc	r25, r25
    2bfc:	88 0f       	add	r24, r24
    2bfe:	99 1f       	adc	r25, r25
    2c00:	88 0f       	add	r24, r24
    2c02:	99 1f       	adc	r25, r25
    2c04:	82 0f       	add	r24, r18
    2c06:	93 1f       	adc	r25, r19
    2c08:	8f 59       	subi	r24, 0x9F	; 159
    2c0a:	9b 4f       	sbci	r25, 0xFB	; 251
    2c0c:	9a 83       	std	Y+2, r25	; 0x02
    2c0e:	89 83       	std	Y+1, r24	; 0x01
    2c10:	e9 81       	ldd	r30, Y+1	; 0x01
    2c12:	fa 81       	ldd	r31, Y+2	; 0x02
    2c14:	01 80       	ldd	r0, Z+1	; 0x01
    2c16:	f2 81       	ldd	r31, Z+2	; 0x02
    2c18:	e0 2d       	mov	r30, r0
    2c1a:	82 81       	ldd	r24, Z+2	; 0x02
    2c1c:	93 81       	ldd	r25, Z+3	; 0x03
    2c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c20:	fa 81       	ldd	r31, Y+2	; 0x02
    2c22:	92 83       	std	Z+2, r25	; 0x02
    2c24:	81 83       	std	Z+1, r24	; 0x01
    2c26:	e9 81       	ldd	r30, Y+1	; 0x01
    2c28:	fa 81       	ldd	r31, Y+2	; 0x02
    2c2a:	21 81       	ldd	r18, Z+1	; 0x01
    2c2c:	32 81       	ldd	r19, Z+2	; 0x02
    2c2e:	89 81       	ldd	r24, Y+1	; 0x01
    2c30:	9a 81       	ldd	r25, Y+2	; 0x02
    2c32:	03 96       	adiw	r24, 0x03	; 3
    2c34:	28 17       	cp	r18, r24
    2c36:	39 07       	cpc	r19, r25
    2c38:	59 f4       	brne	.+22     	; 0x2c50 <vTaskSwitchContext+0xb2>
    2c3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c3e:	01 80       	ldd	r0, Z+1	; 0x01
    2c40:	f2 81       	ldd	r31, Z+2	; 0x02
    2c42:	e0 2d       	mov	r30, r0
    2c44:	82 81       	ldd	r24, Z+2	; 0x02
    2c46:	93 81       	ldd	r25, Z+3	; 0x03
    2c48:	e9 81       	ldd	r30, Y+1	; 0x01
    2c4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2c4c:	92 83       	std	Z+2, r25	; 0x02
    2c4e:	81 83       	std	Z+1, r24	; 0x01
    2c50:	e9 81       	ldd	r30, Y+1	; 0x01
    2c52:	fa 81       	ldd	r31, Y+2	; 0x02
    2c54:	01 80       	ldd	r0, Z+1	; 0x01
    2c56:	f2 81       	ldd	r31, Z+2	; 0x02
    2c58:	e0 2d       	mov	r30, r0
    2c5a:	86 81       	ldd	r24, Z+6	; 0x06
    2c5c:	97 81       	ldd	r25, Z+7	; 0x07
    2c5e:	90 93 53 04 	sts	0x0453, r25
    2c62:	80 93 52 04 	sts	0x0452, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    2c66:	0f 90       	pop	r0
    2c68:	0f 90       	pop	r0
    2c6a:	cf 91       	pop	r28
    2c6c:	df 91       	pop	r29
    2c6e:	08 95       	ret

00002c70 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2c70:	df 93       	push	r29
    2c72:	cf 93       	push	r28
    2c74:	00 d0       	rcall	.+0      	; 0x2c76 <vTaskPlaceOnEventList+0x6>
    2c76:	00 d0       	rcall	.+0      	; 0x2c78 <vTaskPlaceOnEventList+0x8>
    2c78:	00 d0       	rcall	.+0      	; 0x2c7a <vTaskPlaceOnEventList+0xa>
    2c7a:	cd b7       	in	r28, 0x3d	; 61
    2c7c:	de b7       	in	r29, 0x3e	; 62
    2c7e:	9c 83       	std	Y+4, r25	; 0x04
    2c80:	8b 83       	std	Y+3, r24	; 0x03
    2c82:	7e 83       	std	Y+6, r23	; 0x06
    2c84:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2c86:	80 91 52 04 	lds	r24, 0x0452
    2c8a:	90 91 53 04 	lds	r25, 0x0453
    2c8e:	9c 01       	movw	r18, r24
    2c90:	24 5f       	subi	r18, 0xF4	; 244
    2c92:	3f 4f       	sbci	r19, 0xFF	; 255
    2c94:	8b 81       	ldd	r24, Y+3	; 0x03
    2c96:	9c 81       	ldd	r25, Y+4	; 0x04
    2c98:	b9 01       	movw	r22, r18
    2c9a:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2c9e:	80 91 52 04 	lds	r24, 0x0452
    2ca2:	90 91 53 04 	lds	r25, 0x0453
    2ca6:	02 96       	adiw	r24, 0x02	; 2
    2ca8:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the scheduler
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2cac:	20 91 56 04 	lds	r18, 0x0456
    2cb0:	30 91 57 04 	lds	r19, 0x0457
    2cb4:	8d 81       	ldd	r24, Y+5	; 0x05
    2cb6:	9e 81       	ldd	r25, Y+6	; 0x06
    2cb8:	82 0f       	add	r24, r18
    2cba:	93 1f       	adc	r25, r19
    2cbc:	9a 83       	std	Y+2, r25	; 0x02
    2cbe:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2cc0:	89 81       	ldd	r24, Y+1	; 0x01
    2cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    2cc4:	0e 94 0e 19 	call	0x321c	; 0x321c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2cc8:	26 96       	adiw	r28, 0x06	; 6
    2cca:	0f b6       	in	r0, 0x3f	; 63
    2ccc:	f8 94       	cli
    2cce:	de bf       	out	0x3e, r29	; 62
    2cd0:	0f be       	out	0x3f, r0	; 63
    2cd2:	cd bf       	out	0x3d, r28	; 61
    2cd4:	cf 91       	pop	r28
    2cd6:	df 91       	pop	r29
    2cd8:	08 95       	ret

00002cda <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    2cda:	df 93       	push	r29
    2cdc:	cf 93       	push	r28
    2cde:	cd b7       	in	r28, 0x3d	; 61
    2ce0:	de b7       	in	r29, 0x3e	; 62
    2ce2:	28 97       	sbiw	r28, 0x08	; 8
    2ce4:	0f b6       	in	r0, 0x3f	; 63
    2ce6:	f8 94       	cli
    2ce8:	de bf       	out	0x3e, r29	; 62
    2cea:	0f be       	out	0x3f, r0	; 63
    2cec:	cd bf       	out	0x3d, r28	; 61
    2cee:	9c 83       	std	Y+4, r25	; 0x04
    2cf0:	8b 83       	std	Y+3, r24	; 0x03
    2cf2:	7e 83       	std	Y+6, r23	; 0x06
    2cf4:	6d 83       	std	Y+5, r22	; 0x05
    2cf6:	58 87       	std	Y+8, r21	; 0x08
    2cf8:	4f 83       	std	Y+7, r20	; 0x07
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2cfa:	e0 91 52 04 	lds	r30, 0x0452
    2cfe:	f0 91 53 04 	lds	r31, 0x0453
    2d02:	8d 81       	ldd	r24, Y+5	; 0x05
    2d04:	9e 81       	ldd	r25, Y+6	; 0x06
    2d06:	90 68       	ori	r25, 0x80	; 128
    2d08:	95 87       	std	Z+13, r25	; 0x0d
    2d0a:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    2d0c:	80 91 52 04 	lds	r24, 0x0452
    2d10:	90 91 53 04 	lds	r25, 0x0453
    2d14:	9c 01       	movw	r18, r24
    2d16:	24 5f       	subi	r18, 0xF4	; 244
    2d18:	3f 4f       	sbci	r19, 0xFF	; 255
    2d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d1e:	b9 01       	movw	r22, r18
    2d20:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>

	/* The task must be removed from the ready list before it is added to the
	blocked list.  Exclusive access can be assured to the ready list as the
	scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2d24:	80 91 52 04 	lds	r24, 0x0452
    2d28:	90 91 53 04 	lds	r25, 0x0453
    2d2c:	02 96       	adiw	r24, 0x02	; 2
    2d2e:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter, the kernel
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
    2d32:	20 91 56 04 	lds	r18, 0x0456
    2d36:	30 91 57 04 	lds	r19, 0x0457
    2d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    2d3c:	98 85       	ldd	r25, Y+8	; 0x08
    2d3e:	82 0f       	add	r24, r18
    2d40:	93 1f       	adc	r25, r19
    2d42:	9a 83       	std	Y+2, r25	; 0x02
    2d44:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    2d46:	89 81       	ldd	r24, Y+1	; 0x01
    2d48:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4a:	0e 94 0e 19 	call	0x321c	; 0x321c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    2d4e:	28 96       	adiw	r28, 0x08	; 8
    2d50:	0f b6       	in	r0, 0x3f	; 63
    2d52:	f8 94       	cli
    2d54:	de bf       	out	0x3e, r29	; 62
    2d56:	0f be       	out	0x3f, r0	; 63
    2d58:	cd bf       	out	0x3d, r28	; 61
    2d5a:	cf 91       	pop	r28
    2d5c:	df 91       	pop	r29
    2d5e:	08 95       	ret

00002d60 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    2d60:	df 93       	push	r29
    2d62:	cf 93       	push	r28
    2d64:	00 d0       	rcall	.+0      	; 0x2d66 <xTaskRemoveFromEventList+0x6>
    2d66:	00 d0       	rcall	.+0      	; 0x2d68 <xTaskRemoveFromEventList+0x8>
    2d68:	0f 92       	push	r0
    2d6a:	cd b7       	in	r28, 0x3d	; 61
    2d6c:	de b7       	in	r29, 0x3e	; 62
    2d6e:	9d 83       	std	Y+5, r25	; 0x05
    2d70:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2d72:	ec 81       	ldd	r30, Y+4	; 0x04
    2d74:	fd 81       	ldd	r31, Y+5	; 0x05
    2d76:	05 80       	ldd	r0, Z+5	; 0x05
    2d78:	f6 81       	ldd	r31, Z+6	; 0x06
    2d7a:	e0 2d       	mov	r30, r0
    2d7c:	86 81       	ldd	r24, Z+6	; 0x06
    2d7e:	97 81       	ldd	r25, Z+7	; 0x07
    2d80:	9b 83       	std	Y+3, r25	; 0x03
    2d82:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2d84:	8a 81       	ldd	r24, Y+2	; 0x02
    2d86:	9b 81       	ldd	r25, Y+3	; 0x03
    2d88:	0c 96       	adiw	r24, 0x0c	; 12
    2d8a:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2d8e:	80 91 60 04 	lds	r24, 0x0460
    2d92:	88 23       	and	r24, r24
    2d94:	61 f5       	brne	.+88     	; 0x2dee <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2d96:	8a 81       	ldd	r24, Y+2	; 0x02
    2d98:	9b 81       	ldd	r25, Y+3	; 0x03
    2d9a:	02 96       	adiw	r24, 0x02	; 2
    2d9c:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2da0:	ea 81       	ldd	r30, Y+2	; 0x02
    2da2:	fb 81       	ldd	r31, Y+3	; 0x03
    2da4:	96 89       	ldd	r25, Z+22	; 0x16
    2da6:	80 91 58 04 	lds	r24, 0x0458
    2daa:	89 17       	cp	r24, r25
    2dac:	28 f4       	brcc	.+10     	; 0x2db8 <xTaskRemoveFromEventList+0x58>
    2dae:	ea 81       	ldd	r30, Y+2	; 0x02
    2db0:	fb 81       	ldd	r31, Y+3	; 0x03
    2db2:	86 89       	ldd	r24, Z+22	; 0x16
    2db4:	80 93 58 04 	sts	0x0458, r24
    2db8:	ea 81       	ldd	r30, Y+2	; 0x02
    2dba:	fb 81       	ldd	r31, Y+3	; 0x03
    2dbc:	86 89       	ldd	r24, Z+22	; 0x16
    2dbe:	28 2f       	mov	r18, r24
    2dc0:	30 e0       	ldi	r19, 0x00	; 0
    2dc2:	c9 01       	movw	r24, r18
    2dc4:	88 0f       	add	r24, r24
    2dc6:	99 1f       	adc	r25, r25
    2dc8:	88 0f       	add	r24, r24
    2dca:	99 1f       	adc	r25, r25
    2dcc:	88 0f       	add	r24, r24
    2dce:	99 1f       	adc	r25, r25
    2dd0:	82 0f       	add	r24, r18
    2dd2:	93 1f       	adc	r25, r19
    2dd4:	ac 01       	movw	r20, r24
    2dd6:	4f 59       	subi	r20, 0x9F	; 159
    2dd8:	5b 4f       	sbci	r21, 0xFB	; 251
    2dda:	8a 81       	ldd	r24, Y+2	; 0x02
    2ddc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dde:	9c 01       	movw	r18, r24
    2de0:	2e 5f       	subi	r18, 0xFE	; 254
    2de2:	3f 4f       	sbci	r19, 0xFF	; 255
    2de4:	ca 01       	movw	r24, r20
    2de6:	b9 01       	movw	r22, r18
    2de8:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
    2dec:	0a c0       	rjmp	.+20     	; 0x2e02 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2dee:	8a 81       	ldd	r24, Y+2	; 0x02
    2df0:	9b 81       	ldd	r25, Y+3	; 0x03
    2df2:	9c 01       	movw	r18, r24
    2df4:	24 5f       	subi	r18, 0xF4	; 244
    2df6:	3f 4f       	sbci	r19, 0xFF	; 255
    2df8:	8b e9       	ldi	r24, 0x9B	; 155
    2dfa:	94 e0       	ldi	r25, 0x04	; 4
    2dfc:	b9 01       	movw	r22, r18
    2dfe:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2e02:	ea 81       	ldd	r30, Y+2	; 0x02
    2e04:	fb 81       	ldd	r31, Y+3	; 0x03
    2e06:	96 89       	ldd	r25, Z+22	; 0x16
    2e08:	e0 91 52 04 	lds	r30, 0x0452
    2e0c:	f0 91 53 04 	lds	r31, 0x0453
    2e10:	86 89       	ldd	r24, Z+22	; 0x16
    2e12:	89 17       	cp	r24, r25
    2e14:	30 f4       	brcc	.+12     	; 0x2e22 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    2e16:	81 e0       	ldi	r24, 0x01	; 1
    2e18:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2e1a:	81 e0       	ldi	r24, 0x01	; 1
    2e1c:	80 93 5b 04 	sts	0x045B, r24
    2e20:	01 c0       	rjmp	.+2      	; 0x2e24 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    2e22:	19 82       	std	Y+1, r1	; 0x01
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
    2e24:	89 81       	ldd	r24, Y+1	; 0x01
}
    2e26:	0f 90       	pop	r0
    2e28:	0f 90       	pop	r0
    2e2a:	0f 90       	pop	r0
    2e2c:	0f 90       	pop	r0
    2e2e:	0f 90       	pop	r0
    2e30:	cf 91       	pop	r28
    2e32:	df 91       	pop	r29
    2e34:	08 95       	ret

00002e36 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    2e36:	df 93       	push	r29
    2e38:	cf 93       	push	r28
    2e3a:	cd b7       	in	r28, 0x3d	; 61
    2e3c:	de b7       	in	r29, 0x3e	; 62
    2e3e:	27 97       	sbiw	r28, 0x07	; 7
    2e40:	0f b6       	in	r0, 0x3f	; 63
    2e42:	f8 94       	cli
    2e44:	de bf       	out	0x3e, r29	; 62
    2e46:	0f be       	out	0x3f, r0	; 63
    2e48:	cd bf       	out	0x3d, r28	; 61
    2e4a:	9d 83       	std	Y+5, r25	; 0x05
    2e4c:	8c 83       	std	Y+4, r24	; 0x04
    2e4e:	7f 83       	std	Y+7, r23	; 0x07
    2e50:	6e 83       	std	Y+6, r22	; 0x06
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    2e52:	8e 81       	ldd	r24, Y+6	; 0x06
    2e54:	9f 81       	ldd	r25, Y+7	; 0x07
    2e56:	90 68       	ori	r25, 0x80	; 128
    2e58:	ec 81       	ldd	r30, Y+4	; 0x04
    2e5a:	fd 81       	ldd	r31, Y+5	; 0x05
    2e5c:	91 83       	std	Z+1, r25	; 0x01
    2e5e:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    2e60:	ec 81       	ldd	r30, Y+4	; 0x04
    2e62:	fd 81       	ldd	r31, Y+5	; 0x05
    2e64:	86 81       	ldd	r24, Z+6	; 0x06
    2e66:	97 81       	ldd	r25, Z+7	; 0x07
    2e68:	9b 83       	std	Y+3, r25	; 0x03
    2e6a:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    2e6c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e6e:	9d 81       	ldd	r25, Y+5	; 0x05
    2e70:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2e74:	8a 81       	ldd	r24, Y+2	; 0x02
    2e76:	9b 81       	ldd	r25, Y+3	; 0x03
    2e78:	02 96       	adiw	r24, 0x02	; 2
    2e7a:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    2e7e:	ea 81       	ldd	r30, Y+2	; 0x02
    2e80:	fb 81       	ldd	r31, Y+3	; 0x03
    2e82:	96 89       	ldd	r25, Z+22	; 0x16
    2e84:	80 91 58 04 	lds	r24, 0x0458
    2e88:	89 17       	cp	r24, r25
    2e8a:	28 f4       	brcc	.+10     	; 0x2e96 <xTaskRemoveFromUnorderedEventList+0x60>
    2e8c:	ea 81       	ldd	r30, Y+2	; 0x02
    2e8e:	fb 81       	ldd	r31, Y+3	; 0x03
    2e90:	86 89       	ldd	r24, Z+22	; 0x16
    2e92:	80 93 58 04 	sts	0x0458, r24
    2e96:	ea 81       	ldd	r30, Y+2	; 0x02
    2e98:	fb 81       	ldd	r31, Y+3	; 0x03
    2e9a:	86 89       	ldd	r24, Z+22	; 0x16
    2e9c:	28 2f       	mov	r18, r24
    2e9e:	30 e0       	ldi	r19, 0x00	; 0
    2ea0:	c9 01       	movw	r24, r18
    2ea2:	88 0f       	add	r24, r24
    2ea4:	99 1f       	adc	r25, r25
    2ea6:	88 0f       	add	r24, r24
    2ea8:	99 1f       	adc	r25, r25
    2eaa:	88 0f       	add	r24, r24
    2eac:	99 1f       	adc	r25, r25
    2eae:	82 0f       	add	r24, r18
    2eb0:	93 1f       	adc	r25, r19
    2eb2:	ac 01       	movw	r20, r24
    2eb4:	4f 59       	subi	r20, 0x9F	; 159
    2eb6:	5b 4f       	sbci	r21, 0xFB	; 251
    2eb8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eba:	9b 81       	ldd	r25, Y+3	; 0x03
    2ebc:	9c 01       	movw	r18, r24
    2ebe:	2e 5f       	subi	r18, 0xFE	; 254
    2ec0:	3f 4f       	sbci	r19, 0xFF	; 255
    2ec2:	ca 01       	movw	r24, r20
    2ec4:	b9 01       	movw	r22, r18
    2ec6:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2eca:	ea 81       	ldd	r30, Y+2	; 0x02
    2ecc:	fb 81       	ldd	r31, Y+3	; 0x03
    2ece:	96 89       	ldd	r25, Z+22	; 0x16
    2ed0:	e0 91 52 04 	lds	r30, 0x0452
    2ed4:	f0 91 53 04 	lds	r31, 0x0453
    2ed8:	86 89       	ldd	r24, Z+22	; 0x16
    2eda:	89 17       	cp	r24, r25
    2edc:	30 f4       	brcc	.+12     	; 0x2eea <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2ede:	81 e0       	ldi	r24, 0x01	; 1
    2ee0:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2ee2:	81 e0       	ldi	r24, 0x01	; 1
    2ee4:	80 93 5b 04 	sts	0x045B, r24
    2ee8:	01 c0       	rjmp	.+2      	; 0x2eec <xTaskRemoveFromUnorderedEventList+0xb6>
	}
	else
	{
		xReturn = pdFALSE;
    2eea:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2eec:	89 81       	ldd	r24, Y+1	; 0x01
}
    2eee:	27 96       	adiw	r28, 0x07	; 7
    2ef0:	0f b6       	in	r0, 0x3f	; 63
    2ef2:	f8 94       	cli
    2ef4:	de bf       	out	0x3e, r29	; 62
    2ef6:	0f be       	out	0x3f, r0	; 63
    2ef8:	cd bf       	out	0x3d, r28	; 61
    2efa:	cf 91       	pop	r28
    2efc:	df 91       	pop	r29
    2efe:	08 95       	ret

00002f00 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    2f00:	df 93       	push	r29
    2f02:	cf 93       	push	r28
    2f04:	00 d0       	rcall	.+0      	; 0x2f06 <vTaskSetTimeOutState+0x6>
    2f06:	cd b7       	in	r28, 0x3d	; 61
    2f08:	de b7       	in	r29, 0x3e	; 62
    2f0a:	9a 83       	std	Y+2, r25	; 0x02
    2f0c:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2f0e:	80 91 5c 04 	lds	r24, 0x045C
    2f12:	e9 81       	ldd	r30, Y+1	; 0x01
    2f14:	fa 81       	ldd	r31, Y+2	; 0x02
    2f16:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2f18:	80 91 56 04 	lds	r24, 0x0456
    2f1c:	90 91 57 04 	lds	r25, 0x0457
    2f20:	e9 81       	ldd	r30, Y+1	; 0x01
    2f22:	fa 81       	ldd	r31, Y+2	; 0x02
    2f24:	92 83       	std	Z+2, r25	; 0x02
    2f26:	81 83       	std	Z+1, r24	; 0x01
}
    2f28:	0f 90       	pop	r0
    2f2a:	0f 90       	pop	r0
    2f2c:	cf 91       	pop	r28
    2f2e:	df 91       	pop	r29
    2f30:	08 95       	ret

00002f32 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2f32:	df 93       	push	r29
    2f34:	cf 93       	push	r28
    2f36:	cd b7       	in	r28, 0x3d	; 61
    2f38:	de b7       	in	r29, 0x3e	; 62
    2f3a:	27 97       	sbiw	r28, 0x07	; 7
    2f3c:	0f b6       	in	r0, 0x3f	; 63
    2f3e:	f8 94       	cli
    2f40:	de bf       	out	0x3e, r29	; 62
    2f42:	0f be       	out	0x3f, r0	; 63
    2f44:	cd bf       	out	0x3d, r28	; 61
    2f46:	9d 83       	std	Y+5, r25	; 0x05
    2f48:	8c 83       	std	Y+4, r24	; 0x04
    2f4a:	7f 83       	std	Y+7, r23	; 0x07
    2f4c:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2f4e:	0f b6       	in	r0, 0x3f	; 63
    2f50:	f8 94       	cli
    2f52:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2f54:	80 91 56 04 	lds	r24, 0x0456
    2f58:	90 91 57 04 	lds	r25, 0x0457
    2f5c:	9a 83       	std	Y+2, r25	; 0x02
    2f5e:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2f60:	ec 81       	ldd	r30, Y+4	; 0x04
    2f62:	fd 81       	ldd	r31, Y+5	; 0x05
    2f64:	90 81       	ld	r25, Z
    2f66:	80 91 5c 04 	lds	r24, 0x045C
    2f6a:	98 17       	cp	r25, r24
    2f6c:	61 f0       	breq	.+24     	; 0x2f86 <xTaskCheckForTimeOut+0x54>
    2f6e:	ec 81       	ldd	r30, Y+4	; 0x04
    2f70:	fd 81       	ldd	r31, Y+5	; 0x05
    2f72:	21 81       	ldd	r18, Z+1	; 0x01
    2f74:	32 81       	ldd	r19, Z+2	; 0x02
    2f76:	89 81       	ldd	r24, Y+1	; 0x01
    2f78:	9a 81       	ldd	r25, Y+2	; 0x02
    2f7a:	82 17       	cp	r24, r18
    2f7c:	93 07       	cpc	r25, r19
    2f7e:	18 f0       	brcs	.+6      	; 0x2f86 <xTaskCheckForTimeOut+0x54>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2f80:	81 e0       	ldi	r24, 0x01	; 1
    2f82:	8b 83       	std	Y+3, r24	; 0x03
    2f84:	2d c0       	rjmp	.+90     	; 0x2fe0 <xTaskCheckForTimeOut+0xae>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2f86:	ec 81       	ldd	r30, Y+4	; 0x04
    2f88:	fd 81       	ldd	r31, Y+5	; 0x05
    2f8a:	21 81       	ldd	r18, Z+1	; 0x01
    2f8c:	32 81       	ldd	r19, Z+2	; 0x02
    2f8e:	89 81       	ldd	r24, Y+1	; 0x01
    2f90:	9a 81       	ldd	r25, Y+2	; 0x02
    2f92:	ac 01       	movw	r20, r24
    2f94:	42 1b       	sub	r20, r18
    2f96:	53 0b       	sbc	r21, r19
    2f98:	9a 01       	movw	r18, r20
    2f9a:	ee 81       	ldd	r30, Y+6	; 0x06
    2f9c:	ff 81       	ldd	r31, Y+7	; 0x07
    2f9e:	80 81       	ld	r24, Z
    2fa0:	91 81       	ldd	r25, Z+1	; 0x01
    2fa2:	28 17       	cp	r18, r24
    2fa4:	39 07       	cpc	r19, r25
    2fa6:	d0 f4       	brcc	.+52     	; 0x2fdc <xTaskCheckForTimeOut+0xaa>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2fa8:	ee 81       	ldd	r30, Y+6	; 0x06
    2faa:	ff 81       	ldd	r31, Y+7	; 0x07
    2fac:	40 81       	ld	r20, Z
    2fae:	51 81       	ldd	r21, Z+1	; 0x01
    2fb0:	ec 81       	ldd	r30, Y+4	; 0x04
    2fb2:	fd 81       	ldd	r31, Y+5	; 0x05
    2fb4:	21 81       	ldd	r18, Z+1	; 0x01
    2fb6:	32 81       	ldd	r19, Z+2	; 0x02
    2fb8:	89 81       	ldd	r24, Y+1	; 0x01
    2fba:	9a 81       	ldd	r25, Y+2	; 0x02
    2fbc:	b9 01       	movw	r22, r18
    2fbe:	68 1b       	sub	r22, r24
    2fc0:	79 0b       	sbc	r23, r25
    2fc2:	cb 01       	movw	r24, r22
    2fc4:	84 0f       	add	r24, r20
    2fc6:	95 1f       	adc	r25, r21
    2fc8:	ee 81       	ldd	r30, Y+6	; 0x06
    2fca:	ff 81       	ldd	r31, Y+7	; 0x07
    2fcc:	91 83       	std	Z+1, r25	; 0x01
    2fce:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    2fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    2fd4:	0e 94 80 17 	call	0x2f00	; 0x2f00 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2fd8:	1b 82       	std	Y+3, r1	; 0x03
    2fda:	02 c0       	rjmp	.+4      	; 0x2fe0 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			xReturn = pdTRUE;
    2fdc:	81 e0       	ldi	r24, 0x01	; 1
    2fde:	8b 83       	std	Y+3, r24	; 0x03
		}
	}
	taskEXIT_CRITICAL();
    2fe0:	0f 90       	pop	r0
    2fe2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2fe4:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2fe6:	27 96       	adiw	r28, 0x07	; 7
    2fe8:	0f b6       	in	r0, 0x3f	; 63
    2fea:	f8 94       	cli
    2fec:	de bf       	out	0x3e, r29	; 62
    2fee:	0f be       	out	0x3f, r0	; 63
    2ff0:	cd bf       	out	0x3d, r28	; 61
    2ff2:	cf 91       	pop	r28
    2ff4:	df 91       	pop	r29
    2ff6:	08 95       	ret

00002ff8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2ff8:	df 93       	push	r29
    2ffa:	cf 93       	push	r28
    2ffc:	cd b7       	in	r28, 0x3d	; 61
    2ffe:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3000:	81 e0       	ldi	r24, 0x01	; 1
    3002:	80 93 5b 04 	sts	0x045B, r24
}
    3006:	cf 91       	pop	r28
    3008:	df 91       	pop	r29
    300a:	08 95       	ret

0000300c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    300c:	df 93       	push	r29
    300e:	cf 93       	push	r28
    3010:	00 d0       	rcall	.+0      	; 0x3012 <prvIdleTask+0x6>
    3012:	cd b7       	in	r28, 0x3d	; 61
    3014:	de b7       	in	r29, 0x3e	; 62
    3016:	9a 83       	std	Y+2, r25	; 0x02
    3018:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    301a:	0e 94 cf 18 	call	0x319e	; 0x319e <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    301e:	80 91 61 04 	lds	r24, 0x0461
    3022:	82 30       	cpi	r24, 0x02	; 2
    3024:	d0 f3       	brcs	.-12     	; 0x301a <prvIdleTask+0xe>
			{
				taskYIELD();
    3026:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
    302a:	f7 cf       	rjmp	.-18     	; 0x301a <prvIdleTask+0xe>

0000302c <prvInitialiseTCBVariables>:

#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    302c:	0f 93       	push	r16
    302e:	1f 93       	push	r17
    3030:	df 93       	push	r29
    3032:	cf 93       	push	r28
    3034:	cd b7       	in	r28, 0x3d	; 61
    3036:	de b7       	in	r29, 0x3e	; 62
    3038:	2a 97       	sbiw	r28, 0x0a	; 10
    303a:	0f b6       	in	r0, 0x3f	; 63
    303c:	f8 94       	cli
    303e:	de bf       	out	0x3e, r29	; 62
    3040:	0f be       	out	0x3f, r0	; 63
    3042:	cd bf       	out	0x3d, r28	; 61
    3044:	9b 83       	std	Y+3, r25	; 0x03
    3046:	8a 83       	std	Y+2, r24	; 0x02
    3048:	7d 83       	std	Y+5, r23	; 0x05
    304a:	6c 83       	std	Y+4, r22	; 0x04
    304c:	4e 83       	std	Y+6, r20	; 0x06
    304e:	38 87       	std	Y+8, r19	; 0x08
    3050:	2f 83       	std	Y+7, r18	; 0x07
    3052:	1a 87       	std	Y+10, r17	; 0x0a
    3054:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3056:	19 82       	std	Y+1, r1	; 0x01
    3058:	21 c0       	rjmp	.+66     	; 0x309c <prvInitialiseTCBVariables+0x70>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	48 2f       	mov	r20, r24
    305e:	50 e0       	ldi	r21, 0x00	; 0
    3060:	89 81       	ldd	r24, Y+1	; 0x01
    3062:	28 2f       	mov	r18, r24
    3064:	30 e0       	ldi	r19, 0x00	; 0
    3066:	8c 81       	ldd	r24, Y+4	; 0x04
    3068:	9d 81       	ldd	r25, Y+5	; 0x05
    306a:	fc 01       	movw	r30, r24
    306c:	e2 0f       	add	r30, r18
    306e:	f3 1f       	adc	r31, r19
    3070:	20 81       	ld	r18, Z
    3072:	8a 81       	ldd	r24, Y+2	; 0x02
    3074:	9b 81       	ldd	r25, Y+3	; 0x03
    3076:	84 0f       	add	r24, r20
    3078:	95 1f       	adc	r25, r21
    307a:	fc 01       	movw	r30, r24
    307c:	79 96       	adiw	r30, 0x19	; 25
    307e:	20 83       	st	Z, r18

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    3080:	89 81       	ldd	r24, Y+1	; 0x01
    3082:	28 2f       	mov	r18, r24
    3084:	30 e0       	ldi	r19, 0x00	; 0
    3086:	8c 81       	ldd	r24, Y+4	; 0x04
    3088:	9d 81       	ldd	r25, Y+5	; 0x05
    308a:	fc 01       	movw	r30, r24
    308c:	e2 0f       	add	r30, r18
    308e:	f3 1f       	adc	r31, r19
    3090:	80 81       	ld	r24, Z
    3092:	88 23       	and	r24, r24
    3094:	31 f0       	breq	.+12     	; 0x30a2 <prvInitialiseTCBVariables+0x76>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3096:	89 81       	ldd	r24, Y+1	; 0x01
    3098:	8f 5f       	subi	r24, 0xFF	; 255
    309a:	89 83       	std	Y+1, r24	; 0x01
    309c:	89 81       	ldd	r24, Y+1	; 0x01
    309e:	88 30       	cpi	r24, 0x08	; 8
    30a0:	e0 f2       	brcs	.-72     	; 0x305a <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    30a2:	ea 81       	ldd	r30, Y+2	; 0x02
    30a4:	fb 81       	ldd	r31, Y+3	; 0x03
    30a6:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    30a8:	8e 81       	ldd	r24, Y+6	; 0x06
    30aa:	84 30       	cpi	r24, 0x04	; 4
    30ac:	10 f0       	brcs	.+4      	; 0x30b2 <prvInitialiseTCBVariables+0x86>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    30ae:	83 e0       	ldi	r24, 0x03	; 3
    30b0:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    30b2:	ea 81       	ldd	r30, Y+2	; 0x02
    30b4:	fb 81       	ldd	r31, Y+3	; 0x03
    30b6:	8e 81       	ldd	r24, Y+6	; 0x06
    30b8:	86 8b       	std	Z+22, r24	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    30ba:	8a 81       	ldd	r24, Y+2	; 0x02
    30bc:	9b 81       	ldd	r25, Y+3	; 0x03
    30be:	02 96       	adiw	r24, 0x02	; 2
    30c0:	0e 94 5f 08 	call	0x10be	; 0x10be <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    30c4:	8a 81       	ldd	r24, Y+2	; 0x02
    30c6:	9b 81       	ldd	r25, Y+3	; 0x03
    30c8:	0c 96       	adiw	r24, 0x0c	; 12
    30ca:	0e 94 5f 08 	call	0x10be	; 0x10be <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    30ce:	ea 81       	ldd	r30, Y+2	; 0x02
    30d0:	fb 81       	ldd	r31, Y+3	; 0x03
    30d2:	8a 81       	ldd	r24, Y+2	; 0x02
    30d4:	9b 81       	ldd	r25, Y+3	; 0x03
    30d6:	91 87       	std	Z+9, r25	; 0x09
    30d8:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    30da:	8e 81       	ldd	r24, Y+6	; 0x06
    30dc:	28 2f       	mov	r18, r24
    30de:	30 e0       	ldi	r19, 0x00	; 0
    30e0:	84 e0       	ldi	r24, 0x04	; 4
    30e2:	90 e0       	ldi	r25, 0x00	; 0
    30e4:	82 1b       	sub	r24, r18
    30e6:	93 0b       	sbc	r25, r19
    30e8:	ea 81       	ldd	r30, Y+2	; 0x02
    30ea:	fb 81       	ldd	r31, Y+3	; 0x03
    30ec:	95 87       	std	Z+13, r25	; 0x0d
    30ee:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    30f0:	ea 81       	ldd	r30, Y+2	; 0x02
    30f2:	fb 81       	ldd	r31, Y+3	; 0x03
    30f4:	8a 81       	ldd	r24, Y+2	; 0x02
    30f6:	9b 81       	ldd	r25, Y+3	; 0x03
    30f8:	93 8b       	std	Z+19, r25	; 0x13
    30fa:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
    30fc:	ea 81       	ldd	r30, Y+2	; 0x02
    30fe:	fb 81       	ldd	r31, Y+3	; 0x03
    3100:	11 a2       	std	Z+33, r1	; 0x21
    3102:	12 a2       	std	Z+34, r1	; 0x22
    3104:	13 a2       	std	Z+35, r1	; 0x23
    3106:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
    3108:	ea 81       	ldd	r30, Y+2	; 0x02
    310a:	fb 81       	ldd	r31, Y+3	; 0x03
    310c:	15 a2       	std	Z+37, r1	; 0x25
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    310e:	2a 96       	adiw	r28, 0x0a	; 10
    3110:	0f b6       	in	r0, 0x3f	; 63
    3112:	f8 94       	cli
    3114:	de bf       	out	0x3e, r29	; 62
    3116:	0f be       	out	0x3f, r0	; 63
    3118:	cd bf       	out	0x3d, r28	; 61
    311a:	cf 91       	pop	r28
    311c:	df 91       	pop	r29
    311e:	1f 91       	pop	r17
    3120:	0f 91       	pop	r16
    3122:	08 95       	ret

00003124 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3124:	df 93       	push	r29
    3126:	cf 93       	push	r28
    3128:	0f 92       	push	r0
    312a:	cd b7       	in	r28, 0x3d	; 61
    312c:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    312e:	19 82       	std	Y+1, r1	; 0x01
    3130:	13 c0       	rjmp	.+38     	; 0x3158 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3132:	89 81       	ldd	r24, Y+1	; 0x01
    3134:	28 2f       	mov	r18, r24
    3136:	30 e0       	ldi	r19, 0x00	; 0
    3138:	c9 01       	movw	r24, r18
    313a:	88 0f       	add	r24, r24
    313c:	99 1f       	adc	r25, r25
    313e:	88 0f       	add	r24, r24
    3140:	99 1f       	adc	r25, r25
    3142:	88 0f       	add	r24, r24
    3144:	99 1f       	adc	r25, r25
    3146:	82 0f       	add	r24, r18
    3148:	93 1f       	adc	r25, r19
    314a:	8f 59       	subi	r24, 0x9F	; 159
    314c:	9b 4f       	sbci	r25, 0xFB	; 251
    314e:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3152:	89 81       	ldd	r24, Y+1	; 0x01
    3154:	8f 5f       	subi	r24, 0xFF	; 255
    3156:	89 83       	std	Y+1, r24	; 0x01
    3158:	89 81       	ldd	r24, Y+1	; 0x01
    315a:	84 30       	cpi	r24, 0x04	; 4
    315c:	50 f3       	brcs	.-44     	; 0x3132 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    315e:	85 e8       	ldi	r24, 0x85	; 133
    3160:	94 e0       	ldi	r25, 0x04	; 4
    3162:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3166:	8e e8       	ldi	r24, 0x8E	; 142
    3168:	94 e0       	ldi	r25, 0x04	; 4
    316a:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
	vListInitialise( &xPendingReadyList );
    316e:	8b e9       	ldi	r24, 0x9B	; 155
    3170:	94 e0       	ldi	r25, 0x04	; 4
    3172:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3176:	84 ea       	ldi	r24, 0xA4	; 164
    3178:	94 e0       	ldi	r25, 0x04	; 4
    317a:	0e 94 35 08 	call	0x106a	; 0x106a <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    317e:	85 e8       	ldi	r24, 0x85	; 133
    3180:	94 e0       	ldi	r25, 0x04	; 4
    3182:	90 93 98 04 	sts	0x0498, r25
    3186:	80 93 97 04 	sts	0x0497, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    318a:	8e e8       	ldi	r24, 0x8E	; 142
    318c:	94 e0       	ldi	r25, 0x04	; 4
    318e:	90 93 9a 04 	sts	0x049A, r25
    3192:	80 93 99 04 	sts	0x0499, r24
}
    3196:	0f 90       	pop	r0
    3198:	cf 91       	pop	r28
    319a:	df 91       	pop	r29
    319c:	08 95       	ret

0000319e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    319e:	df 93       	push	r29
    31a0:	cf 93       	push	r28
    31a2:	00 d0       	rcall	.+0      	; 0x31a4 <prvCheckTasksWaitingTermination+0x6>
    31a4:	0f 92       	push	r0
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
    31aa:	2e c0       	rjmp	.+92     	; 0x3208 <prvCheckTasksWaitingTermination+0x6a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    31ac:	0e 94 1d 14 	call	0x283a	; 0x283a <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    31b0:	80 91 a4 04 	lds	r24, 0x04A4
    31b4:	1b 82       	std	Y+3, r1	; 0x03
    31b6:	88 23       	and	r24, r24
    31b8:	11 f4       	brne	.+4      	; 0x31be <prvCheckTasksWaitingTermination+0x20>
    31ba:	81 e0       	ldi	r24, 0x01	; 1
    31bc:	8b 83       	std	Y+3, r24	; 0x03
			}
			( void ) xTaskResumeAll();
    31be:	0e 94 29 14 	call	0x2852	; 0x2852 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    31c2:	8b 81       	ldd	r24, Y+3	; 0x03
    31c4:	88 23       	and	r24, r24
    31c6:	01 f5       	brne	.+64     	; 0x3208 <prvCheckTasksWaitingTermination+0x6a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    31c8:	0f b6       	in	r0, 0x3f	; 63
    31ca:	f8 94       	cli
    31cc:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    31ce:	e0 91 a9 04 	lds	r30, 0x04A9
    31d2:	f0 91 aa 04 	lds	r31, 0x04AA
    31d6:	86 81       	ldd	r24, Z+6	; 0x06
    31d8:	97 81       	ldd	r25, Z+7	; 0x07
    31da:	9a 83       	std	Y+2, r25	; 0x02
    31dc:	89 83       	std	Y+1, r24	; 0x01
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    31de:	89 81       	ldd	r24, Y+1	; 0x01
    31e0:	9a 81       	ldd	r25, Y+2	; 0x02
    31e2:	02 96       	adiw	r24, 0x02	; 2
    31e4:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					--uxCurrentNumberOfTasks;
    31e8:	80 91 55 04 	lds	r24, 0x0455
    31ec:	81 50       	subi	r24, 0x01	; 1
    31ee:	80 93 55 04 	sts	0x0455, r24
					--uxTasksDeleted;
    31f2:	80 91 54 04 	lds	r24, 0x0454
    31f6:	81 50       	subi	r24, 0x01	; 1
    31f8:	80 93 54 04 	sts	0x0454, r24
				}
				taskEXIT_CRITICAL();
    31fc:	0f 90       	pop	r0
    31fe:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    3200:	89 81       	ldd	r24, Y+1	; 0x01
    3202:	9a 81       	ldd	r25, Y+2	; 0x02
    3204:	0e 94 9f 19 	call	0x333e	; 0x333e <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    3208:	80 91 54 04 	lds	r24, 0x0454
    320c:	88 23       	and	r24, r24
    320e:	71 f6       	brne	.-100    	; 0x31ac <prvCheckTasksWaitingTermination+0xe>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    3210:	0f 90       	pop	r0
    3212:	0f 90       	pop	r0
    3214:	0f 90       	pop	r0
    3216:	cf 91       	pop	r28
    3218:	df 91       	pop	r29
    321a:	08 95       	ret

0000321c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    321c:	df 93       	push	r29
    321e:	cf 93       	push	r28
    3220:	00 d0       	rcall	.+0      	; 0x3222 <prvAddCurrentTaskToDelayedList+0x6>
    3222:	cd b7       	in	r28, 0x3d	; 61
    3224:	de b7       	in	r29, 0x3e	; 62
    3226:	9a 83       	std	Y+2, r25	; 0x02
    3228:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    322a:	e0 91 52 04 	lds	r30, 0x0452
    322e:	f0 91 53 04 	lds	r31, 0x0453
    3232:	89 81       	ldd	r24, Y+1	; 0x01
    3234:	9a 81       	ldd	r25, Y+2	; 0x02
    3236:	93 83       	std	Z+3, r25	; 0x03
    3238:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    323a:	20 91 56 04 	lds	r18, 0x0456
    323e:	30 91 57 04 	lds	r19, 0x0457
    3242:	89 81       	ldd	r24, Y+1	; 0x01
    3244:	9a 81       	ldd	r25, Y+2	; 0x02
    3246:	82 17       	cp	r24, r18
    3248:	93 07       	cpc	r25, r19
    324a:	70 f4       	brcc	.+28     	; 0x3268 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    324c:	80 91 99 04 	lds	r24, 0x0499
    3250:	90 91 9a 04 	lds	r25, 0x049A
    3254:	20 91 52 04 	lds	r18, 0x0452
    3258:	30 91 53 04 	lds	r19, 0x0453
    325c:	2e 5f       	subi	r18, 0xFE	; 254
    325e:	3f 4f       	sbci	r19, 0xFF	; 255
    3260:	b9 01       	movw	r22, r18
    3262:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInsert>
    3266:	1e c0       	rjmp	.+60     	; 0x32a4 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3268:	40 91 97 04 	lds	r20, 0x0497
    326c:	50 91 98 04 	lds	r21, 0x0498
    3270:	80 91 52 04 	lds	r24, 0x0452
    3274:	90 91 53 04 	lds	r25, 0x0453
    3278:	9c 01       	movw	r18, r24
    327a:	2e 5f       	subi	r18, 0xFE	; 254
    327c:	3f 4f       	sbci	r19, 0xFF	; 255
    327e:	ca 01       	movw	r24, r20
    3280:	b9 01       	movw	r22, r18
    3282:	0e 94 b3 08 	call	0x1166	; 0x1166 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3286:	20 91 5e 04 	lds	r18, 0x045E
    328a:	30 91 5f 04 	lds	r19, 0x045F
    328e:	89 81       	ldd	r24, Y+1	; 0x01
    3290:	9a 81       	ldd	r25, Y+2	; 0x02
    3292:	82 17       	cp	r24, r18
    3294:	93 07       	cpc	r25, r19
    3296:	30 f4       	brcc	.+12     	; 0x32a4 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3298:	89 81       	ldd	r24, Y+1	; 0x01
    329a:	9a 81       	ldd	r25, Y+2	; 0x02
    329c:	90 93 5f 04 	sts	0x045F, r25
    32a0:	80 93 5e 04 	sts	0x045E, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    32a4:	0f 90       	pop	r0
    32a6:	0f 90       	pop	r0
    32a8:	cf 91       	pop	r28
    32aa:	df 91       	pop	r29
    32ac:	08 95       	ret

000032ae <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    32ae:	df 93       	push	r29
    32b0:	cf 93       	push	r28
    32b2:	cd b7       	in	r28, 0x3d	; 61
    32b4:	de b7       	in	r29, 0x3e	; 62
    32b6:	2a 97       	sbiw	r28, 0x0a	; 10
    32b8:	0f b6       	in	r0, 0x3f	; 63
    32ba:	f8 94       	cli
    32bc:	de bf       	out	0x3e, r29	; 62
    32be:	0f be       	out	0x3f, r0	; 63
    32c0:	cd bf       	out	0x3d, r28	; 61
    32c2:	9e 83       	std	Y+6, r25	; 0x06
    32c4:	8d 83       	std	Y+5, r24	; 0x05
    32c6:	78 87       	std	Y+8, r23	; 0x08
    32c8:	6f 83       	std	Y+7, r22	; 0x07
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    32ca:	8f 81       	ldd	r24, Y+7	; 0x07
    32cc:	98 85       	ldd	r25, Y+8	; 0x08
    32ce:	00 97       	sbiw	r24, 0x00	; 0
    32d0:	39 f4       	brne	.+14     	; 0x32e0 <prvAllocateTCBAndStack+0x32>
    32d2:	8d 81       	ldd	r24, Y+5	; 0x05
    32d4:	9e 81       	ldd	r25, Y+6	; 0x06
    32d6:	0e 94 a3 05 	call	0xb46	; 0xb46 <pvPortMalloc>
    32da:	9a 87       	std	Y+10, r25	; 0x0a
    32dc:	89 87       	std	Y+9, r24	; 0x09
    32de:	04 c0       	rjmp	.+8      	; 0x32e8 <prvAllocateTCBAndStack+0x3a>
    32e0:	8f 81       	ldd	r24, Y+7	; 0x07
    32e2:	98 85       	ldd	r25, Y+8	; 0x08
    32e4:	9a 87       	std	Y+10, r25	; 0x0a
    32e6:	89 87       	std	Y+9, r24	; 0x09
    32e8:	89 85       	ldd	r24, Y+9	; 0x09
    32ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    32ec:	9a 83       	std	Y+2, r25	; 0x02
    32ee:	89 83       	std	Y+1, r24	; 0x01

		if( pxStack != NULL )
    32f0:	89 81       	ldd	r24, Y+1	; 0x01
    32f2:	9a 81       	ldd	r25, Y+2	; 0x02
    32f4:	00 97       	sbiw	r24, 0x00	; 0
    32f6:	b1 f0       	breq	.+44     	; 0x3324 <prvAllocateTCBAndStack+0x76>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    32f8:	86 e2       	ldi	r24, 0x26	; 38
    32fa:	90 e0       	ldi	r25, 0x00	; 0
    32fc:	0e 94 a3 05 	call	0xb46	; 0xb46 <pvPortMalloc>
    3300:	9c 83       	std	Y+4, r25	; 0x04
    3302:	8b 83       	std	Y+3, r24	; 0x03

			if( pxNewTCB != NULL )
    3304:	8b 81       	ldd	r24, Y+3	; 0x03
    3306:	9c 81       	ldd	r25, Y+4	; 0x04
    3308:	00 97       	sbiw	r24, 0x00	; 0
    330a:	39 f0       	breq	.+14     	; 0x331a <prvAllocateTCBAndStack+0x6c>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
    330c:	eb 81       	ldd	r30, Y+3	; 0x03
    330e:	fc 81       	ldd	r31, Y+4	; 0x04
    3310:	89 81       	ldd	r24, Y+1	; 0x01
    3312:	9a 81       	ldd	r25, Y+2	; 0x02
    3314:	90 8f       	std	Z+24, r25	; 0x18
    3316:	87 8b       	std	Z+23, r24	; 0x17
    3318:	07 c0       	rjmp	.+14     	; 0x3328 <prvAllocateTCBAndStack+0x7a>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
    331a:	89 81       	ldd	r24, Y+1	; 0x01
    331c:	9a 81       	ldd	r25, Y+2	; 0x02
    331e:	0e 94 98 06 	call	0xd30	; 0xd30 <vPortFree>
    3322:	02 c0       	rjmp	.+4      	; 0x3328 <prvAllocateTCBAndStack+0x7a>
			}
		}
		else
		{
			pxNewTCB = NULL;
    3324:	1c 82       	std	Y+4, r1	; 0x04
    3326:	1b 82       	std	Y+3, r1	; 0x03
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
		}
		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
	}

	return pxNewTCB;
    3328:	8b 81       	ldd	r24, Y+3	; 0x03
    332a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    332c:	2a 96       	adiw	r28, 0x0a	; 10
    332e:	0f b6       	in	r0, 0x3f	; 63
    3330:	f8 94       	cli
    3332:	de bf       	out	0x3e, r29	; 62
    3334:	0f be       	out	0x3f, r0	; 63
    3336:	cd bf       	out	0x3d, r28	; 61
    3338:	cf 91       	pop	r28
    333a:	df 91       	pop	r29
    333c:	08 95       	ret

0000333e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    333e:	df 93       	push	r29
    3340:	cf 93       	push	r28
    3342:	00 d0       	rcall	.+0      	; 0x3344 <prvDeleteTCB+0x6>
    3344:	cd b7       	in	r28, 0x3d	; 61
    3346:	de b7       	in	r29, 0x3e	; 62
    3348:	9a 83       	std	Y+2, r25	; 0x02
    334a:	89 83       	std	Y+1, r24	; 0x01
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    334c:	e9 81       	ldd	r30, Y+1	; 0x01
    334e:	fa 81       	ldd	r31, Y+2	; 0x02
    3350:	87 89       	ldd	r24, Z+23	; 0x17
    3352:	90 8d       	ldd	r25, Z+24	; 0x18
    3354:	0e 94 98 06 	call	0xd30	; 0xd30 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    3358:	89 81       	ldd	r24, Y+1	; 0x01
    335a:	9a 81       	ldd	r25, Y+2	; 0x02
    335c:	0e 94 98 06 	call	0xd30	; 0xd30 <vPortFree>
	}
    3360:	0f 90       	pop	r0
    3362:	0f 90       	pop	r0
    3364:	cf 91       	pop	r28
    3366:	df 91       	pop	r29
    3368:	08 95       	ret

0000336a <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    336a:	df 93       	push	r29
    336c:	cf 93       	push	r28
    336e:	00 d0       	rcall	.+0      	; 0x3370 <prvResetNextTaskUnblockTime+0x6>
    3370:	cd b7       	in	r28, 0x3d	; 61
    3372:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3374:	e0 91 97 04 	lds	r30, 0x0497
    3378:	f0 91 98 04 	lds	r31, 0x0498
    337c:	80 81       	ld	r24, Z
    337e:	88 23       	and	r24, r24
    3380:	39 f4       	brne	.+14     	; 0x3390 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3382:	8f ef       	ldi	r24, 0xFF	; 255
    3384:	9f ef       	ldi	r25, 0xFF	; 255
    3386:	90 93 5f 04 	sts	0x045F, r25
    338a:	80 93 5e 04 	sts	0x045E, r24
    338e:	13 c0       	rjmp	.+38     	; 0x33b6 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3390:	e0 91 97 04 	lds	r30, 0x0497
    3394:	f0 91 98 04 	lds	r31, 0x0498
    3398:	05 80       	ldd	r0, Z+5	; 0x05
    339a:	f6 81       	ldd	r31, Z+6	; 0x06
    339c:	e0 2d       	mov	r30, r0
    339e:	86 81       	ldd	r24, Z+6	; 0x06
    33a0:	97 81       	ldd	r25, Z+7	; 0x07
    33a2:	9a 83       	std	Y+2, r25	; 0x02
    33a4:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    33a6:	e9 81       	ldd	r30, Y+1	; 0x01
    33a8:	fa 81       	ldd	r31, Y+2	; 0x02
    33aa:	82 81       	ldd	r24, Z+2	; 0x02
    33ac:	93 81       	ldd	r25, Z+3	; 0x03
    33ae:	90 93 5f 04 	sts	0x045F, r25
    33b2:	80 93 5e 04 	sts	0x045E, r24
	}
}
    33b6:	0f 90       	pop	r0
    33b8:	0f 90       	pop	r0
    33ba:	cf 91       	pop	r28
    33bc:	df 91       	pop	r29
    33be:	08 95       	ret

000033c0 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    33c0:	df 93       	push	r29
    33c2:	cf 93       	push	r28
    33c4:	00 d0       	rcall	.+0      	; 0x33c6 <uxTaskResetEventItemValue+0x6>
    33c6:	cd b7       	in	r28, 0x3d	; 61
    33c8:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    33ca:	e0 91 52 04 	lds	r30, 0x0452
    33ce:	f0 91 53 04 	lds	r31, 0x0453
    33d2:	84 85       	ldd	r24, Z+12	; 0x0c
    33d4:	95 85       	ldd	r25, Z+13	; 0x0d
    33d6:	9a 83       	std	Y+2, r25	; 0x02
    33d8:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    33da:	a0 91 52 04 	lds	r26, 0x0452
    33de:	b0 91 53 04 	lds	r27, 0x0453
    33e2:	e0 91 52 04 	lds	r30, 0x0452
    33e6:	f0 91 53 04 	lds	r31, 0x0453
    33ea:	86 89       	ldd	r24, Z+22	; 0x16
    33ec:	28 2f       	mov	r18, r24
    33ee:	30 e0       	ldi	r19, 0x00	; 0
    33f0:	84 e0       	ldi	r24, 0x04	; 4
    33f2:	90 e0       	ldi	r25, 0x00	; 0
    33f4:	82 1b       	sub	r24, r18
    33f6:	93 0b       	sbc	r25, r19
    33f8:	1d 96       	adiw	r26, 0x0d	; 13
    33fa:	9c 93       	st	X, r25
    33fc:	8e 93       	st	-X, r24
    33fe:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    3400:	89 81       	ldd	r24, Y+1	; 0x01
    3402:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3404:	0f 90       	pop	r0
    3406:	0f 90       	pop	r0
    3408:	cf 91       	pop	r28
    340a:	df 91       	pop	r29
    340c:	08 95       	ret

0000340e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    340e:	df 93       	push	r29
    3410:	cf 93       	push	r28
    3412:	cd b7       	in	r28, 0x3d	; 61
    3414:	de b7       	in	r29, 0x3e	; 62
    3416:	29 97       	sbiw	r28, 0x09	; 9
    3418:	0f b6       	in	r0, 0x3f	; 63
    341a:	f8 94       	cli
    341c:	de bf       	out	0x3e, r29	; 62
    341e:	0f be       	out	0x3f, r0	; 63
    3420:	cd bf       	out	0x3d, r28	; 61
    3422:	8f 83       	std	Y+7, r24	; 0x07
    3424:	79 87       	std	Y+9, r23	; 0x09
    3426:	68 87       	std	Y+8, r22	; 0x08
	TickType_t xTimeToWake;
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    3428:	0f b6       	in	r0, 0x3f	; 63
    342a:	f8 94       	cli
    342c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    342e:	e0 91 52 04 	lds	r30, 0x0452
    3432:	f0 91 53 04 	lds	r31, 0x0453
    3436:	81 a1       	ldd	r24, Z+33	; 0x21
    3438:	92 a1       	ldd	r25, Z+34	; 0x22
    343a:	a3 a1       	ldd	r26, Z+35	; 0x23
    343c:	b4 a1       	ldd	r27, Z+36	; 0x24
    343e:	00 97       	sbiw	r24, 0x00	; 0
    3440:	a1 05       	cpc	r26, r1
    3442:	b1 05       	cpc	r27, r1
    3444:	09 f5       	brne	.+66     	; 0x3488 <ulTaskNotifyTake+0x7a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    3446:	e0 91 52 04 	lds	r30, 0x0452
    344a:	f0 91 53 04 	lds	r31, 0x0453
    344e:	81 e0       	ldi	r24, 0x01	; 1
    3450:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    3452:	88 85       	ldd	r24, Y+8	; 0x08
    3454:	99 85       	ldd	r25, Y+9	; 0x09
    3456:	00 97       	sbiw	r24, 0x00	; 0
    3458:	b9 f0       	breq	.+46     	; 0x3488 <ulTaskNotifyTake+0x7a>
				{
					/* The task is going to block.  First it must be removed
					from the ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    345a:	80 91 52 04 	lds	r24, 0x0452
    345e:	90 91 53 04 	lds	r25, 0x0453
    3462:	02 96       	adiw	r24, 0x02	; 2
    3464:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    3468:	20 91 56 04 	lds	r18, 0x0456
    346c:	30 91 57 04 	lds	r19, 0x0457
    3470:	88 85       	ldd	r24, Y+8	; 0x08
    3472:	99 85       	ldd	r25, Y+9	; 0x09
    3474:	82 0f       	add	r24, r18
    3476:	93 1f       	adc	r25, r19
    3478:	9e 83       	std	Y+6, r25	; 0x06
    347a:	8d 83       	std	Y+5, r24	; 0x05
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    347c:	8d 81       	ldd	r24, Y+5	; 0x05
    347e:	9e 81       	ldd	r25, Y+6	; 0x06
    3480:	0e 94 0e 19 	call	0x321c	; 0x321c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3484:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3488:	0f 90       	pop	r0
    348a:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    348c:	0f b6       	in	r0, 0x3f	; 63
    348e:	f8 94       	cli
    3490:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    3492:	e0 91 52 04 	lds	r30, 0x0452
    3496:	f0 91 53 04 	lds	r31, 0x0453
    349a:	81 a1       	ldd	r24, Z+33	; 0x21
    349c:	92 a1       	ldd	r25, Z+34	; 0x22
    349e:	a3 a1       	ldd	r26, Z+35	; 0x23
    34a0:	b4 a1       	ldd	r27, Z+36	; 0x24
    34a2:	89 83       	std	Y+1, r24	; 0x01
    34a4:	9a 83       	std	Y+2, r25	; 0x02
    34a6:	ab 83       	std	Y+3, r26	; 0x03
    34a8:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    34aa:	89 81       	ldd	r24, Y+1	; 0x01
    34ac:	9a 81       	ldd	r25, Y+2	; 0x02
    34ae:	ab 81       	ldd	r26, Y+3	; 0x03
    34b0:	bc 81       	ldd	r27, Y+4	; 0x04
    34b2:	00 97       	sbiw	r24, 0x00	; 0
    34b4:	a1 05       	cpc	r26, r1
    34b6:	b1 05       	cpc	r27, r1
    34b8:	d9 f0       	breq	.+54     	; 0x34f0 <ulTaskNotifyTake+0xe2>
			{
				if( xClearCountOnExit != pdFALSE )
    34ba:	8f 81       	ldd	r24, Y+7	; 0x07
    34bc:	88 23       	and	r24, r24
    34be:	49 f0       	breq	.+18     	; 0x34d2 <ulTaskNotifyTake+0xc4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    34c0:	e0 91 52 04 	lds	r30, 0x0452
    34c4:	f0 91 53 04 	lds	r31, 0x0453
    34c8:	11 a2       	std	Z+33, r1	; 0x21
    34ca:	12 a2       	std	Z+34, r1	; 0x22
    34cc:	13 a2       	std	Z+35, r1	; 0x23
    34ce:	14 a2       	std	Z+36, r1	; 0x24
    34d0:	0f c0       	rjmp	.+30     	; 0x34f0 <ulTaskNotifyTake+0xe2>
				}
				else
				{
					( pxCurrentTCB->ulNotifiedValue )--;
    34d2:	e0 91 52 04 	lds	r30, 0x0452
    34d6:	f0 91 53 04 	lds	r31, 0x0453
    34da:	81 a1       	ldd	r24, Z+33	; 0x21
    34dc:	92 a1       	ldd	r25, Z+34	; 0x22
    34de:	a3 a1       	ldd	r26, Z+35	; 0x23
    34e0:	b4 a1       	ldd	r27, Z+36	; 0x24
    34e2:	01 97       	sbiw	r24, 0x01	; 1
    34e4:	a1 09       	sbc	r26, r1
    34e6:	b1 09       	sbc	r27, r1
    34e8:	81 a3       	std	Z+33, r24	; 0x21
    34ea:	92 a3       	std	Z+34, r25	; 0x22
    34ec:	a3 a3       	std	Z+35, r26	; 0x23
    34ee:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    34f0:	e0 91 52 04 	lds	r30, 0x0452
    34f4:	f0 91 53 04 	lds	r31, 0x0453
    34f8:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    34fa:	0f 90       	pop	r0
    34fc:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    34fe:	89 81       	ldd	r24, Y+1	; 0x01
    3500:	9a 81       	ldd	r25, Y+2	; 0x02
    3502:	ab 81       	ldd	r26, Y+3	; 0x03
    3504:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    3506:	bc 01       	movw	r22, r24
    3508:	cd 01       	movw	r24, r26
    350a:	29 96       	adiw	r28, 0x09	; 9
    350c:	0f b6       	in	r0, 0x3f	; 63
    350e:	f8 94       	cli
    3510:	de bf       	out	0x3e, r29	; 62
    3512:	0f be       	out	0x3f, r0	; 63
    3514:	cd bf       	out	0x3d, r28	; 61
    3516:	cf 91       	pop	r28
    3518:	df 91       	pop	r29
    351a:	08 95       	ret

0000351c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    351c:	ef 92       	push	r14
    351e:	ff 92       	push	r15
    3520:	0f 93       	push	r16
    3522:	1f 93       	push	r17
    3524:	df 93       	push	r29
    3526:	cf 93       	push	r28
    3528:	cd b7       	in	r28, 0x3d	; 61
    352a:	de b7       	in	r29, 0x3e	; 62
    352c:	2f 97       	sbiw	r28, 0x0f	; 15
    352e:	0f b6       	in	r0, 0x3f	; 63
    3530:	f8 94       	cli
    3532:	de bf       	out	0x3e, r29	; 62
    3534:	0f be       	out	0x3f, r0	; 63
    3536:	cd bf       	out	0x3d, r28	; 61
    3538:	6c 83       	std	Y+4, r22	; 0x04
    353a:	7d 83       	std	Y+5, r23	; 0x05
    353c:	8e 83       	std	Y+6, r24	; 0x06
    353e:	9f 83       	std	Y+7, r25	; 0x07
    3540:	28 87       	std	Y+8, r18	; 0x08
    3542:	39 87       	std	Y+9, r19	; 0x09
    3544:	4a 87       	std	Y+10, r20	; 0x0a
    3546:	5b 87       	std	Y+11, r21	; 0x0b
    3548:	1d 87       	std	Y+13, r17	; 0x0d
    354a:	0c 87       	std	Y+12, r16	; 0x0c
    354c:	ff 86       	std	Y+15, r15	; 0x0f
    354e:	ee 86       	std	Y+14, r14	; 0x0e
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    3550:	0f b6       	in	r0, 0x3f	; 63
    3552:	f8 94       	cli
    3554:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    3556:	e0 91 52 04 	lds	r30, 0x0452
    355a:	f0 91 53 04 	lds	r31, 0x0453
    355e:	85 a1       	ldd	r24, Z+37	; 0x25
    3560:	82 30       	cpi	r24, 0x02	; 2
    3562:	c9 f1       	breq	.+114    	; 0x35d6 <xTaskNotifyWait+0xba>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    3564:	e0 91 52 04 	lds	r30, 0x0452
    3568:	f0 91 53 04 	lds	r31, 0x0453
    356c:	21 a1       	ldd	r18, Z+33	; 0x21
    356e:	32 a1       	ldd	r19, Z+34	; 0x22
    3570:	43 a1       	ldd	r20, Z+35	; 0x23
    3572:	54 a1       	ldd	r21, Z+36	; 0x24
    3574:	8c 81       	ldd	r24, Y+4	; 0x04
    3576:	9d 81       	ldd	r25, Y+5	; 0x05
    3578:	ae 81       	ldd	r26, Y+6	; 0x06
    357a:	bf 81       	ldd	r27, Y+7	; 0x07
    357c:	80 95       	com	r24
    357e:	90 95       	com	r25
    3580:	a0 95       	com	r26
    3582:	b0 95       	com	r27
    3584:	82 23       	and	r24, r18
    3586:	93 23       	and	r25, r19
    3588:	a4 23       	and	r26, r20
    358a:	b5 23       	and	r27, r21
    358c:	81 a3       	std	Z+33, r24	; 0x21
    358e:	92 a3       	std	Z+34, r25	; 0x22
    3590:	a3 a3       	std	Z+35, r26	; 0x23
    3592:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    3594:	e0 91 52 04 	lds	r30, 0x0452
    3598:	f0 91 53 04 	lds	r31, 0x0453
    359c:	81 e0       	ldi	r24, 0x01	; 1
    359e:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    35a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    35a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    35a4:	00 97       	sbiw	r24, 0x00	; 0
    35a6:	b9 f0       	breq	.+46     	; 0x35d6 <xTaskNotifyWait+0xba>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    35a8:	80 91 52 04 	lds	r24, 0x0452
    35ac:	90 91 53 04 	lds	r25, 0x0453
    35b0:	02 96       	adiw	r24, 0x02	; 2
    35b2:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					{
							/* Calculate the time at which the task should be
							woken if the event does not occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    35b6:	20 91 56 04 	lds	r18, 0x0456
    35ba:	30 91 57 04 	lds	r19, 0x0457
    35be:	8e 85       	ldd	r24, Y+14	; 0x0e
    35c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    35c2:	82 0f       	add	r24, r18
    35c4:	93 1f       	adc	r25, r19
    35c6:	9b 83       	std	Y+3, r25	; 0x03
    35c8:	8a 83       	std	Y+2, r24	; 0x02
							prvAddCurrentTaskToDelayedList( xTimeToWake );
    35ca:	8a 81       	ldd	r24, Y+2	; 0x02
    35cc:	9b 81       	ldd	r25, Y+3	; 0x03
    35ce:	0e 94 0e 19 	call	0x321c	; 0x321c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    35d2:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    35d6:	0f 90       	pop	r0
    35d8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    35da:	0f b6       	in	r0, 0x3f	; 63
    35dc:	f8 94       	cli
    35de:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    35e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    35e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    35e4:	00 97       	sbiw	r24, 0x00	; 0
    35e6:	71 f0       	breq	.+28     	; 0x3604 <xTaskNotifyWait+0xe8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    35e8:	e0 91 52 04 	lds	r30, 0x0452
    35ec:	f0 91 53 04 	lds	r31, 0x0453
    35f0:	81 a1       	ldd	r24, Z+33	; 0x21
    35f2:	92 a1       	ldd	r25, Z+34	; 0x22
    35f4:	a3 a1       	ldd	r26, Z+35	; 0x23
    35f6:	b4 a1       	ldd	r27, Z+36	; 0x24
    35f8:	ec 85       	ldd	r30, Y+12	; 0x0c
    35fa:	fd 85       	ldd	r31, Y+13	; 0x0d
    35fc:	80 83       	st	Z, r24
    35fe:	91 83       	std	Z+1, r25	; 0x01
    3600:	a2 83       	std	Z+2, r26	; 0x02
    3602:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    3604:	e0 91 52 04 	lds	r30, 0x0452
    3608:	f0 91 53 04 	lds	r31, 0x0453
    360c:	85 a1       	ldd	r24, Z+37	; 0x25
    360e:	81 30       	cpi	r24, 0x01	; 1
    3610:	11 f4       	brne	.+4      	; 0x3616 <xTaskNotifyWait+0xfa>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3612:	19 82       	std	Y+1, r1	; 0x01
    3614:	1a c0       	rjmp	.+52     	; 0x364a <xTaskNotifyWait+0x12e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    3616:	e0 91 52 04 	lds	r30, 0x0452
    361a:	f0 91 53 04 	lds	r31, 0x0453
    361e:	21 a1       	ldd	r18, Z+33	; 0x21
    3620:	32 a1       	ldd	r19, Z+34	; 0x22
    3622:	43 a1       	ldd	r20, Z+35	; 0x23
    3624:	54 a1       	ldd	r21, Z+36	; 0x24
    3626:	88 85       	ldd	r24, Y+8	; 0x08
    3628:	99 85       	ldd	r25, Y+9	; 0x09
    362a:	aa 85       	ldd	r26, Y+10	; 0x0a
    362c:	bb 85       	ldd	r27, Y+11	; 0x0b
    362e:	80 95       	com	r24
    3630:	90 95       	com	r25
    3632:	a0 95       	com	r26
    3634:	b0 95       	com	r27
    3636:	82 23       	and	r24, r18
    3638:	93 23       	and	r25, r19
    363a:	a4 23       	and	r26, r20
    363c:	b5 23       	and	r27, r21
    363e:	81 a3       	std	Z+33, r24	; 0x21
    3640:	92 a3       	std	Z+34, r25	; 0x22
    3642:	a3 a3       	std	Z+35, r26	; 0x23
    3644:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    3646:	81 e0       	ldi	r24, 0x01	; 1
    3648:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    364a:	e0 91 52 04 	lds	r30, 0x0452
    364e:	f0 91 53 04 	lds	r31, 0x0453
    3652:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    3654:	0f 90       	pop	r0
    3656:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3658:	89 81       	ldd	r24, Y+1	; 0x01
	}
    365a:	2f 96       	adiw	r28, 0x0f	; 15
    365c:	0f b6       	in	r0, 0x3f	; 63
    365e:	f8 94       	cli
    3660:	de bf       	out	0x3e, r29	; 62
    3662:	0f be       	out	0x3f, r0	; 63
    3664:	cd bf       	out	0x3d, r28	; 61
    3666:	cf 91       	pop	r28
    3668:	df 91       	pop	r29
    366a:	1f 91       	pop	r17
    366c:	0f 91       	pop	r16
    366e:	ff 90       	pop	r15
    3670:	ef 90       	pop	r14
    3672:	08 95       	ret

00003674 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3674:	0f 93       	push	r16
    3676:	1f 93       	push	r17
    3678:	df 93       	push	r29
    367a:	cf 93       	push	r28
    367c:	cd b7       	in	r28, 0x3d	; 61
    367e:	de b7       	in	r29, 0x3e	; 62
    3680:	2f 97       	sbiw	r28, 0x0f	; 15
    3682:	0f b6       	in	r0, 0x3f	; 63
    3684:	f8 94       	cli
    3686:	de bf       	out	0x3e, r29	; 62
    3688:	0f be       	out	0x3f, r0	; 63
    368a:	cd bf       	out	0x3d, r28	; 61
    368c:	9e 83       	std	Y+6, r25	; 0x06
    368e:	8d 83       	std	Y+5, r24	; 0x05
    3690:	4f 83       	std	Y+7, r20	; 0x07
    3692:	58 87       	std	Y+8, r21	; 0x08
    3694:	69 87       	std	Y+9, r22	; 0x09
    3696:	7a 87       	std	Y+10, r23	; 0x0a
    3698:	2b 87       	std	Y+11, r18	; 0x0b
    369a:	1d 87       	std	Y+13, r17	; 0x0d
    369c:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    369e:	81 e0       	ldi	r24, 0x01	; 1
    36a0:	89 83       	std	Y+1, r24	; 0x01

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
    36a2:	8d 81       	ldd	r24, Y+5	; 0x05
    36a4:	9e 81       	ldd	r25, Y+6	; 0x06
    36a6:	9c 83       	std	Y+4, r25	; 0x04
    36a8:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    36aa:	0f b6       	in	r0, 0x3f	; 63
    36ac:	f8 94       	cli
    36ae:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    36b0:	8c 85       	ldd	r24, Y+12	; 0x0c
    36b2:	9d 85       	ldd	r25, Y+13	; 0x0d
    36b4:	00 97       	sbiw	r24, 0x00	; 0
    36b6:	61 f0       	breq	.+24     	; 0x36d0 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    36b8:	eb 81       	ldd	r30, Y+3	; 0x03
    36ba:	fc 81       	ldd	r31, Y+4	; 0x04
    36bc:	81 a1       	ldd	r24, Z+33	; 0x21
    36be:	92 a1       	ldd	r25, Z+34	; 0x22
    36c0:	a3 a1       	ldd	r26, Z+35	; 0x23
    36c2:	b4 a1       	ldd	r27, Z+36	; 0x24
    36c4:	ec 85       	ldd	r30, Y+12	; 0x0c
    36c6:	fd 85       	ldd	r31, Y+13	; 0x0d
    36c8:	80 83       	st	Z, r24
    36ca:	91 83       	std	Z+1, r25	; 0x01
    36cc:	a2 83       	std	Z+2, r26	; 0x02
    36ce:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    36d0:	eb 81       	ldd	r30, Y+3	; 0x03
    36d2:	fc 81       	ldd	r31, Y+4	; 0x04
    36d4:	85 a1       	ldd	r24, Z+37	; 0x25
    36d6:	8a 83       	std	Y+2, r24	; 0x02

			pxTCB->eNotifyState = eNotified;
    36d8:	eb 81       	ldd	r30, Y+3	; 0x03
    36da:	fc 81       	ldd	r31, Y+4	; 0x04
    36dc:	82 e0       	ldi	r24, 0x02	; 2
    36de:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    36e0:	8b 85       	ldd	r24, Y+11	; 0x0b
    36e2:	28 2f       	mov	r18, r24
    36e4:	30 e0       	ldi	r19, 0x00	; 0
    36e6:	3f 87       	std	Y+15, r19	; 0x0f
    36e8:	2e 87       	std	Y+14, r18	; 0x0e
    36ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    36ec:	9f 85       	ldd	r25, Y+15	; 0x0f
    36ee:	82 30       	cpi	r24, 0x02	; 2
    36f0:	91 05       	cpc	r25, r1
    36f2:	59 f1       	breq	.+86     	; 0x374a <xTaskGenericNotify+0xd6>
    36f4:	2e 85       	ldd	r18, Y+14	; 0x0e
    36f6:	3f 85       	ldd	r19, Y+15	; 0x0f
    36f8:	23 30       	cpi	r18, 0x03	; 3
    36fa:	31 05       	cpc	r19, r1
    36fc:	34 f4       	brge	.+12     	; 0x370a <xTaskGenericNotify+0x96>
    36fe:	8e 85       	ldd	r24, Y+14	; 0x0e
    3700:	9f 85       	ldd	r25, Y+15	; 0x0f
    3702:	81 30       	cpi	r24, 0x01	; 1
    3704:	91 05       	cpc	r25, r1
    3706:	61 f0       	breq	.+24     	; 0x3720 <xTaskGenericNotify+0xac>
    3708:	4a c0       	rjmp	.+148    	; 0x379e <xTaskGenericNotify+0x12a>
    370a:	2e 85       	ldd	r18, Y+14	; 0x0e
    370c:	3f 85       	ldd	r19, Y+15	; 0x0f
    370e:	23 30       	cpi	r18, 0x03	; 3
    3710:	31 05       	cpc	r19, r1
    3712:	59 f1       	breq	.+86     	; 0x376a <xTaskGenericNotify+0xf6>
    3714:	8e 85       	ldd	r24, Y+14	; 0x0e
    3716:	9f 85       	ldd	r25, Y+15	; 0x0f
    3718:	84 30       	cpi	r24, 0x04	; 4
    371a:	91 05       	cpc	r25, r1
    371c:	89 f1       	breq	.+98     	; 0x3780 <xTaskGenericNotify+0x10c>
    371e:	3f c0       	rjmp	.+126    	; 0x379e <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3720:	eb 81       	ldd	r30, Y+3	; 0x03
    3722:	fc 81       	ldd	r31, Y+4	; 0x04
    3724:	21 a1       	ldd	r18, Z+33	; 0x21
    3726:	32 a1       	ldd	r19, Z+34	; 0x22
    3728:	43 a1       	ldd	r20, Z+35	; 0x23
    372a:	54 a1       	ldd	r21, Z+36	; 0x24
    372c:	8f 81       	ldd	r24, Y+7	; 0x07
    372e:	98 85       	ldd	r25, Y+8	; 0x08
    3730:	a9 85       	ldd	r26, Y+9	; 0x09
    3732:	ba 85       	ldd	r27, Y+10	; 0x0a
    3734:	82 2b       	or	r24, r18
    3736:	93 2b       	or	r25, r19
    3738:	a4 2b       	or	r26, r20
    373a:	b5 2b       	or	r27, r21
    373c:	eb 81       	ldd	r30, Y+3	; 0x03
    373e:	fc 81       	ldd	r31, Y+4	; 0x04
    3740:	81 a3       	std	Z+33, r24	; 0x21
    3742:	92 a3       	std	Z+34, r25	; 0x22
    3744:	a3 a3       	std	Z+35, r26	; 0x23
    3746:	b4 a3       	std	Z+36, r27	; 0x24
    3748:	2a c0       	rjmp	.+84     	; 0x379e <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    374a:	eb 81       	ldd	r30, Y+3	; 0x03
    374c:	fc 81       	ldd	r31, Y+4	; 0x04
    374e:	81 a1       	ldd	r24, Z+33	; 0x21
    3750:	92 a1       	ldd	r25, Z+34	; 0x22
    3752:	a3 a1       	ldd	r26, Z+35	; 0x23
    3754:	b4 a1       	ldd	r27, Z+36	; 0x24
    3756:	01 96       	adiw	r24, 0x01	; 1
    3758:	a1 1d       	adc	r26, r1
    375a:	b1 1d       	adc	r27, r1
    375c:	eb 81       	ldd	r30, Y+3	; 0x03
    375e:	fc 81       	ldd	r31, Y+4	; 0x04
    3760:	81 a3       	std	Z+33, r24	; 0x21
    3762:	92 a3       	std	Z+34, r25	; 0x22
    3764:	a3 a3       	std	Z+35, r26	; 0x23
    3766:	b4 a3       	std	Z+36, r27	; 0x24
    3768:	1a c0       	rjmp	.+52     	; 0x379e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    376a:	eb 81       	ldd	r30, Y+3	; 0x03
    376c:	fc 81       	ldd	r31, Y+4	; 0x04
    376e:	8f 81       	ldd	r24, Y+7	; 0x07
    3770:	98 85       	ldd	r25, Y+8	; 0x08
    3772:	a9 85       	ldd	r26, Y+9	; 0x09
    3774:	ba 85       	ldd	r27, Y+10	; 0x0a
    3776:	81 a3       	std	Z+33, r24	; 0x21
    3778:	92 a3       	std	Z+34, r25	; 0x22
    377a:	a3 a3       	std	Z+35, r26	; 0x23
    377c:	b4 a3       	std	Z+36, r27	; 0x24
    377e:	0f c0       	rjmp	.+30     	; 0x379e <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    3780:	8a 81       	ldd	r24, Y+2	; 0x02
    3782:	82 30       	cpi	r24, 0x02	; 2
    3784:	59 f0       	breq	.+22     	; 0x379c <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3786:	eb 81       	ldd	r30, Y+3	; 0x03
    3788:	fc 81       	ldd	r31, Y+4	; 0x04
    378a:	8f 81       	ldd	r24, Y+7	; 0x07
    378c:	98 85       	ldd	r25, Y+8	; 0x08
    378e:	a9 85       	ldd	r26, Y+9	; 0x09
    3790:	ba 85       	ldd	r27, Y+10	; 0x0a
    3792:	81 a3       	std	Z+33, r24	; 0x21
    3794:	92 a3       	std	Z+34, r25	; 0x22
    3796:	a3 a3       	std	Z+35, r26	; 0x23
    3798:	b4 a3       	std	Z+36, r27	; 0x24
    379a:	01 c0       	rjmp	.+2      	; 0x379e <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    379c:	19 82       	std	Y+1, r1	; 0x01

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    379e:	8a 81       	ldd	r24, Y+2	; 0x02
    37a0:	81 30       	cpi	r24, 0x01	; 1
    37a2:	b9 f5       	brne	.+110    	; 0x3812 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    37a4:	8b 81       	ldd	r24, Y+3	; 0x03
    37a6:	9c 81       	ldd	r25, Y+4	; 0x04
    37a8:	02 96       	adiw	r24, 0x02	; 2
    37aa:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    37ae:	eb 81       	ldd	r30, Y+3	; 0x03
    37b0:	fc 81       	ldd	r31, Y+4	; 0x04
    37b2:	96 89       	ldd	r25, Z+22	; 0x16
    37b4:	80 91 58 04 	lds	r24, 0x0458
    37b8:	89 17       	cp	r24, r25
    37ba:	28 f4       	brcc	.+10     	; 0x37c6 <xTaskGenericNotify+0x152>
    37bc:	eb 81       	ldd	r30, Y+3	; 0x03
    37be:	fc 81       	ldd	r31, Y+4	; 0x04
    37c0:	86 89       	ldd	r24, Z+22	; 0x16
    37c2:	80 93 58 04 	sts	0x0458, r24
    37c6:	eb 81       	ldd	r30, Y+3	; 0x03
    37c8:	fc 81       	ldd	r31, Y+4	; 0x04
    37ca:	86 89       	ldd	r24, Z+22	; 0x16
    37cc:	28 2f       	mov	r18, r24
    37ce:	30 e0       	ldi	r19, 0x00	; 0
    37d0:	c9 01       	movw	r24, r18
    37d2:	88 0f       	add	r24, r24
    37d4:	99 1f       	adc	r25, r25
    37d6:	88 0f       	add	r24, r24
    37d8:	99 1f       	adc	r25, r25
    37da:	88 0f       	add	r24, r24
    37dc:	99 1f       	adc	r25, r25
    37de:	82 0f       	add	r24, r18
    37e0:	93 1f       	adc	r25, r19
    37e2:	ac 01       	movw	r20, r24
    37e4:	4f 59       	subi	r20, 0x9F	; 159
    37e6:	5b 4f       	sbci	r21, 0xFB	; 251
    37e8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ea:	9c 81       	ldd	r25, Y+4	; 0x04
    37ec:	9c 01       	movw	r18, r24
    37ee:	2e 5f       	subi	r18, 0xFE	; 254
    37f0:	3f 4f       	sbci	r19, 0xFF	; 255
    37f2:	ca 01       	movw	r24, r20
    37f4:	b9 01       	movw	r22, r18
    37f6:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    37fa:	eb 81       	ldd	r30, Y+3	; 0x03
    37fc:	fc 81       	ldd	r31, Y+4	; 0x04
    37fe:	96 89       	ldd	r25, Z+22	; 0x16
    3800:	e0 91 52 04 	lds	r30, 0x0452
    3804:	f0 91 53 04 	lds	r31, 0x0453
    3808:	86 89       	ldd	r24, Z+22	; 0x16
    380a:	89 17       	cp	r24, r25
    380c:	10 f4       	brcc	.+4      	; 0x3812 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    380e:	0e 94 2a 0b 	call	0x1654	; 0x1654 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3812:	0f 90       	pop	r0
    3814:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3816:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3818:	2f 96       	adiw	r28, 0x0f	; 15
    381a:	0f b6       	in	r0, 0x3f	; 63
    381c:	f8 94       	cli
    381e:	de bf       	out	0x3e, r29	; 62
    3820:	0f be       	out	0x3f, r0	; 63
    3822:	cd bf       	out	0x3d, r28	; 61
    3824:	cf 91       	pop	r28
    3826:	df 91       	pop	r29
    3828:	1f 91       	pop	r17
    382a:	0f 91       	pop	r16
    382c:	08 95       	ret

0000382e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    382e:	ef 92       	push	r14
    3830:	ff 92       	push	r15
    3832:	0f 93       	push	r16
    3834:	1f 93       	push	r17
    3836:	df 93       	push	r29
    3838:	cf 93       	push	r28
    383a:	cd b7       	in	r28, 0x3d	; 61
    383c:	de b7       	in	r29, 0x3e	; 62
    383e:	62 97       	sbiw	r28, 0x12	; 18
    3840:	0f b6       	in	r0, 0x3f	; 63
    3842:	f8 94       	cli
    3844:	de bf       	out	0x3e, r29	; 62
    3846:	0f be       	out	0x3f, r0	; 63
    3848:	cd bf       	out	0x3d, r28	; 61
    384a:	9f 83       	std	Y+7, r25	; 0x07
    384c:	8e 83       	std	Y+6, r24	; 0x06
    384e:	48 87       	std	Y+8, r20	; 0x08
    3850:	59 87       	std	Y+9, r21	; 0x09
    3852:	6a 87       	std	Y+10, r22	; 0x0a
    3854:	7b 87       	std	Y+11, r23	; 0x0b
    3856:	2c 87       	std	Y+12, r18	; 0x0c
    3858:	1e 87       	std	Y+14, r17	; 0x0e
    385a:	0d 87       	std	Y+13, r16	; 0x0d
    385c:	f8 8a       	std	Y+16, r15	; 0x10
    385e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	eNotifyValue eOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    3860:	81 e0       	ldi	r24, 0x01	; 1
    3862:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    3864:	8e 81       	ldd	r24, Y+6	; 0x06
    3866:	9f 81       	ldd	r25, Y+7	; 0x07
    3868:	9d 83       	std	Y+5, r25	; 0x05
    386a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    386c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    386e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3870:	9e 85       	ldd	r25, Y+14	; 0x0e
    3872:	00 97       	sbiw	r24, 0x00	; 0
    3874:	61 f0       	breq	.+24     	; 0x388e <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3876:	ec 81       	ldd	r30, Y+4	; 0x04
    3878:	fd 81       	ldd	r31, Y+5	; 0x05
    387a:	81 a1       	ldd	r24, Z+33	; 0x21
    387c:	92 a1       	ldd	r25, Z+34	; 0x22
    387e:	a3 a1       	ldd	r26, Z+35	; 0x23
    3880:	b4 a1       	ldd	r27, Z+36	; 0x24
    3882:	ed 85       	ldd	r30, Y+13	; 0x0d
    3884:	fe 85       	ldd	r31, Y+14	; 0x0e
    3886:	80 83       	st	Z, r24
    3888:	91 83       	std	Z+1, r25	; 0x01
    388a:	a2 83       	std	Z+2, r26	; 0x02
    388c:	b3 83       	std	Z+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    388e:	ec 81       	ldd	r30, Y+4	; 0x04
    3890:	fd 81       	ldd	r31, Y+5	; 0x05
    3892:	85 a1       	ldd	r24, Z+37	; 0x25
    3894:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->eNotifyState = eNotified;
    3896:	ec 81       	ldd	r30, Y+4	; 0x04
    3898:	fd 81       	ldd	r31, Y+5	; 0x05
    389a:	82 e0       	ldi	r24, 0x02	; 2
    389c:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    389e:	8c 85       	ldd	r24, Y+12	; 0x0c
    38a0:	28 2f       	mov	r18, r24
    38a2:	30 e0       	ldi	r19, 0x00	; 0
    38a4:	3a 8b       	std	Y+18, r19	; 0x12
    38a6:	29 8b       	std	Y+17, r18	; 0x11
    38a8:	89 89       	ldd	r24, Y+17	; 0x11
    38aa:	9a 89       	ldd	r25, Y+18	; 0x12
    38ac:	82 30       	cpi	r24, 0x02	; 2
    38ae:	91 05       	cpc	r25, r1
    38b0:	59 f1       	breq	.+86     	; 0x3908 <xTaskGenericNotifyFromISR+0xda>
    38b2:	29 89       	ldd	r18, Y+17	; 0x11
    38b4:	3a 89       	ldd	r19, Y+18	; 0x12
    38b6:	23 30       	cpi	r18, 0x03	; 3
    38b8:	31 05       	cpc	r19, r1
    38ba:	34 f4       	brge	.+12     	; 0x38c8 <xTaskGenericNotifyFromISR+0x9a>
    38bc:	89 89       	ldd	r24, Y+17	; 0x11
    38be:	9a 89       	ldd	r25, Y+18	; 0x12
    38c0:	81 30       	cpi	r24, 0x01	; 1
    38c2:	91 05       	cpc	r25, r1
    38c4:	61 f0       	breq	.+24     	; 0x38de <xTaskGenericNotifyFromISR+0xb0>
    38c6:	4a c0       	rjmp	.+148    	; 0x395c <xTaskGenericNotifyFromISR+0x12e>
    38c8:	29 89       	ldd	r18, Y+17	; 0x11
    38ca:	3a 89       	ldd	r19, Y+18	; 0x12
    38cc:	23 30       	cpi	r18, 0x03	; 3
    38ce:	31 05       	cpc	r19, r1
    38d0:	59 f1       	breq	.+86     	; 0x3928 <xTaskGenericNotifyFromISR+0xfa>
    38d2:	89 89       	ldd	r24, Y+17	; 0x11
    38d4:	9a 89       	ldd	r25, Y+18	; 0x12
    38d6:	84 30       	cpi	r24, 0x04	; 4
    38d8:	91 05       	cpc	r25, r1
    38da:	89 f1       	breq	.+98     	; 0x393e <xTaskGenericNotifyFromISR+0x110>
    38dc:	3f c0       	rjmp	.+126    	; 0x395c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    38de:	ec 81       	ldd	r30, Y+4	; 0x04
    38e0:	fd 81       	ldd	r31, Y+5	; 0x05
    38e2:	21 a1       	ldd	r18, Z+33	; 0x21
    38e4:	32 a1       	ldd	r19, Z+34	; 0x22
    38e6:	43 a1       	ldd	r20, Z+35	; 0x23
    38e8:	54 a1       	ldd	r21, Z+36	; 0x24
    38ea:	88 85       	ldd	r24, Y+8	; 0x08
    38ec:	99 85       	ldd	r25, Y+9	; 0x09
    38ee:	aa 85       	ldd	r26, Y+10	; 0x0a
    38f0:	bb 85       	ldd	r27, Y+11	; 0x0b
    38f2:	82 2b       	or	r24, r18
    38f4:	93 2b       	or	r25, r19
    38f6:	a4 2b       	or	r26, r20
    38f8:	b5 2b       	or	r27, r21
    38fa:	ec 81       	ldd	r30, Y+4	; 0x04
    38fc:	fd 81       	ldd	r31, Y+5	; 0x05
    38fe:	81 a3       	std	Z+33, r24	; 0x21
    3900:	92 a3       	std	Z+34, r25	; 0x22
    3902:	a3 a3       	std	Z+35, r26	; 0x23
    3904:	b4 a3       	std	Z+36, r27	; 0x24
    3906:	2a c0       	rjmp	.+84     	; 0x395c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3908:	ec 81       	ldd	r30, Y+4	; 0x04
    390a:	fd 81       	ldd	r31, Y+5	; 0x05
    390c:	81 a1       	ldd	r24, Z+33	; 0x21
    390e:	92 a1       	ldd	r25, Z+34	; 0x22
    3910:	a3 a1       	ldd	r26, Z+35	; 0x23
    3912:	b4 a1       	ldd	r27, Z+36	; 0x24
    3914:	01 96       	adiw	r24, 0x01	; 1
    3916:	a1 1d       	adc	r26, r1
    3918:	b1 1d       	adc	r27, r1
    391a:	ec 81       	ldd	r30, Y+4	; 0x04
    391c:	fd 81       	ldd	r31, Y+5	; 0x05
    391e:	81 a3       	std	Z+33, r24	; 0x21
    3920:	92 a3       	std	Z+34, r25	; 0x22
    3922:	a3 a3       	std	Z+35, r26	; 0x23
    3924:	b4 a3       	std	Z+36, r27	; 0x24
    3926:	1a c0       	rjmp	.+52     	; 0x395c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3928:	ec 81       	ldd	r30, Y+4	; 0x04
    392a:	fd 81       	ldd	r31, Y+5	; 0x05
    392c:	88 85       	ldd	r24, Y+8	; 0x08
    392e:	99 85       	ldd	r25, Y+9	; 0x09
    3930:	aa 85       	ldd	r26, Y+10	; 0x0a
    3932:	bb 85       	ldd	r27, Y+11	; 0x0b
    3934:	81 a3       	std	Z+33, r24	; 0x21
    3936:	92 a3       	std	Z+34, r25	; 0x22
    3938:	a3 a3       	std	Z+35, r26	; 0x23
    393a:	b4 a3       	std	Z+36, r27	; 0x24
    393c:	0f c0       	rjmp	.+30     	; 0x395c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    393e:	8b 81       	ldd	r24, Y+3	; 0x03
    3940:	82 30       	cpi	r24, 0x02	; 2
    3942:	59 f0       	breq	.+22     	; 0x395a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    3944:	ec 81       	ldd	r30, Y+4	; 0x04
    3946:	fd 81       	ldd	r31, Y+5	; 0x05
    3948:	88 85       	ldd	r24, Y+8	; 0x08
    394a:	99 85       	ldd	r25, Y+9	; 0x09
    394c:	aa 85       	ldd	r26, Y+10	; 0x0a
    394e:	bb 85       	ldd	r27, Y+11	; 0x0b
    3950:	81 a3       	std	Z+33, r24	; 0x21
    3952:	92 a3       	std	Z+34, r25	; 0x22
    3954:	a3 a3       	std	Z+35, r26	; 0x23
    3956:	b4 a3       	std	Z+36, r27	; 0x24
    3958:	01 c0       	rjmp	.+2      	; 0x395c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    395a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    395c:	8b 81       	ldd	r24, Y+3	; 0x03
    395e:	81 30       	cpi	r24, 0x01	; 1
    3960:	09 f0       	breq	.+2      	; 0x3964 <xTaskGenericNotifyFromISR+0x136>
    3962:	4c c0       	rjmp	.+152    	; 0x39fc <xTaskGenericNotifyFromISR+0x1ce>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3964:	80 91 60 04 	lds	r24, 0x0460
    3968:	88 23       	and	r24, r24
    396a:	61 f5       	brne	.+88     	; 0x39c4 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    396c:	8c 81       	ldd	r24, Y+4	; 0x04
    396e:	9d 81       	ldd	r25, Y+5	; 0x05
    3970:	02 96       	adiw	r24, 0x02	; 2
    3972:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3976:	ec 81       	ldd	r30, Y+4	; 0x04
    3978:	fd 81       	ldd	r31, Y+5	; 0x05
    397a:	96 89       	ldd	r25, Z+22	; 0x16
    397c:	80 91 58 04 	lds	r24, 0x0458
    3980:	89 17       	cp	r24, r25
    3982:	28 f4       	brcc	.+10     	; 0x398e <xTaskGenericNotifyFromISR+0x160>
    3984:	ec 81       	ldd	r30, Y+4	; 0x04
    3986:	fd 81       	ldd	r31, Y+5	; 0x05
    3988:	86 89       	ldd	r24, Z+22	; 0x16
    398a:	80 93 58 04 	sts	0x0458, r24
    398e:	ec 81       	ldd	r30, Y+4	; 0x04
    3990:	fd 81       	ldd	r31, Y+5	; 0x05
    3992:	86 89       	ldd	r24, Z+22	; 0x16
    3994:	28 2f       	mov	r18, r24
    3996:	30 e0       	ldi	r19, 0x00	; 0
    3998:	c9 01       	movw	r24, r18
    399a:	88 0f       	add	r24, r24
    399c:	99 1f       	adc	r25, r25
    399e:	88 0f       	add	r24, r24
    39a0:	99 1f       	adc	r25, r25
    39a2:	88 0f       	add	r24, r24
    39a4:	99 1f       	adc	r25, r25
    39a6:	82 0f       	add	r24, r18
    39a8:	93 1f       	adc	r25, r19
    39aa:	ac 01       	movw	r20, r24
    39ac:	4f 59       	subi	r20, 0x9F	; 159
    39ae:	5b 4f       	sbci	r21, 0xFB	; 251
    39b0:	8c 81       	ldd	r24, Y+4	; 0x04
    39b2:	9d 81       	ldd	r25, Y+5	; 0x05
    39b4:	9c 01       	movw	r18, r24
    39b6:	2e 5f       	subi	r18, 0xFE	; 254
    39b8:	3f 4f       	sbci	r19, 0xFF	; 255
    39ba:	ca 01       	movw	r24, r20
    39bc:	b9 01       	movw	r22, r18
    39be:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
    39c2:	0a c0       	rjmp	.+20     	; 0x39d8 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    39c4:	8c 81       	ldd	r24, Y+4	; 0x04
    39c6:	9d 81       	ldd	r25, Y+5	; 0x05
    39c8:	9c 01       	movw	r18, r24
    39ca:	24 5f       	subi	r18, 0xF4	; 244
    39cc:	3f 4f       	sbci	r19, 0xFF	; 255
    39ce:	8b e9       	ldi	r24, 0x9B	; 155
    39d0:	94 e0       	ldi	r25, 0x04	; 4
    39d2:	b9 01       	movw	r22, r18
    39d4:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    39d8:	ec 81       	ldd	r30, Y+4	; 0x04
    39da:	fd 81       	ldd	r31, Y+5	; 0x05
    39dc:	96 89       	ldd	r25, Z+22	; 0x16
    39de:	e0 91 52 04 	lds	r30, 0x0452
    39e2:	f0 91 53 04 	lds	r31, 0x0453
    39e6:	86 89       	ldd	r24, Z+22	; 0x16
    39e8:	89 17       	cp	r24, r25
    39ea:	40 f4       	brcc	.+16     	; 0x39fc <xTaskGenericNotifyFromISR+0x1ce>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    39ec:	8f 85       	ldd	r24, Y+15	; 0x0f
    39ee:	98 89       	ldd	r25, Y+16	; 0x10
    39f0:	00 97       	sbiw	r24, 0x00	; 0
    39f2:	21 f0       	breq	.+8      	; 0x39fc <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    39f4:	ef 85       	ldd	r30, Y+15	; 0x0f
    39f6:	f8 89       	ldd	r31, Y+16	; 0x10
    39f8:	81 e0       	ldi	r24, 0x01	; 1
    39fa:	80 83       	st	Z, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    39fc:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    39fe:	62 96       	adiw	r28, 0x12	; 18
    3a00:	0f b6       	in	r0, 0x3f	; 63
    3a02:	f8 94       	cli
    3a04:	de bf       	out	0x3e, r29	; 62
    3a06:	0f be       	out	0x3f, r0	; 63
    3a08:	cd bf       	out	0x3d, r28	; 61
    3a0a:	cf 91       	pop	r28
    3a0c:	df 91       	pop	r29
    3a0e:	1f 91       	pop	r17
    3a10:	0f 91       	pop	r16
    3a12:	ff 90       	pop	r15
    3a14:	ef 90       	pop	r14
    3a16:	08 95       	ret

00003a18 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3a18:	df 93       	push	r29
    3a1a:	cf 93       	push	r28
    3a1c:	cd b7       	in	r28, 0x3d	; 61
    3a1e:	de b7       	in	r29, 0x3e	; 62
    3a20:	28 97       	sbiw	r28, 0x08	; 8
    3a22:	0f b6       	in	r0, 0x3f	; 63
    3a24:	f8 94       	cli
    3a26:	de bf       	out	0x3e, r29	; 62
    3a28:	0f be       	out	0x3f, r0	; 63
    3a2a:	cd bf       	out	0x3d, r28	; 61
    3a2c:	9e 83       	std	Y+6, r25	; 0x06
    3a2e:	8d 83       	std	Y+5, r24	; 0x05
    3a30:	78 87       	std	Y+8, r23	; 0x08
    3a32:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
    3a34:	8d 81       	ldd	r24, Y+5	; 0x05
    3a36:	9e 81       	ldd	r25, Y+6	; 0x06
    3a38:	9c 83       	std	Y+4, r25	; 0x04
    3a3a:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3a3c:	19 82       	std	Y+1, r1	; 0x01
		{
			eOriginalNotifyState = pxTCB->eNotifyState;
    3a3e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a40:	fc 81       	ldd	r31, Y+4	; 0x04
    3a42:	85 a1       	ldd	r24, Z+37	; 0x25
    3a44:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->eNotifyState = eNotified;
    3a46:	eb 81       	ldd	r30, Y+3	; 0x03
    3a48:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4a:	82 e0       	ldi	r24, 0x02	; 2
    3a4c:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    3a4e:	eb 81       	ldd	r30, Y+3	; 0x03
    3a50:	fc 81       	ldd	r31, Y+4	; 0x04
    3a52:	81 a1       	ldd	r24, Z+33	; 0x21
    3a54:	92 a1       	ldd	r25, Z+34	; 0x22
    3a56:	a3 a1       	ldd	r26, Z+35	; 0x23
    3a58:	b4 a1       	ldd	r27, Z+36	; 0x24
    3a5a:	01 96       	adiw	r24, 0x01	; 1
    3a5c:	a1 1d       	adc	r26, r1
    3a5e:	b1 1d       	adc	r27, r1
    3a60:	eb 81       	ldd	r30, Y+3	; 0x03
    3a62:	fc 81       	ldd	r31, Y+4	; 0x04
    3a64:	81 a3       	std	Z+33, r24	; 0x21
    3a66:	92 a3       	std	Z+34, r25	; 0x22
    3a68:	a3 a3       	std	Z+35, r26	; 0x23
    3a6a:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    3a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a6e:	81 30       	cpi	r24, 0x01	; 1
    3a70:	09 f0       	breq	.+2      	; 0x3a74 <vTaskNotifyGiveFromISR+0x5c>
    3a72:	4c c0       	rjmp	.+152    	; 0x3b0c <vTaskNotifyGiveFromISR+0xf4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a74:	80 91 60 04 	lds	r24, 0x0460
    3a78:	88 23       	and	r24, r24
    3a7a:	61 f5       	brne	.+88     	; 0x3ad4 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    3a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    3a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    3a80:	02 96       	adiw	r24, 0x02	; 2
    3a82:	0e 94 1f 09 	call	0x123e	; 0x123e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3a86:	eb 81       	ldd	r30, Y+3	; 0x03
    3a88:	fc 81       	ldd	r31, Y+4	; 0x04
    3a8a:	96 89       	ldd	r25, Z+22	; 0x16
    3a8c:	80 91 58 04 	lds	r24, 0x0458
    3a90:	89 17       	cp	r24, r25
    3a92:	28 f4       	brcc	.+10     	; 0x3a9e <vTaskNotifyGiveFromISR+0x86>
    3a94:	eb 81       	ldd	r30, Y+3	; 0x03
    3a96:	fc 81       	ldd	r31, Y+4	; 0x04
    3a98:	86 89       	ldd	r24, Z+22	; 0x16
    3a9a:	80 93 58 04 	sts	0x0458, r24
    3a9e:	eb 81       	ldd	r30, Y+3	; 0x03
    3aa0:	fc 81       	ldd	r31, Y+4	; 0x04
    3aa2:	86 89       	ldd	r24, Z+22	; 0x16
    3aa4:	28 2f       	mov	r18, r24
    3aa6:	30 e0       	ldi	r19, 0x00	; 0
    3aa8:	c9 01       	movw	r24, r18
    3aaa:	88 0f       	add	r24, r24
    3aac:	99 1f       	adc	r25, r25
    3aae:	88 0f       	add	r24, r24
    3ab0:	99 1f       	adc	r25, r25
    3ab2:	88 0f       	add	r24, r24
    3ab4:	99 1f       	adc	r25, r25
    3ab6:	82 0f       	add	r24, r18
    3ab8:	93 1f       	adc	r25, r19
    3aba:	ac 01       	movw	r20, r24
    3abc:	4f 59       	subi	r20, 0x9F	; 159
    3abe:	5b 4f       	sbci	r21, 0xFB	; 251
    3ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ac2:	9c 81       	ldd	r25, Y+4	; 0x04
    3ac4:	9c 01       	movw	r18, r24
    3ac6:	2e 5f       	subi	r18, 0xFE	; 254
    3ac8:	3f 4f       	sbci	r19, 0xFF	; 255
    3aca:	ca 01       	movw	r24, r20
    3acc:	b9 01       	movw	r22, r18
    3ace:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
    3ad2:	0a c0       	rjmp	.+20     	; 0x3ae8 <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3ad4:	8b 81       	ldd	r24, Y+3	; 0x03
    3ad6:	9c 81       	ldd	r25, Y+4	; 0x04
    3ad8:	9c 01       	movw	r18, r24
    3ada:	24 5f       	subi	r18, 0xF4	; 244
    3adc:	3f 4f       	sbci	r19, 0xFF	; 255
    3ade:	8b e9       	ldi	r24, 0x9B	; 155
    3ae0:	94 e0       	ldi	r25, 0x04	; 4
    3ae2:	b9 01       	movw	r22, r18
    3ae4:	0e 94 6f 08 	call	0x10de	; 0x10de <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3ae8:	eb 81       	ldd	r30, Y+3	; 0x03
    3aea:	fc 81       	ldd	r31, Y+4	; 0x04
    3aec:	96 89       	ldd	r25, Z+22	; 0x16
    3aee:	e0 91 52 04 	lds	r30, 0x0452
    3af2:	f0 91 53 04 	lds	r31, 0x0453
    3af6:	86 89       	ldd	r24, Z+22	; 0x16
    3af8:	89 17       	cp	r24, r25
    3afa:	40 f4       	brcc	.+16     	; 0x3b0c <vTaskNotifyGiveFromISR+0xf4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3afc:	8f 81       	ldd	r24, Y+7	; 0x07
    3afe:	98 85       	ldd	r25, Y+8	; 0x08
    3b00:	00 97       	sbiw	r24, 0x00	; 0
    3b02:	21 f0       	breq	.+8      	; 0x3b0c <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3b04:	ef 81       	ldd	r30, Y+7	; 0x07
    3b06:	f8 85       	ldd	r31, Y+8	; 0x08
    3b08:	81 e0       	ldi	r24, 0x01	; 1
    3b0a:	80 83       	st	Z, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    3b0c:	28 96       	adiw	r28, 0x08	; 8
    3b0e:	0f b6       	in	r0, 0x3f	; 63
    3b10:	f8 94       	cli
    3b12:	de bf       	out	0x3e, r29	; 62
    3b14:	0f be       	out	0x3f, r0	; 63
    3b16:	cd bf       	out	0x3d, r28	; 61
    3b18:	cf 91       	pop	r28
    3b1a:	df 91       	pop	r29
    3b1c:	08 95       	ret

00003b1e <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    3b1e:	df 93       	push	r29
    3b20:	cf 93       	push	r28
    3b22:	cd b7       	in	r28, 0x3d	; 61
    3b24:	de b7       	in	r29, 0x3e	; 62
    3b26:	27 97       	sbiw	r28, 0x07	; 7
    3b28:	0f b6       	in	r0, 0x3f	; 63
    3b2a:	f8 94       	cli
    3b2c:	de bf       	out	0x3e, r29	; 62
    3b2e:	0f be       	out	0x3f, r0	; 63
    3b30:	cd bf       	out	0x3d, r28	; 61
    3b32:	9d 83       	std	Y+5, r25	; 0x05
    3b34:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		pxTCB = ( TCB_t * ) xTask;
    3b36:	8c 81       	ldd	r24, Y+4	; 0x04
    3b38:	9d 81       	ldd	r25, Y+5	; 0x05
    3b3a:	9b 83       	std	Y+3, r25	; 0x03
    3b3c:	8a 83       	std	Y+2, r24	; 0x02

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    3b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3b40:	9b 81       	ldd	r25, Y+3	; 0x03
    3b42:	00 97       	sbiw	r24, 0x00	; 0
    3b44:	39 f4       	brne	.+14     	; 0x3b54 <xTaskNotifyStateClear+0x36>
    3b46:	80 91 52 04 	lds	r24, 0x0452
    3b4a:	90 91 53 04 	lds	r25, 0x0453
    3b4e:	9f 83       	std	Y+7, r25	; 0x07
    3b50:	8e 83       	std	Y+6, r24	; 0x06
    3b52:	04 c0       	rjmp	.+8      	; 0x3b5c <xTaskNotifyStateClear+0x3e>
    3b54:	8a 81       	ldd	r24, Y+2	; 0x02
    3b56:	9b 81       	ldd	r25, Y+3	; 0x03
    3b58:	9f 83       	std	Y+7, r25	; 0x07
    3b5a:	8e 83       	std	Y+6, r24	; 0x06
    3b5c:	8e 81       	ldd	r24, Y+6	; 0x06
    3b5e:	9f 81       	ldd	r25, Y+7	; 0x07
    3b60:	9b 83       	std	Y+3, r25	; 0x03
    3b62:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    3b64:	0f b6       	in	r0, 0x3f	; 63
    3b66:	f8 94       	cli
    3b68:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    3b6a:	ea 81       	ldd	r30, Y+2	; 0x02
    3b6c:	fb 81       	ldd	r31, Y+3	; 0x03
    3b6e:	85 a1       	ldd	r24, Z+37	; 0x25
    3b70:	82 30       	cpi	r24, 0x02	; 2
    3b72:	31 f4       	brne	.+12     	; 0x3b80 <xTaskNotifyStateClear+0x62>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    3b74:	ea 81       	ldd	r30, Y+2	; 0x02
    3b76:	fb 81       	ldd	r31, Y+3	; 0x03
    3b78:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    3b7a:	81 e0       	ldi	r24, 0x01	; 1
    3b7c:	89 83       	std	Y+1, r24	; 0x01
    3b7e:	01 c0       	rjmp	.+2      	; 0x3b82 <xTaskNotifyStateClear+0x64>
			}
			else
			{
				xReturn = pdFAIL;
    3b80:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    3b86:	89 81       	ldd	r24, Y+1	; 0x01
	}
    3b88:	27 96       	adiw	r28, 0x07	; 7
    3b8a:	0f b6       	in	r0, 0x3f	; 63
    3b8c:	f8 94       	cli
    3b8e:	de bf       	out	0x3e, r29	; 62
    3b90:	0f be       	out	0x3f, r0	; 63
    3b92:	cd bf       	out	0x3d, r28	; 61
    3b94:	cf 91       	pop	r28
    3b96:	df 91       	pop	r29
    3b98:	08 95       	ret

00003b9a <UART_Init>:
* \Reentrancy      : Non Reentrant
* \Parameters (in) : baudRate - Baudrate corresponding value
* \Return value:   : None
*******************************************************************************/
void UART_Init(uint_16 baudRate)
{
    3b9a:	df 93       	push	r29
    3b9c:	cf 93       	push	r28
    3b9e:	00 d0       	rcall	.+0      	; 0x3ba0 <UART_Init+0x6>
    3ba0:	cd b7       	in	r28, 0x3d	; 61
    3ba2:	de b7       	in	r29, 0x3e	; 62
    3ba4:	9a 83       	std	Y+2, r25	; 0x02
    3ba6:	89 83       	std	Y+1, r24	; 0x01
	/* Set baud rate */
	UART_UBRRH_REG = (uint_8)(baudRate>>8);
    3ba8:	e0 e4       	ldi	r30, 0x40	; 64
    3baa:	f0 e0       	ldi	r31, 0x00	; 0
    3bac:	89 81       	ldd	r24, Y+1	; 0x01
    3bae:	9a 81       	ldd	r25, Y+2	; 0x02
    3bb0:	89 2f       	mov	r24, r25
    3bb2:	99 27       	eor	r25, r25
    3bb4:	80 83       	st	Z, r24
	UART_UBRRL_REG = (uint_8)baudRate;
    3bb6:	e9 e2       	ldi	r30, 0x29	; 41
    3bb8:	f0 e0       	ldi	r31, 0x00	; 0
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
    3bbc:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	SET_BIT(UART_UCSRB_REG,RXEN_BIT_NO);  /* Enable Receiver*/
    3bbe:	aa e2       	ldi	r26, 0x2A	; 42
    3bc0:	b0 e0       	ldi	r27, 0x00	; 0
    3bc2:	ea e2       	ldi	r30, 0x2A	; 42
    3bc4:	f0 e0       	ldi	r31, 0x00	; 0
    3bc6:	80 81       	ld	r24, Z
    3bc8:	80 61       	ori	r24, 0x10	; 16
    3bca:	8c 93       	st	X, r24
	SET_BIT(UART_UCSRB_REG,TXEN_BIT_NO);  /* Enable Transmitter */
    3bcc:	aa e2       	ldi	r26, 0x2A	; 42
    3bce:	b0 e0       	ldi	r27, 0x00	; 0
    3bd0:	ea e2       	ldi	r30, 0x2A	; 42
    3bd2:	f0 e0       	ldi	r31, 0x00	; 0
    3bd4:	80 81       	ld	r24, Z
    3bd6:	88 60       	ori	r24, 0x08	; 8
    3bd8:	8c 93       	st	X, r24
	/* Set frame format: 8data, 1stop bit, Even Parity */
	UART_UCSRC_REG |= (1 << URSEL_BIT_NO)|UART_8_BIT_DATA | UART_NONE_PARITY;
    3bda:	a0 e4       	ldi	r26, 0x40	; 64
    3bdc:	b0 e0       	ldi	r27, 0x00	; 0
    3bde:	e0 e4       	ldi	r30, 0x40	; 64
    3be0:	f0 e0       	ldi	r31, 0x00	; 0
    3be2:	80 81       	ld	r24, Z
    3be4:	86 68       	ori	r24, 0x86	; 134
    3be6:	8c 93       	st	X, r24
}
    3be8:	0f 90       	pop	r0
    3bea:	0f 90       	pop	r0
    3bec:	cf 91       	pop	r28
    3bee:	df 91       	pop	r29
    3bf0:	08 95       	ret

00003bf2 <UART_Send>:
* \Reentrancy      : Non Reentrant
* \Parameters (in) : data - data byte to transmit
* \Return value:   : None
*******************************************************************************/
void UART_Send(uint_8 data)
{
    3bf2:	df 93       	push	r29
    3bf4:	cf 93       	push	r28
    3bf6:	0f 92       	push	r0
    3bf8:	cd b7       	in	r28, 0x3d	; 61
    3bfa:	de b7       	in	r29, 0x3e	; 62
    3bfc:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for empty transmit buffer */
	while (!(GET_BIT(UART_UCSRA_REG,UDRE_BIT_NO)))
    3bfe:	eb e2       	ldi	r30, 0x2B	; 43
    3c00:	f0 e0       	ldi	r31, 0x00	; 0
    3c02:	80 81       	ld	r24, Z
    3c04:	88 2f       	mov	r24, r24
    3c06:	90 e0       	ldi	r25, 0x00	; 0
    3c08:	80 72       	andi	r24, 0x20	; 32
    3c0a:	90 70       	andi	r25, 0x00	; 0
    3c0c:	00 97       	sbiw	r24, 0x00	; 0
    3c0e:	b9 f3       	breq	.-18     	; 0x3bfe <UART_Send+0xc>
			;
	/* Put data into buffer, sends the data */
	UART_UDR_REG = data;
    3c10:	ec e2       	ldi	r30, 0x2C	; 44
    3c12:	f0 e0       	ldi	r31, 0x00	; 0
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	80 83       	st	Z, r24
}
    3c18:	0f 90       	pop	r0
    3c1a:	cf 91       	pop	r28
    3c1c:	df 91       	pop	r29
    3c1e:	08 95       	ret

00003c20 <UART_SendStr>:
* \Reentrancy      : Non Reentrant
* \Parameters (in) : data - data byte to transmit
* \Return value:   : None
*******************************************************************************/
void UART_SendStr(uint_8 *str)
{
    3c20:	df 93       	push	r29
    3c22:	cf 93       	push	r28
    3c24:	00 d0       	rcall	.+0      	; 0x3c26 <UART_SendStr+0x6>
    3c26:	cd b7       	in	r28, 0x3d	; 61
    3c28:	de b7       	in	r29, 0x3e	; 62
    3c2a:	9a 83       	std	Y+2, r25	; 0x02
    3c2c:	89 83       	std	Y+1, r24	; 0x01
    3c2e:	0a c0       	rjmp	.+20     	; 0x3c44 <UART_SendStr+0x24>
	/* Wait for empty transmit buffer */
	while (*str != '\0')
	{
		UART_Send(*str);
    3c30:	e9 81       	ldd	r30, Y+1	; 0x01
    3c32:	fa 81       	ldd	r31, Y+2	; 0x02
    3c34:	80 81       	ld	r24, Z
    3c36:	0e 94 f9 1d 	call	0x3bf2	; 0x3bf2 <UART_Send>
		str++;
    3c3a:	89 81       	ldd	r24, Y+1	; 0x01
    3c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    3c3e:	01 96       	adiw	r24, 0x01	; 1
    3c40:	9a 83       	std	Y+2, r25	; 0x02
    3c42:	89 83       	std	Y+1, r24	; 0x01
* \Return value:   : None
*******************************************************************************/
void UART_SendStr(uint_8 *str)
{
	/* Wait for empty transmit buffer */
	while (*str != '\0')
    3c44:	e9 81       	ldd	r30, Y+1	; 0x01
    3c46:	fa 81       	ldd	r31, Y+2	; 0x02
    3c48:	80 81       	ld	r24, Z
    3c4a:	88 23       	and	r24, r24
    3c4c:	89 f7       	brne	.-30     	; 0x3c30 <UART_SendStr+0x10>
	{
		UART_Send(*str);
		str++;
	}
}
    3c4e:	0f 90       	pop	r0
    3c50:	0f 90       	pop	r0
    3c52:	cf 91       	pop	r28
    3c54:	df 91       	pop	r29
    3c56:	08 95       	ret

00003c58 <UART_Read>:
* \Reentrancy      : Non Reentrant
* \Parameters (in) : Nonr
* \Return value:   : data byte received
*******************************************************************************/
uint_8 UART_Read(void)
{
    3c58:	df 93       	push	r29
    3c5a:	cf 93       	push	r28
    3c5c:	0f 92       	push	r0
    3c5e:	cd b7       	in	r28, 0x3d	; 61
    3c60:	de b7       	in	r29, 0x3e	; 62
	while(!(UART_UCSRA_REG) & (1<<RXC_BIT_NO));
    3c62:	eb e2       	ldi	r30, 0x2B	; 43
    3c64:	f0 e0       	ldi	r31, 0x00	; 0
    3c66:	80 81       	ld	r24, Z
	return UART_UDR_REG;
    3c68:	ec e2       	ldi	r30, 0x2C	; 44
    3c6a:	f0 e0       	ldi	r31, 0x00	; 0
    3c6c:	80 81       	ld	r24, Z
	/* Wait for data to be received */
	//while (!(GET_BIT(UART_UCSRA_REG,RXC_BIT_NO)))
			
	/* Get and return received data from buffer */
	//return UART_UDR_REG;
}
    3c6e:	0f 90       	pop	r0
    3c70:	cf 91       	pop	r28
    3c72:	df 91       	pop	r29
    3c74:	08 95       	ret

00003c76 <Spi_MasterInit>:
#include "STD_TYPES.h"
#include "DIO_PRIVATE.h"
#include "DIO_INTERFACE.h"

void Spi_MasterInit(void)
{
    3c76:	df 93       	push	r29
    3c78:	cf 93       	push	r28
    3c7a:	cd b7       	in	r28, 0x3d	; 61
    3c7c:	de b7       	in	r29, 0x3e	; 62
	/*	configure SPI MOSI Pin as output	*/
	DIO_SetPinDirection(SPI_MOSI_PORT, SPI_MOSI_CHANNEL, OUTPUT);
    3c7e:	81 e0       	ldi	r24, 0x01	; 1
    3c80:	65 e0       	ldi	r22, 0x05	; 5
    3c82:	41 e0       	ldi	r20, 0x01	; 1
    3c84:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	configure SPI SS Pin as output	*/
	DIO_SetPinDirection(SPI_SS_PORT, SPI_SS_CHANNEL, OUTPUT);
    3c88:	81 e0       	ldi	r24, 0x01	; 1
    3c8a:	64 e0       	ldi	r22, 0x04	; 4
    3c8c:	41 e0       	ldi	r20, 0x01	; 1
    3c8e:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	configure SPI SCK Pin as output	*/
	DIO_SetPinDirection(SPI_SCK_PORT, SPI_SCK_CHANNEL, OUTPUT);
    3c92:	81 e0       	ldi	r24, 0x01	; 1
    3c94:	67 e0       	ldi	r22, 0x07	; 7
    3c96:	41 e0       	ldi	r20, 0x01	; 1
    3c98:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	configure SPI MISO Pin as input	*/
	DIO_SetPinDirection(SPI_MISO_PORT, SPI_MISO_CHANNEL, INPUT);
    3c9c:	81 e0       	ldi	r24, 0x01	; 1
    3c9e:	66 e0       	ldi	r22, 0x06	; 6
    3ca0:	40 e0       	ldi	r20, 0x00	; 0
    3ca2:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	initialize SPI SS pin with HIGH (No slave selected) */
	DIO_SetPinValue(SPI_SS_PORT, SPI_SS_CHANNEL, HIGH);
    3ca6:	81 e0       	ldi	r24, 0x01	; 1
    3ca8:	64 e0       	ldi	r22, 0x04	; 4
    3caa:	41 e0       	ldi	r20, 0x01	; 1
    3cac:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT_NO);
    3cb0:	ad e2       	ldi	r26, 0x2D	; 45
    3cb2:	b0 e0       	ldi	r27, 0x00	; 0
    3cb4:	ed e2       	ldi	r30, 0x2D	; 45
    3cb6:	f0 e0       	ldi	r31, 0x00	; 0
    3cb8:	80 81       	ld	r24, Z
    3cba:	80 64       	ori	r24, 0x40	; 64
    3cbc:	8c 93       	st	X, r24
	/*	enable SPI Module in Master mode	*/
	SET_BIT(SPI_SPCR_REG,SPI_MSTR_BIT_NO);
    3cbe:	ad e2       	ldi	r26, 0x2D	; 45
    3cc0:	b0 e0       	ldi	r27, 0x00	; 0
    3cc2:	ed e2       	ldi	r30, 0x2D	; 45
    3cc4:	f0 e0       	ldi	r31, 0x00	; 0
    3cc6:	80 81       	ld	r24, Z
    3cc8:	80 61       	ori	r24, 0x10	; 16
    3cca:	8c 93       	st	X, r24
	/*	set SCK frequency by F_CPU/16	*/
	SPI_SPCR_REG|=SPI_SCK_FREQ_FCPU_DIV_16;
    3ccc:	ad e2       	ldi	r26, 0x2D	; 45
    3cce:	b0 e0       	ldi	r27, 0x00	; 0
    3cd0:	ed e2       	ldi	r30, 0x2D	; 45
    3cd2:	f0 e0       	ldi	r31, 0x00	; 0
    3cd4:	80 81       	ld	r24, Z
    3cd6:	81 60       	ori	r24, 0x01	; 1
    3cd8:	8c 93       	st	X, r24
}
    3cda:	cf 91       	pop	r28
    3cdc:	df 91       	pop	r29
    3cde:	08 95       	ret

00003ce0 <Spi_SlaveInit>:

void Spi_SlaveInit(void)
{
    3ce0:	df 93       	push	r29
    3ce2:	cf 93       	push	r28
    3ce4:	cd b7       	in	r28, 0x3d	; 61
    3ce6:	de b7       	in	r29, 0x3e	; 62
	/*	configure SPI MOSI Pin as input	*/
	DIO_SetPinDirection(SPI_MOSI_PORT, SPI_MOSI_CHANNEL, INPUT);
    3ce8:	81 e0       	ldi	r24, 0x01	; 1
    3cea:	65 e0       	ldi	r22, 0x05	; 5
    3cec:	40 e0       	ldi	r20, 0x00	; 0
    3cee:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	configure SPI SS Pin as input	*/
	DIO_SetPinDirection(SPI_SS_PORT, SPI_SS_CHANNEL, INPUT);
    3cf2:	81 e0       	ldi	r24, 0x01	; 1
    3cf4:	64 e0       	ldi	r22, 0x04	; 4
    3cf6:	40 e0       	ldi	r20, 0x00	; 0
    3cf8:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	configure SPI SCK Pin as input	*/
	DIO_SetPinDirection(SPI_SCK_PORT, SPI_SCK_CHANNEL, INPUT);
    3cfc:	81 e0       	ldi	r24, 0x01	; 1
    3cfe:	67 e0       	ldi	r22, 0x07	; 7
    3d00:	40 e0       	ldi	r20, 0x00	; 0
    3d02:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	configure SPI MISO Pin as output	*/
	DIO_SetPinDirection(SPI_MISO_PORT, SPI_MISO_CHANNEL, OUTPUT);
    3d06:	81 e0       	ldi	r24, 0x01	; 1
    3d08:	66 e0       	ldi	r22, 0x06	; 6
    3d0a:	41 e0       	ldi	r20, 0x01	; 1
    3d0c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT_NO);
    3d10:	ad e2       	ldi	r26, 0x2D	; 45
    3d12:	b0 e0       	ldi	r27, 0x00	; 0
    3d14:	ed e2       	ldi	r30, 0x2D	; 45
    3d16:	f0 e0       	ldi	r31, 0x00	; 0
    3d18:	80 81       	ld	r24, Z
    3d1a:	80 64       	ori	r24, 0x40	; 64
    3d1c:	8c 93       	st	X, r24
	/*	enable SPI Module in Slave mode	*/
	CLR_BIT(SPI_SPCR_REG,SPI_MSTR_BIT_NO);
    3d1e:	ad e2       	ldi	r26, 0x2D	; 45
    3d20:	b0 e0       	ldi	r27, 0x00	; 0
    3d22:	ed e2       	ldi	r30, 0x2D	; 45
    3d24:	f0 e0       	ldi	r31, 0x00	; 0
    3d26:	80 81       	ld	r24, Z
    3d28:	8f 7e       	andi	r24, 0xEF	; 239
    3d2a:	8c 93       	st	X, r24
}
    3d2c:	cf 91       	pop	r28
    3d2e:	df 91       	pop	r29
    3d30:	08 95       	ret

00003d32 <Spi_MasterWrite>:

void Spi_MasterWrite(uint_8 data)
{
    3d32:	df 93       	push	r29
    3d34:	cf 93       	push	r28
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <Spi_MasterWrite+0x6>
    3d38:	cd b7       	in	r28, 0x3d	; 61
    3d3a:	de b7       	in	r29, 0x3e	; 62
    3d3c:	8a 83       	std	Y+2, r24	; 0x02
	uint_8 loc_flush_byte;
	/*	load SPI data register with a byte to send	*/
	DIO_SetPinValue(SPI_SS_PORT,SPI_SS_CHANNEL,LOW);
    3d3e:	81 e0       	ldi	r24, 0x01	; 1
    3d40:	64 e0       	ldi	r22, 0x04	; 4
    3d42:	40 e0       	ldi	r20, 0x00	; 0
    3d44:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	SPI_SPDR_REG = data;
    3d48:	ef e2       	ldi	r30, 0x2F	; 47
    3d4a:	f0 e0       	ldi	r31, 0x00	; 0
    3d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d4e:	80 83       	st	Z, r24
	/*	wait until byte sent	*/
	while(!(GET_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)));
    3d50:	ee e2       	ldi	r30, 0x2E	; 46
    3d52:	f0 e0       	ldi	r31, 0x00	; 0
    3d54:	80 81       	ld	r24, Z
    3d56:	88 23       	and	r24, r24
    3d58:	dc f7       	brge	.-10     	; 0x3d50 <Spi_MasterWrite+0x1e>
	/*	flush the data register	*/
	loc_flush_byte = SPI_SPDR_REG;
    3d5a:	ef e2       	ldi	r30, 0x2F	; 47
    3d5c:	f0 e0       	ldi	r31, 0x00	; 0
    3d5e:	80 81       	ld	r24, Z
    3d60:	89 83       	std	Y+1, r24	; 0x01
}
    3d62:	0f 90       	pop	r0
    3d64:	0f 90       	pop	r0
    3d66:	cf 91       	pop	r28
    3d68:	df 91       	pop	r29
    3d6a:	08 95       	ret

00003d6c <Spi_MasterRead>:
uint_8 Spi_MasterRead(void)
{
    3d6c:	df 93       	push	r29
    3d6e:	cf 93       	push	r28
    3d70:	0f 92       	push	r0
    3d72:	cd b7       	in	r28, 0x3d	; 61
    3d74:	de b7       	in	r29, 0x3e	; 62
	uint_8 loc_dummy_byte=0xFF;
    3d76:	8f ef       	ldi	r24, 0xFF	; 255
    3d78:	89 83       	std	Y+1, r24	; 0x01
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = loc_dummy_byte;
    3d7a:	ef e2       	ldi	r30, 0x2F	; 47
    3d7c:	f0 e0       	ldi	r31, 0x00	; 0
    3d7e:	89 81       	ldd	r24, Y+1	; 0x01
    3d80:	80 83       	st	Z, r24
	/*	wait until byte received	*/
	while(!(GET_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)));
    3d82:	ee e2       	ldi	r30, 0x2E	; 46
    3d84:	f0 e0       	ldi	r31, 0x00	; 0
    3d86:	80 81       	ld	r24, Z
    3d88:	88 23       	and	r24, r24
    3d8a:	dc f7       	brge	.-10     	; 0x3d82 <Spi_MasterRead+0x16>
	/*	read the data register	*/
	return SPI_SPDR_REG;
    3d8c:	ef e2       	ldi	r30, 0x2F	; 47
    3d8e:	f0 e0       	ldi	r31, 0x00	; 0
    3d90:	80 81       	ld	r24, Z
}
    3d92:	0f 90       	pop	r0
    3d94:	cf 91       	pop	r28
    3d96:	df 91       	pop	r29
    3d98:	08 95       	ret

00003d9a <Spi_MasterTranseve>:

uint_8 Spi_MasterTranseve(uint_8 data)
{
    3d9a:	df 93       	push	r29
    3d9c:	cf 93       	push	r28
    3d9e:	0f 92       	push	r0
    3da0:	cd b7       	in	r28, 0x3d	; 61
    3da2:	de b7       	in	r29, 0x3e	; 62
    3da4:	89 83       	std	Y+1, r24	; 0x01
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    3da6:	ef e2       	ldi	r30, 0x2F	; 47
    3da8:	f0 e0       	ldi	r31, 0x00	; 0
    3daa:	89 81       	ldd	r24, Y+1	; 0x01
    3dac:	80 83       	st	Z, r24
	/*	wait until byte sent	*/
	while(!(GET_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)));
    3dae:	ee e2       	ldi	r30, 0x2E	; 46
    3db0:	f0 e0       	ldi	r31, 0x00	; 0
    3db2:	80 81       	ld	r24, Z
    3db4:	88 23       	and	r24, r24
    3db6:	dc f7       	brge	.-10     	; 0x3dae <Spi_MasterTranseve+0x14>
	/*	flush the data register	*/
	return SPI_SPDR_REG;
    3db8:	ef e2       	ldi	r30, 0x2F	; 47
    3dba:	f0 e0       	ldi	r31, 0x00	; 0
    3dbc:	80 81       	ld	r24, Z
}
    3dbe:	0f 90       	pop	r0
    3dc0:	cf 91       	pop	r28
    3dc2:	df 91       	pop	r29
    3dc4:	08 95       	ret

00003dc6 <Spi_SlaveRead>:
uint_8 Spi_SlaveRead(void)
{
    3dc6:	df 93       	push	r29
    3dc8:	cf 93       	push	r28
    3dca:	cd b7       	in	r28, 0x3d	; 61
    3dcc:	de b7       	in	r29, 0x3e	; 62
	/*	wait until byte received	*/
	while(!(GET_BIT(SPI_SPSR_REG,SPI_SPIF_BIT_NO)));
    3dce:	ee e2       	ldi	r30, 0x2E	; 46
    3dd0:	f0 e0       	ldi	r31, 0x00	; 0
    3dd2:	80 81       	ld	r24, Z
    3dd4:	88 23       	and	r24, r24
    3dd6:	dc f7       	brge	.-10     	; 0x3dce <Spi_SlaveRead+0x8>
	/*	read the data register	*/
	return SPI_SPDR_REG;
    3dd8:	ef e2       	ldi	r30, 0x2F	; 47
    3dda:	f0 e0       	ldi	r31, 0x00	; 0
    3ddc:	80 81       	ld	r24, Z
}
    3dde:	cf 91       	pop	r28
    3de0:	df 91       	pop	r29
    3de2:	08 95       	ret

00003de4 <Spi_SlaveWrite>:

void Spi_SlaveWrite(uint_8 data)
{
    3de4:	df 93       	push	r29
    3de6:	cf 93       	push	r28
    3de8:	0f 92       	push	r0
    3dea:	cd b7       	in	r28, 0x3d	; 61
    3dec:	de b7       	in	r29, 0x3e	; 62
    3dee:	89 83       	std	Y+1, r24	; 0x01
	SPI_SPDR_REG = data;
    3df0:	ef e2       	ldi	r30, 0x2F	; 47
    3df2:	f0 e0       	ldi	r31, 0x00	; 0
    3df4:	89 81       	ldd	r24, Y+1	; 0x01
    3df6:	80 83       	st	Z, r24
    3df8:	0f 90       	pop	r0
    3dfa:	cf 91       	pop	r28
    3dfc:	df 91       	pop	r29
    3dfe:	08 95       	ret

00003e00 <DIO_SetPortDirection>:
	DIO_SetportDirection(PORTA ,INPUT);
	PORTA ===> input 				===> 	DDR = 0x00
*/

void DIO_SetPortDirection(uint_8 PortID ,uint_8 Direction)
{
    3e00:	df 93       	push	r29
    3e02:	cf 93       	push	r28
    3e04:	cd b7       	in	r28, 0x3d	; 61
    3e06:	de b7       	in	r29, 0x3e	; 62
    3e08:	28 97       	sbiw	r28, 0x08	; 8
    3e0a:	0f b6       	in	r0, 0x3f	; 63
    3e0c:	f8 94       	cli
    3e0e:	de bf       	out	0x3e, r29	; 62
    3e10:	0f be       	out	0x3f, r0	; 63
    3e12:	cd bf       	out	0x3d, r28	; 61
    3e14:	89 83       	std	Y+1, r24	; 0x01
    3e16:	6a 83       	std	Y+2, r22	; 0x02
	//Range check
	if (PortID <4 )
    3e18:	89 81       	ldd	r24, Y+1	; 0x01
    3e1a:	84 30       	cpi	r24, 0x04	; 4
    3e1c:	08 f0       	brcs	.+2      	; 0x3e20 <DIO_SetPortDirection+0x20>
    3e1e:	9a c0       	rjmp	.+308    	; 0x3f54 <DIO_SetPortDirection+0x154>
	{
		if(Direction==OUTPUT)
    3e20:	8a 81       	ldd	r24, Y+2	; 0x02
    3e22:	81 30       	cpi	r24, 0x01	; 1
    3e24:	99 f5       	brne	.+102    	; 0x3e8c <DIO_SetPortDirection+0x8c>
			{
				switch(PortID)
    3e26:	89 81       	ldd	r24, Y+1	; 0x01
    3e28:	28 2f       	mov	r18, r24
    3e2a:	30 e0       	ldi	r19, 0x00	; 0
    3e2c:	38 87       	std	Y+8, r19	; 0x08
    3e2e:	2f 83       	std	Y+7, r18	; 0x07
    3e30:	8f 81       	ldd	r24, Y+7	; 0x07
    3e32:	98 85       	ldd	r25, Y+8	; 0x08
    3e34:	81 30       	cpi	r24, 0x01	; 1
    3e36:	91 05       	cpc	r25, r1
    3e38:	d1 f0       	breq	.+52     	; 0x3e6e <DIO_SetPortDirection+0x6e>
    3e3a:	2f 81       	ldd	r18, Y+7	; 0x07
    3e3c:	38 85       	ldd	r19, Y+8	; 0x08
    3e3e:	22 30       	cpi	r18, 0x02	; 2
    3e40:	31 05       	cpc	r19, r1
    3e42:	2c f4       	brge	.+10     	; 0x3e4e <DIO_SetPortDirection+0x4e>
    3e44:	8f 81       	ldd	r24, Y+7	; 0x07
    3e46:	98 85       	ldd	r25, Y+8	; 0x08
    3e48:	00 97       	sbiw	r24, 0x00	; 0
    3e4a:	61 f0       	breq	.+24     	; 0x3e64 <DIO_SetPortDirection+0x64>
    3e4c:	83 c0       	rjmp	.+262    	; 0x3f54 <DIO_SetPortDirection+0x154>
    3e4e:	2f 81       	ldd	r18, Y+7	; 0x07
    3e50:	38 85       	ldd	r19, Y+8	; 0x08
    3e52:	22 30       	cpi	r18, 0x02	; 2
    3e54:	31 05       	cpc	r19, r1
    3e56:	81 f0       	breq	.+32     	; 0x3e78 <DIO_SetPortDirection+0x78>
    3e58:	8f 81       	ldd	r24, Y+7	; 0x07
    3e5a:	98 85       	ldd	r25, Y+8	; 0x08
    3e5c:	83 30       	cpi	r24, 0x03	; 3
    3e5e:	91 05       	cpc	r25, r1
    3e60:	81 f0       	breq	.+32     	; 0x3e82 <DIO_SetPortDirection+0x82>
    3e62:	78 c0       	rjmp	.+240    	; 0x3f54 <DIO_SetPortDirection+0x154>
				{
					case DIO_PORTA : DDRA_REG = 0xFF; break;
    3e64:	ea e3       	ldi	r30, 0x3A	; 58
    3e66:	f0 e0       	ldi	r31, 0x00	; 0
    3e68:	8f ef       	ldi	r24, 0xFF	; 255
    3e6a:	80 83       	st	Z, r24
    3e6c:	73 c0       	rjmp	.+230    	; 0x3f54 <DIO_SetPortDirection+0x154>
					case DIO_PORTB : DDRB_REG = 0xFF; break;
    3e6e:	e7 e3       	ldi	r30, 0x37	; 55
    3e70:	f0 e0       	ldi	r31, 0x00	; 0
    3e72:	8f ef       	ldi	r24, 0xFF	; 255
    3e74:	80 83       	st	Z, r24
    3e76:	6e c0       	rjmp	.+220    	; 0x3f54 <DIO_SetPortDirection+0x154>
					case DIO_PORTC : DDRC_REG = 0xFF; break;
    3e78:	e4 e3       	ldi	r30, 0x34	; 52
    3e7a:	f0 e0       	ldi	r31, 0x00	; 0
    3e7c:	8f ef       	ldi	r24, 0xFF	; 255
    3e7e:	80 83       	st	Z, r24
    3e80:	69 c0       	rjmp	.+210    	; 0x3f54 <DIO_SetPortDirection+0x154>
					case DIO_PORTD : DDRD_REG = 0xFF; break;
    3e82:	e1 e3       	ldi	r30, 0x31	; 49
    3e84:	f0 e0       	ldi	r31, 0x00	; 0
    3e86:	8f ef       	ldi	r24, 0xFF	; 255
    3e88:	80 83       	st	Z, r24
    3e8a:	64 c0       	rjmp	.+200    	; 0x3f54 <DIO_SetPortDirection+0x154>
				}
			}
		else if (Direction==INPUT)
    3e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    3e8e:	88 23       	and	r24, r24
    3e90:	79 f5       	brne	.+94     	; 0x3ef0 <DIO_SetPortDirection+0xf0>
		   {
			   switch(PortID)
    3e92:	89 81       	ldd	r24, Y+1	; 0x01
    3e94:	28 2f       	mov	r18, r24
    3e96:	30 e0       	ldi	r19, 0x00	; 0
    3e98:	3e 83       	std	Y+6, r19	; 0x06
    3e9a:	2d 83       	std	Y+5, r18	; 0x05
    3e9c:	8d 81       	ldd	r24, Y+5	; 0x05
    3e9e:	9e 81       	ldd	r25, Y+6	; 0x06
    3ea0:	81 30       	cpi	r24, 0x01	; 1
    3ea2:	91 05       	cpc	r25, r1
    3ea4:	c9 f0       	breq	.+50     	; 0x3ed8 <DIO_SetPortDirection+0xd8>
    3ea6:	2d 81       	ldd	r18, Y+5	; 0x05
    3ea8:	3e 81       	ldd	r19, Y+6	; 0x06
    3eaa:	22 30       	cpi	r18, 0x02	; 2
    3eac:	31 05       	cpc	r19, r1
    3eae:	2c f4       	brge	.+10     	; 0x3eba <DIO_SetPortDirection+0xba>
    3eb0:	8d 81       	ldd	r24, Y+5	; 0x05
    3eb2:	9e 81       	ldd	r25, Y+6	; 0x06
    3eb4:	00 97       	sbiw	r24, 0x00	; 0
    3eb6:	61 f0       	breq	.+24     	; 0x3ed0 <DIO_SetPortDirection+0xd0>
    3eb8:	4d c0       	rjmp	.+154    	; 0x3f54 <DIO_SetPortDirection+0x154>
    3eba:	2d 81       	ldd	r18, Y+5	; 0x05
    3ebc:	3e 81       	ldd	r19, Y+6	; 0x06
    3ebe:	22 30       	cpi	r18, 0x02	; 2
    3ec0:	31 05       	cpc	r19, r1
    3ec2:	71 f0       	breq	.+28     	; 0x3ee0 <DIO_SetPortDirection+0xe0>
    3ec4:	8d 81       	ldd	r24, Y+5	; 0x05
    3ec6:	9e 81       	ldd	r25, Y+6	; 0x06
    3ec8:	83 30       	cpi	r24, 0x03	; 3
    3eca:	91 05       	cpc	r25, r1
    3ecc:	69 f0       	breq	.+26     	; 0x3ee8 <DIO_SetPortDirection+0xe8>
    3ece:	42 c0       	rjmp	.+132    	; 0x3f54 <DIO_SetPortDirection+0x154>
				{
					case DIO_PORTA : DDRA_REG = 0x00; break;
    3ed0:	ea e3       	ldi	r30, 0x3A	; 58
    3ed2:	f0 e0       	ldi	r31, 0x00	; 0
    3ed4:	10 82       	st	Z, r1
    3ed6:	3e c0       	rjmp	.+124    	; 0x3f54 <DIO_SetPortDirection+0x154>
					case DIO_PORTB : DDRB_REG = 0x00; break;
    3ed8:	e7 e3       	ldi	r30, 0x37	; 55
    3eda:	f0 e0       	ldi	r31, 0x00	; 0
    3edc:	10 82       	st	Z, r1
    3ede:	3a c0       	rjmp	.+116    	; 0x3f54 <DIO_SetPortDirection+0x154>
					case DIO_PORTC : DDRC_REG = 0x00; break;
    3ee0:	e4 e3       	ldi	r30, 0x34	; 52
    3ee2:	f0 e0       	ldi	r31, 0x00	; 0
    3ee4:	10 82       	st	Z, r1
    3ee6:	36 c0       	rjmp	.+108    	; 0x3f54 <DIO_SetPortDirection+0x154>
					case DIO_PORTD : DDRD_REG = 0x00; break;
    3ee8:	e1 e3       	ldi	r30, 0x31	; 49
    3eea:	f0 e0       	ldi	r31, 0x00	; 0
    3eec:	10 82       	st	Z, r1
    3eee:	32 c0       	rjmp	.+100    	; 0x3f54 <DIO_SetPortDirection+0x154>
		   }
		else 
		{
			/*  set Direction value to the custom direction inserted  
            DIO_SetDIO_PORTDirection(DDRA_REG ,0x0F);			*/
			switch (PortID)
    3ef0:	89 81       	ldd	r24, Y+1	; 0x01
    3ef2:	28 2f       	mov	r18, r24
    3ef4:	30 e0       	ldi	r19, 0x00	; 0
    3ef6:	3c 83       	std	Y+4, r19	; 0x04
    3ef8:	2b 83       	std	Y+3, r18	; 0x03
    3efa:	8b 81       	ldd	r24, Y+3	; 0x03
    3efc:	9c 81       	ldd	r25, Y+4	; 0x04
    3efe:	81 30       	cpi	r24, 0x01	; 1
    3f00:	91 05       	cpc	r25, r1
    3f02:	d1 f0       	breq	.+52     	; 0x3f38 <DIO_SetPortDirection+0x138>
    3f04:	2b 81       	ldd	r18, Y+3	; 0x03
    3f06:	3c 81       	ldd	r19, Y+4	; 0x04
    3f08:	22 30       	cpi	r18, 0x02	; 2
    3f0a:	31 05       	cpc	r19, r1
    3f0c:	2c f4       	brge	.+10     	; 0x3f18 <DIO_SetPortDirection+0x118>
    3f0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f10:	9c 81       	ldd	r25, Y+4	; 0x04
    3f12:	00 97       	sbiw	r24, 0x00	; 0
    3f14:	61 f0       	breq	.+24     	; 0x3f2e <DIO_SetPortDirection+0x12e>
    3f16:	1e c0       	rjmp	.+60     	; 0x3f54 <DIO_SetPortDirection+0x154>
    3f18:	2b 81       	ldd	r18, Y+3	; 0x03
    3f1a:	3c 81       	ldd	r19, Y+4	; 0x04
    3f1c:	22 30       	cpi	r18, 0x02	; 2
    3f1e:	31 05       	cpc	r19, r1
    3f20:	81 f0       	breq	.+32     	; 0x3f42 <DIO_SetPortDirection+0x142>
    3f22:	8b 81       	ldd	r24, Y+3	; 0x03
    3f24:	9c 81       	ldd	r25, Y+4	; 0x04
    3f26:	83 30       	cpi	r24, 0x03	; 3
    3f28:	91 05       	cpc	r25, r1
    3f2a:	81 f0       	breq	.+32     	; 0x3f4c <DIO_SetPortDirection+0x14c>
    3f2c:	13 c0       	rjmp	.+38     	; 0x3f54 <DIO_SetPortDirection+0x154>
			{
				case DIO_PORTA : DDRA_REG = Direction; break;
    3f2e:	ea e3       	ldi	r30, 0x3A	; 58
    3f30:	f0 e0       	ldi	r31, 0x00	; 0
    3f32:	8a 81       	ldd	r24, Y+2	; 0x02
    3f34:	80 83       	st	Z, r24
    3f36:	0e c0       	rjmp	.+28     	; 0x3f54 <DIO_SetPortDirection+0x154>
				case DIO_PORTB : DDRB_REG = Direction; break;
    3f38:	e7 e3       	ldi	r30, 0x37	; 55
    3f3a:	f0 e0       	ldi	r31, 0x00	; 0
    3f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    3f3e:	80 83       	st	Z, r24
    3f40:	09 c0       	rjmp	.+18     	; 0x3f54 <DIO_SetPortDirection+0x154>
				case DIO_PORTC : DDRC_REG = Direction; break;
    3f42:	e4 e3       	ldi	r30, 0x34	; 52
    3f44:	f0 e0       	ldi	r31, 0x00	; 0
    3f46:	8a 81       	ldd	r24, Y+2	; 0x02
    3f48:	80 83       	st	Z, r24
    3f4a:	04 c0       	rjmp	.+8      	; 0x3f54 <DIO_SetPortDirection+0x154>
				case DIO_PORTD : DDRD_REG = Direction; break;
    3f4c:	e1 e3       	ldi	r30, 0x31	; 49
    3f4e:	f0 e0       	ldi	r31, 0x00	; 0
    3f50:	8a 81       	ldd	r24, Y+2	; 0x02
    3f52:	80 83       	st	Z, r24
	else 
	{
		/* ERROR*/
	}
	
}
    3f54:	28 96       	adiw	r28, 0x08	; 8
    3f56:	0f b6       	in	r0, 0x3f	; 63
    3f58:	f8 94       	cli
    3f5a:	de bf       	out	0x3e, r29	; 62
    3f5c:	0f be       	out	0x3f, r0	; 63
    3f5e:	cd bf       	out	0x3d, r28	; 61
    3f60:	cf 91       	pop	r28
    3f62:	df 91       	pop	r29
    3f64:	08 95       	ret

00003f66 <DIO_SetPinDirection>:
	DIO_voidSetPinDireation(PORTA , PIN1 ,OUTPUT);
	A1 ===> input 				===> 	DDR = 0
*/

void DIO_SetPinDirection(uint_8 PortID , uint_8 PinID,uint_8 Direction)
{
    3f66:	df 93       	push	r29
    3f68:	cf 93       	push	r28
    3f6a:	cd b7       	in	r28, 0x3d	; 61
    3f6c:	de b7       	in	r29, 0x3e	; 62
    3f6e:	27 97       	sbiw	r28, 0x07	; 7
    3f70:	0f b6       	in	r0, 0x3f	; 63
    3f72:	f8 94       	cli
    3f74:	de bf       	out	0x3e, r29	; 62
    3f76:	0f be       	out	0x3f, r0	; 63
    3f78:	cd bf       	out	0x3d, r28	; 61
    3f7a:	89 83       	std	Y+1, r24	; 0x01
    3f7c:	6a 83       	std	Y+2, r22	; 0x02
    3f7e:	4b 83       	std	Y+3, r20	; 0x03
	//Range check
	if (PortID <4 && PinID <8)
    3f80:	89 81       	ldd	r24, Y+1	; 0x01
    3f82:	84 30       	cpi	r24, 0x04	; 4
    3f84:	08 f0       	brcs	.+2      	; 0x3f88 <DIO_SetPinDirection+0x22>
    3f86:	ee c0       	rjmp	.+476    	; 0x4164 <DIO_SetPinDirection+0x1fe>
    3f88:	8a 81       	ldd	r24, Y+2	; 0x02
    3f8a:	88 30       	cpi	r24, 0x08	; 8
    3f8c:	08 f0       	brcs	.+2      	; 0x3f90 <DIO_SetPinDirection+0x2a>
    3f8e:	ea c0       	rjmp	.+468    	; 0x4164 <DIO_SetPinDirection+0x1fe>
	{
		if(Direction==OUTPUT)
    3f90:	8b 81       	ldd	r24, Y+3	; 0x03
    3f92:	81 30       	cpi	r24, 0x01	; 1
    3f94:	09 f0       	breq	.+2      	; 0x3f98 <DIO_SetPinDirection+0x32>
    3f96:	6f c0       	rjmp	.+222    	; 0x4076 <DIO_SetPinDirection+0x110>
			{
				switch(PortID)
    3f98:	89 81       	ldd	r24, Y+1	; 0x01
    3f9a:	28 2f       	mov	r18, r24
    3f9c:	30 e0       	ldi	r19, 0x00	; 0
    3f9e:	3f 83       	std	Y+7, r19	; 0x07
    3fa0:	2e 83       	std	Y+6, r18	; 0x06
    3fa2:	8e 81       	ldd	r24, Y+6	; 0x06
    3fa4:	9f 81       	ldd	r25, Y+7	; 0x07
    3fa6:	81 30       	cpi	r24, 0x01	; 1
    3fa8:	91 05       	cpc	r25, r1
    3faa:	49 f1       	breq	.+82     	; 0x3ffe <DIO_SetPinDirection+0x98>
    3fac:	2e 81       	ldd	r18, Y+6	; 0x06
    3fae:	3f 81       	ldd	r19, Y+7	; 0x07
    3fb0:	22 30       	cpi	r18, 0x02	; 2
    3fb2:	31 05       	cpc	r19, r1
    3fb4:	2c f4       	brge	.+10     	; 0x3fc0 <DIO_SetPinDirection+0x5a>
    3fb6:	8e 81       	ldd	r24, Y+6	; 0x06
    3fb8:	9f 81       	ldd	r25, Y+7	; 0x07
    3fba:	00 97       	sbiw	r24, 0x00	; 0
    3fbc:	61 f0       	breq	.+24     	; 0x3fd6 <DIO_SetPinDirection+0x70>
    3fbe:	d2 c0       	rjmp	.+420    	; 0x4164 <DIO_SetPinDirection+0x1fe>
    3fc0:	2e 81       	ldd	r18, Y+6	; 0x06
    3fc2:	3f 81       	ldd	r19, Y+7	; 0x07
    3fc4:	22 30       	cpi	r18, 0x02	; 2
    3fc6:	31 05       	cpc	r19, r1
    3fc8:	71 f1       	breq	.+92     	; 0x4026 <DIO_SetPinDirection+0xc0>
    3fca:	8e 81       	ldd	r24, Y+6	; 0x06
    3fcc:	9f 81       	ldd	r25, Y+7	; 0x07
    3fce:	83 30       	cpi	r24, 0x03	; 3
    3fd0:	91 05       	cpc	r25, r1
    3fd2:	e9 f1       	breq	.+122    	; 0x404e <DIO_SetPinDirection+0xe8>
    3fd4:	c7 c0       	rjmp	.+398    	; 0x4164 <DIO_SetPinDirection+0x1fe>
				{
					case DIO_PORTA : SET_BIT(DDRA_REG,PinID); break;
    3fd6:	aa e3       	ldi	r26, 0x3A	; 58
    3fd8:	b0 e0       	ldi	r27, 0x00	; 0
    3fda:	ea e3       	ldi	r30, 0x3A	; 58
    3fdc:	f0 e0       	ldi	r31, 0x00	; 0
    3fde:	80 81       	ld	r24, Z
    3fe0:	48 2f       	mov	r20, r24
    3fe2:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe4:	28 2f       	mov	r18, r24
    3fe6:	30 e0       	ldi	r19, 0x00	; 0
    3fe8:	81 e0       	ldi	r24, 0x01	; 1
    3fea:	90 e0       	ldi	r25, 0x00	; 0
    3fec:	02 2e       	mov	r0, r18
    3fee:	02 c0       	rjmp	.+4      	; 0x3ff4 <DIO_SetPinDirection+0x8e>
    3ff0:	88 0f       	add	r24, r24
    3ff2:	99 1f       	adc	r25, r25
    3ff4:	0a 94       	dec	r0
    3ff6:	e2 f7       	brpl	.-8      	; 0x3ff0 <DIO_SetPinDirection+0x8a>
    3ff8:	84 2b       	or	r24, r20
    3ffa:	8c 93       	st	X, r24
    3ffc:	b3 c0       	rjmp	.+358    	; 0x4164 <DIO_SetPinDirection+0x1fe>
					case DIO_PORTB : SET_BIT(DDRB_REG,PinID); break;
    3ffe:	a7 e3       	ldi	r26, 0x37	; 55
    4000:	b0 e0       	ldi	r27, 0x00	; 0
    4002:	e7 e3       	ldi	r30, 0x37	; 55
    4004:	f0 e0       	ldi	r31, 0x00	; 0
    4006:	80 81       	ld	r24, Z
    4008:	48 2f       	mov	r20, r24
    400a:	8a 81       	ldd	r24, Y+2	; 0x02
    400c:	28 2f       	mov	r18, r24
    400e:	30 e0       	ldi	r19, 0x00	; 0
    4010:	81 e0       	ldi	r24, 0x01	; 1
    4012:	90 e0       	ldi	r25, 0x00	; 0
    4014:	02 2e       	mov	r0, r18
    4016:	02 c0       	rjmp	.+4      	; 0x401c <DIO_SetPinDirection+0xb6>
    4018:	88 0f       	add	r24, r24
    401a:	99 1f       	adc	r25, r25
    401c:	0a 94       	dec	r0
    401e:	e2 f7       	brpl	.-8      	; 0x4018 <DIO_SetPinDirection+0xb2>
    4020:	84 2b       	or	r24, r20
    4022:	8c 93       	st	X, r24
    4024:	9f c0       	rjmp	.+318    	; 0x4164 <DIO_SetPinDirection+0x1fe>
					case DIO_PORTC : SET_BIT(DDRC_REG,PinID); break;
    4026:	a4 e3       	ldi	r26, 0x34	; 52
    4028:	b0 e0       	ldi	r27, 0x00	; 0
    402a:	e4 e3       	ldi	r30, 0x34	; 52
    402c:	f0 e0       	ldi	r31, 0x00	; 0
    402e:	80 81       	ld	r24, Z
    4030:	48 2f       	mov	r20, r24
    4032:	8a 81       	ldd	r24, Y+2	; 0x02
    4034:	28 2f       	mov	r18, r24
    4036:	30 e0       	ldi	r19, 0x00	; 0
    4038:	81 e0       	ldi	r24, 0x01	; 1
    403a:	90 e0       	ldi	r25, 0x00	; 0
    403c:	02 2e       	mov	r0, r18
    403e:	02 c0       	rjmp	.+4      	; 0x4044 <DIO_SetPinDirection+0xde>
    4040:	88 0f       	add	r24, r24
    4042:	99 1f       	adc	r25, r25
    4044:	0a 94       	dec	r0
    4046:	e2 f7       	brpl	.-8      	; 0x4040 <DIO_SetPinDirection+0xda>
    4048:	84 2b       	or	r24, r20
    404a:	8c 93       	st	X, r24
    404c:	8b c0       	rjmp	.+278    	; 0x4164 <DIO_SetPinDirection+0x1fe>
					case DIO_PORTD : SET_BIT(DDRD_REG,PinID); break;
    404e:	a1 e3       	ldi	r26, 0x31	; 49
    4050:	b0 e0       	ldi	r27, 0x00	; 0
    4052:	e1 e3       	ldi	r30, 0x31	; 49
    4054:	f0 e0       	ldi	r31, 0x00	; 0
    4056:	80 81       	ld	r24, Z
    4058:	48 2f       	mov	r20, r24
    405a:	8a 81       	ldd	r24, Y+2	; 0x02
    405c:	28 2f       	mov	r18, r24
    405e:	30 e0       	ldi	r19, 0x00	; 0
    4060:	81 e0       	ldi	r24, 0x01	; 1
    4062:	90 e0       	ldi	r25, 0x00	; 0
    4064:	02 2e       	mov	r0, r18
    4066:	02 c0       	rjmp	.+4      	; 0x406c <DIO_SetPinDirection+0x106>
    4068:	88 0f       	add	r24, r24
    406a:	99 1f       	adc	r25, r25
    406c:	0a 94       	dec	r0
    406e:	e2 f7       	brpl	.-8      	; 0x4068 <DIO_SetPinDirection+0x102>
    4070:	84 2b       	or	r24, r20
    4072:	8c 93       	st	X, r24
    4074:	77 c0       	rjmp	.+238    	; 0x4164 <DIO_SetPinDirection+0x1fe>
				}
			}
		else if (Direction==INPUT)
    4076:	8b 81       	ldd	r24, Y+3	; 0x03
    4078:	88 23       	and	r24, r24
    407a:	09 f0       	breq	.+2      	; 0x407e <DIO_SetPinDirection+0x118>
    407c:	73 c0       	rjmp	.+230    	; 0x4164 <DIO_SetPinDirection+0x1fe>
		   {
			   switch(PortID)
    407e:	89 81       	ldd	r24, Y+1	; 0x01
    4080:	28 2f       	mov	r18, r24
    4082:	30 e0       	ldi	r19, 0x00	; 0
    4084:	3d 83       	std	Y+5, r19	; 0x05
    4086:	2c 83       	std	Y+4, r18	; 0x04
    4088:	8c 81       	ldd	r24, Y+4	; 0x04
    408a:	9d 81       	ldd	r25, Y+5	; 0x05
    408c:	81 30       	cpi	r24, 0x01	; 1
    408e:	91 05       	cpc	r25, r1
    4090:	59 f1       	breq	.+86     	; 0x40e8 <DIO_SetPinDirection+0x182>
    4092:	2c 81       	ldd	r18, Y+4	; 0x04
    4094:	3d 81       	ldd	r19, Y+5	; 0x05
    4096:	22 30       	cpi	r18, 0x02	; 2
    4098:	31 05       	cpc	r19, r1
    409a:	2c f4       	brge	.+10     	; 0x40a6 <DIO_SetPinDirection+0x140>
    409c:	8c 81       	ldd	r24, Y+4	; 0x04
    409e:	9d 81       	ldd	r25, Y+5	; 0x05
    40a0:	00 97       	sbiw	r24, 0x00	; 0
    40a2:	69 f0       	breq	.+26     	; 0x40be <DIO_SetPinDirection+0x158>
    40a4:	5f c0       	rjmp	.+190    	; 0x4164 <DIO_SetPinDirection+0x1fe>
    40a6:	2c 81       	ldd	r18, Y+4	; 0x04
    40a8:	3d 81       	ldd	r19, Y+5	; 0x05
    40aa:	22 30       	cpi	r18, 0x02	; 2
    40ac:	31 05       	cpc	r19, r1
    40ae:	89 f1       	breq	.+98     	; 0x4112 <DIO_SetPinDirection+0x1ac>
    40b0:	8c 81       	ldd	r24, Y+4	; 0x04
    40b2:	9d 81       	ldd	r25, Y+5	; 0x05
    40b4:	83 30       	cpi	r24, 0x03	; 3
    40b6:	91 05       	cpc	r25, r1
    40b8:	09 f4       	brne	.+2      	; 0x40bc <DIO_SetPinDirection+0x156>
    40ba:	40 c0       	rjmp	.+128    	; 0x413c <DIO_SetPinDirection+0x1d6>
    40bc:	53 c0       	rjmp	.+166    	; 0x4164 <DIO_SetPinDirection+0x1fe>
				{
					case DIO_PORTA : CLR_BIT(DDRA_REG,PinID); break;
    40be:	aa e3       	ldi	r26, 0x3A	; 58
    40c0:	b0 e0       	ldi	r27, 0x00	; 0
    40c2:	ea e3       	ldi	r30, 0x3A	; 58
    40c4:	f0 e0       	ldi	r31, 0x00	; 0
    40c6:	80 81       	ld	r24, Z
    40c8:	48 2f       	mov	r20, r24
    40ca:	8a 81       	ldd	r24, Y+2	; 0x02
    40cc:	28 2f       	mov	r18, r24
    40ce:	30 e0       	ldi	r19, 0x00	; 0
    40d0:	81 e0       	ldi	r24, 0x01	; 1
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	02 2e       	mov	r0, r18
    40d6:	02 c0       	rjmp	.+4      	; 0x40dc <DIO_SetPinDirection+0x176>
    40d8:	88 0f       	add	r24, r24
    40da:	99 1f       	adc	r25, r25
    40dc:	0a 94       	dec	r0
    40de:	e2 f7       	brpl	.-8      	; 0x40d8 <DIO_SetPinDirection+0x172>
    40e0:	80 95       	com	r24
    40e2:	84 23       	and	r24, r20
    40e4:	8c 93       	st	X, r24
    40e6:	3e c0       	rjmp	.+124    	; 0x4164 <DIO_SetPinDirection+0x1fe>
					case DIO_PORTB : CLR_BIT(DDRB_REG,PinID); break;
    40e8:	a7 e3       	ldi	r26, 0x37	; 55
    40ea:	b0 e0       	ldi	r27, 0x00	; 0
    40ec:	e7 e3       	ldi	r30, 0x37	; 55
    40ee:	f0 e0       	ldi	r31, 0x00	; 0
    40f0:	80 81       	ld	r24, Z
    40f2:	48 2f       	mov	r20, r24
    40f4:	8a 81       	ldd	r24, Y+2	; 0x02
    40f6:	28 2f       	mov	r18, r24
    40f8:	30 e0       	ldi	r19, 0x00	; 0
    40fa:	81 e0       	ldi	r24, 0x01	; 1
    40fc:	90 e0       	ldi	r25, 0x00	; 0
    40fe:	02 2e       	mov	r0, r18
    4100:	02 c0       	rjmp	.+4      	; 0x4106 <DIO_SetPinDirection+0x1a0>
    4102:	88 0f       	add	r24, r24
    4104:	99 1f       	adc	r25, r25
    4106:	0a 94       	dec	r0
    4108:	e2 f7       	brpl	.-8      	; 0x4102 <DIO_SetPinDirection+0x19c>
    410a:	80 95       	com	r24
    410c:	84 23       	and	r24, r20
    410e:	8c 93       	st	X, r24
    4110:	29 c0       	rjmp	.+82     	; 0x4164 <DIO_SetPinDirection+0x1fe>
					case DIO_PORTC : CLR_BIT(DDRC_REG,PinID); break;
    4112:	a4 e3       	ldi	r26, 0x34	; 52
    4114:	b0 e0       	ldi	r27, 0x00	; 0
    4116:	e4 e3       	ldi	r30, 0x34	; 52
    4118:	f0 e0       	ldi	r31, 0x00	; 0
    411a:	80 81       	ld	r24, Z
    411c:	48 2f       	mov	r20, r24
    411e:	8a 81       	ldd	r24, Y+2	; 0x02
    4120:	28 2f       	mov	r18, r24
    4122:	30 e0       	ldi	r19, 0x00	; 0
    4124:	81 e0       	ldi	r24, 0x01	; 1
    4126:	90 e0       	ldi	r25, 0x00	; 0
    4128:	02 2e       	mov	r0, r18
    412a:	02 c0       	rjmp	.+4      	; 0x4130 <DIO_SetPinDirection+0x1ca>
    412c:	88 0f       	add	r24, r24
    412e:	99 1f       	adc	r25, r25
    4130:	0a 94       	dec	r0
    4132:	e2 f7       	brpl	.-8      	; 0x412c <DIO_SetPinDirection+0x1c6>
    4134:	80 95       	com	r24
    4136:	84 23       	and	r24, r20
    4138:	8c 93       	st	X, r24
    413a:	14 c0       	rjmp	.+40     	; 0x4164 <DIO_SetPinDirection+0x1fe>
					case DIO_PORTD : CLR_BIT(DDRD_REG,PinID); break;
    413c:	a1 e3       	ldi	r26, 0x31	; 49
    413e:	b0 e0       	ldi	r27, 0x00	; 0
    4140:	e1 e3       	ldi	r30, 0x31	; 49
    4142:	f0 e0       	ldi	r31, 0x00	; 0
    4144:	80 81       	ld	r24, Z
    4146:	48 2f       	mov	r20, r24
    4148:	8a 81       	ldd	r24, Y+2	; 0x02
    414a:	28 2f       	mov	r18, r24
    414c:	30 e0       	ldi	r19, 0x00	; 0
    414e:	81 e0       	ldi	r24, 0x01	; 1
    4150:	90 e0       	ldi	r25, 0x00	; 0
    4152:	02 2e       	mov	r0, r18
    4154:	02 c0       	rjmp	.+4      	; 0x415a <DIO_SetPinDirection+0x1f4>
    4156:	88 0f       	add	r24, r24
    4158:	99 1f       	adc	r25, r25
    415a:	0a 94       	dec	r0
    415c:	e2 f7       	brpl	.-8      	; 0x4156 <DIO_SetPinDirection+0x1f0>
    415e:	80 95       	com	r24
    4160:	84 23       	and	r24, r20
    4162:	8c 93       	st	X, r24
	else 
	{
		/* ERROR*/
	}
	
}
    4164:	27 96       	adiw	r28, 0x07	; 7
    4166:	0f b6       	in	r0, 0x3f	; 63
    4168:	f8 94       	cli
    416a:	de bf       	out	0x3e, r29	; 62
    416c:	0f be       	out	0x3f, r0	; 63
    416e:	cd bf       	out	0x3d, r28	; 61
    4170:	cf 91       	pop	r28
    4172:	df 91       	pop	r29
    4174:	08 95       	ret

00004176 <DIO_SetPortValue>:

/* ############################# SET Port VALUE ################################## 
*/
void DIO_SetPortValue(uint_8 PortID ,uint_8 Value)
{
    4176:	df 93       	push	r29
    4178:	cf 93       	push	r28
    417a:	cd b7       	in	r28, 0x3d	; 61
    417c:	de b7       	in	r29, 0x3e	; 62
    417e:	28 97       	sbiw	r28, 0x08	; 8
    4180:	0f b6       	in	r0, 0x3f	; 63
    4182:	f8 94       	cli
    4184:	de bf       	out	0x3e, r29	; 62
    4186:	0f be       	out	0x3f, r0	; 63
    4188:	cd bf       	out	0x3d, r28	; 61
    418a:	89 83       	std	Y+1, r24	; 0x01
    418c:	6a 83       	std	Y+2, r22	; 0x02
	/* Range check*/
	if (PortID <4)
    418e:	89 81       	ldd	r24, Y+1	; 0x01
    4190:	84 30       	cpi	r24, 0x04	; 4
    4192:	08 f0       	brcs	.+2      	; 0x4196 <DIO_SetPortValue+0x20>
    4194:	9a c0       	rjmp	.+308    	; 0x42ca <DIO_SetPortValue+0x154>
	{
		if (Value == HIGH)
    4196:	8a 81       	ldd	r24, Y+2	; 0x02
    4198:	81 30       	cpi	r24, 0x01	; 1
    419a:	99 f5       	brne	.+102    	; 0x4202 <DIO_SetPortValue+0x8c>
		{
			switch (PortID)
    419c:	89 81       	ldd	r24, Y+1	; 0x01
    419e:	28 2f       	mov	r18, r24
    41a0:	30 e0       	ldi	r19, 0x00	; 0
    41a2:	38 87       	std	Y+8, r19	; 0x08
    41a4:	2f 83       	std	Y+7, r18	; 0x07
    41a6:	8f 81       	ldd	r24, Y+7	; 0x07
    41a8:	98 85       	ldd	r25, Y+8	; 0x08
    41aa:	81 30       	cpi	r24, 0x01	; 1
    41ac:	91 05       	cpc	r25, r1
    41ae:	d1 f0       	breq	.+52     	; 0x41e4 <DIO_SetPortValue+0x6e>
    41b0:	2f 81       	ldd	r18, Y+7	; 0x07
    41b2:	38 85       	ldd	r19, Y+8	; 0x08
    41b4:	22 30       	cpi	r18, 0x02	; 2
    41b6:	31 05       	cpc	r19, r1
    41b8:	2c f4       	brge	.+10     	; 0x41c4 <DIO_SetPortValue+0x4e>
    41ba:	8f 81       	ldd	r24, Y+7	; 0x07
    41bc:	98 85       	ldd	r25, Y+8	; 0x08
    41be:	00 97       	sbiw	r24, 0x00	; 0
    41c0:	61 f0       	breq	.+24     	; 0x41da <DIO_SetPortValue+0x64>
    41c2:	83 c0       	rjmp	.+262    	; 0x42ca <DIO_SetPortValue+0x154>
    41c4:	2f 81       	ldd	r18, Y+7	; 0x07
    41c6:	38 85       	ldd	r19, Y+8	; 0x08
    41c8:	22 30       	cpi	r18, 0x02	; 2
    41ca:	31 05       	cpc	r19, r1
    41cc:	81 f0       	breq	.+32     	; 0x41ee <DIO_SetPortValue+0x78>
    41ce:	8f 81       	ldd	r24, Y+7	; 0x07
    41d0:	98 85       	ldd	r25, Y+8	; 0x08
    41d2:	83 30       	cpi	r24, 0x03	; 3
    41d4:	91 05       	cpc	r25, r1
    41d6:	81 f0       	breq	.+32     	; 0x41f8 <DIO_SetPortValue+0x82>
    41d8:	78 c0       	rjmp	.+240    	; 0x42ca <DIO_SetPortValue+0x154>
			{
				case DIO_PORTA : PORTA_REG = 0xFF; break;
    41da:	eb e3       	ldi	r30, 0x3B	; 59
    41dc:	f0 e0       	ldi	r31, 0x00	; 0
    41de:	8f ef       	ldi	r24, 0xFF	; 255
    41e0:	80 83       	st	Z, r24
    41e2:	73 c0       	rjmp	.+230    	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTB : PORTB_REG = 0xFF; break;
    41e4:	e8 e3       	ldi	r30, 0x38	; 56
    41e6:	f0 e0       	ldi	r31, 0x00	; 0
    41e8:	8f ef       	ldi	r24, 0xFF	; 255
    41ea:	80 83       	st	Z, r24
    41ec:	6e c0       	rjmp	.+220    	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTC : PORTC_REG = 0xFF; break;
    41ee:	e5 e3       	ldi	r30, 0x35	; 53
    41f0:	f0 e0       	ldi	r31, 0x00	; 0
    41f2:	8f ef       	ldi	r24, 0xFF	; 255
    41f4:	80 83       	st	Z, r24
    41f6:	69 c0       	rjmp	.+210    	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTD : PORTD_REG = 0xFF; break;
    41f8:	e2 e3       	ldi	r30, 0x32	; 50
    41fa:	f0 e0       	ldi	r31, 0x00	; 0
    41fc:	8f ef       	ldi	r24, 0xFF	; 255
    41fe:	80 83       	st	Z, r24
    4200:	64 c0       	rjmp	.+200    	; 0x42ca <DIO_SetPortValue+0x154>
			}	
		}
		else if (Value == LOW)
    4202:	8a 81       	ldd	r24, Y+2	; 0x02
    4204:	88 23       	and	r24, r24
    4206:	79 f5       	brne	.+94     	; 0x4266 <DIO_SetPortValue+0xf0>
		{
			switch (PortID)
    4208:	89 81       	ldd	r24, Y+1	; 0x01
    420a:	28 2f       	mov	r18, r24
    420c:	30 e0       	ldi	r19, 0x00	; 0
    420e:	3e 83       	std	Y+6, r19	; 0x06
    4210:	2d 83       	std	Y+5, r18	; 0x05
    4212:	8d 81       	ldd	r24, Y+5	; 0x05
    4214:	9e 81       	ldd	r25, Y+6	; 0x06
    4216:	81 30       	cpi	r24, 0x01	; 1
    4218:	91 05       	cpc	r25, r1
    421a:	c9 f0       	breq	.+50     	; 0x424e <DIO_SetPortValue+0xd8>
    421c:	2d 81       	ldd	r18, Y+5	; 0x05
    421e:	3e 81       	ldd	r19, Y+6	; 0x06
    4220:	22 30       	cpi	r18, 0x02	; 2
    4222:	31 05       	cpc	r19, r1
    4224:	2c f4       	brge	.+10     	; 0x4230 <DIO_SetPortValue+0xba>
    4226:	8d 81       	ldd	r24, Y+5	; 0x05
    4228:	9e 81       	ldd	r25, Y+6	; 0x06
    422a:	00 97       	sbiw	r24, 0x00	; 0
    422c:	61 f0       	breq	.+24     	; 0x4246 <DIO_SetPortValue+0xd0>
    422e:	4d c0       	rjmp	.+154    	; 0x42ca <DIO_SetPortValue+0x154>
    4230:	2d 81       	ldd	r18, Y+5	; 0x05
    4232:	3e 81       	ldd	r19, Y+6	; 0x06
    4234:	22 30       	cpi	r18, 0x02	; 2
    4236:	31 05       	cpc	r19, r1
    4238:	71 f0       	breq	.+28     	; 0x4256 <DIO_SetPortValue+0xe0>
    423a:	8d 81       	ldd	r24, Y+5	; 0x05
    423c:	9e 81       	ldd	r25, Y+6	; 0x06
    423e:	83 30       	cpi	r24, 0x03	; 3
    4240:	91 05       	cpc	r25, r1
    4242:	69 f0       	breq	.+26     	; 0x425e <DIO_SetPortValue+0xe8>
    4244:	42 c0       	rjmp	.+132    	; 0x42ca <DIO_SetPortValue+0x154>
			{
				case DIO_PORTA : PORTA_REG = 0x00; break;
    4246:	eb e3       	ldi	r30, 0x3B	; 59
    4248:	f0 e0       	ldi	r31, 0x00	; 0
    424a:	10 82       	st	Z, r1
    424c:	3e c0       	rjmp	.+124    	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTB : PORTB_REG = 0x00; break;
    424e:	e8 e3       	ldi	r30, 0x38	; 56
    4250:	f0 e0       	ldi	r31, 0x00	; 0
    4252:	10 82       	st	Z, r1
    4254:	3a c0       	rjmp	.+116    	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTC : PORTC_REG = 0x00; break;
    4256:	e5 e3       	ldi	r30, 0x35	; 53
    4258:	f0 e0       	ldi	r31, 0x00	; 0
    425a:	10 82       	st	Z, r1
    425c:	36 c0       	rjmp	.+108    	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTD : PORTD_REG = 0x00; break;
    425e:	e2 e3       	ldi	r30, 0x32	; 50
    4260:	f0 e0       	ldi	r31, 0x00	; 0
    4262:	10 82       	st	Z, r1
    4264:	32 c0       	rjmp	.+100    	; 0x42ca <DIO_SetPortValue+0x154>
		}
		else 
		{
			/*  set port value to the value inserted  
		       DIO_SetPortValue(PORTA_REG ,0b 1010101010)	 set any value as you like */
			switch (PortID)
    4266:	89 81       	ldd	r24, Y+1	; 0x01
    4268:	28 2f       	mov	r18, r24
    426a:	30 e0       	ldi	r19, 0x00	; 0
    426c:	3c 83       	std	Y+4, r19	; 0x04
    426e:	2b 83       	std	Y+3, r18	; 0x03
    4270:	8b 81       	ldd	r24, Y+3	; 0x03
    4272:	9c 81       	ldd	r25, Y+4	; 0x04
    4274:	81 30       	cpi	r24, 0x01	; 1
    4276:	91 05       	cpc	r25, r1
    4278:	d1 f0       	breq	.+52     	; 0x42ae <DIO_SetPortValue+0x138>
    427a:	2b 81       	ldd	r18, Y+3	; 0x03
    427c:	3c 81       	ldd	r19, Y+4	; 0x04
    427e:	22 30       	cpi	r18, 0x02	; 2
    4280:	31 05       	cpc	r19, r1
    4282:	2c f4       	brge	.+10     	; 0x428e <DIO_SetPortValue+0x118>
    4284:	8b 81       	ldd	r24, Y+3	; 0x03
    4286:	9c 81       	ldd	r25, Y+4	; 0x04
    4288:	00 97       	sbiw	r24, 0x00	; 0
    428a:	61 f0       	breq	.+24     	; 0x42a4 <DIO_SetPortValue+0x12e>
    428c:	1e c0       	rjmp	.+60     	; 0x42ca <DIO_SetPortValue+0x154>
    428e:	2b 81       	ldd	r18, Y+3	; 0x03
    4290:	3c 81       	ldd	r19, Y+4	; 0x04
    4292:	22 30       	cpi	r18, 0x02	; 2
    4294:	31 05       	cpc	r19, r1
    4296:	81 f0       	breq	.+32     	; 0x42b8 <DIO_SetPortValue+0x142>
    4298:	8b 81       	ldd	r24, Y+3	; 0x03
    429a:	9c 81       	ldd	r25, Y+4	; 0x04
    429c:	83 30       	cpi	r24, 0x03	; 3
    429e:	91 05       	cpc	r25, r1
    42a0:	81 f0       	breq	.+32     	; 0x42c2 <DIO_SetPortValue+0x14c>
    42a2:	13 c0       	rjmp	.+38     	; 0x42ca <DIO_SetPortValue+0x154>
			{
				case DIO_PORTA : PORTA_REG = Value; break;
    42a4:	eb e3       	ldi	r30, 0x3B	; 59
    42a6:	f0 e0       	ldi	r31, 0x00	; 0
    42a8:	8a 81       	ldd	r24, Y+2	; 0x02
    42aa:	80 83       	st	Z, r24
    42ac:	0e c0       	rjmp	.+28     	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTB : PORTB_REG = Value; break;
    42ae:	e8 e3       	ldi	r30, 0x38	; 56
    42b0:	f0 e0       	ldi	r31, 0x00	; 0
    42b2:	8a 81       	ldd	r24, Y+2	; 0x02
    42b4:	80 83       	st	Z, r24
    42b6:	09 c0       	rjmp	.+18     	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTC : PORTC_REG = Value; break;
    42b8:	e5 e3       	ldi	r30, 0x35	; 53
    42ba:	f0 e0       	ldi	r31, 0x00	; 0
    42bc:	8a 81       	ldd	r24, Y+2	; 0x02
    42be:	80 83       	st	Z, r24
    42c0:	04 c0       	rjmp	.+8      	; 0x42ca <DIO_SetPortValue+0x154>
				case DIO_PORTD : PORTD_REG = Value; break;
    42c2:	e2 e3       	ldi	r30, 0x32	; 50
    42c4:	f0 e0       	ldi	r31, 0x00	; 0
    42c6:	8a 81       	ldd	r24, Y+2	; 0x02
    42c8:	80 83       	st	Z, r24
	else 
	{
		/*           */
	
	}
}
    42ca:	28 96       	adiw	r28, 0x08	; 8
    42cc:	0f b6       	in	r0, 0x3f	; 63
    42ce:	f8 94       	cli
    42d0:	de bf       	out	0x3e, r29	; 62
    42d2:	0f be       	out	0x3f, r0	; 63
    42d4:	cd bf       	out	0x3d, r28	; 61
    42d6:	cf 91       	pop	r28
    42d8:	df 91       	pop	r29
    42da:	08 95       	ret

000042dc <DIO_SetPinValue>:

/* ############################# SET BIT VALUE ################################## 
*/
void DIO_SetPinValue(uint_8 PortID , uint_8 PinID,uint_8 Value)
{
    42dc:	df 93       	push	r29
    42de:	cf 93       	push	r28
    42e0:	cd b7       	in	r28, 0x3d	; 61
    42e2:	de b7       	in	r29, 0x3e	; 62
    42e4:	27 97       	sbiw	r28, 0x07	; 7
    42e6:	0f b6       	in	r0, 0x3f	; 63
    42e8:	f8 94       	cli
    42ea:	de bf       	out	0x3e, r29	; 62
    42ec:	0f be       	out	0x3f, r0	; 63
    42ee:	cd bf       	out	0x3d, r28	; 61
    42f0:	89 83       	std	Y+1, r24	; 0x01
    42f2:	6a 83       	std	Y+2, r22	; 0x02
    42f4:	4b 83       	std	Y+3, r20	; 0x03
	/* Range check*/
	if (PortID <4 && PinID <8)
    42f6:	89 81       	ldd	r24, Y+1	; 0x01
    42f8:	84 30       	cpi	r24, 0x04	; 4
    42fa:	08 f0       	brcs	.+2      	; 0x42fe <DIO_SetPinValue+0x22>
    42fc:	ee c0       	rjmp	.+476    	; 0x44da <DIO_SetPinValue+0x1fe>
    42fe:	8a 81       	ldd	r24, Y+2	; 0x02
    4300:	88 30       	cpi	r24, 0x08	; 8
    4302:	08 f0       	brcs	.+2      	; 0x4306 <DIO_SetPinValue+0x2a>
    4304:	ea c0       	rjmp	.+468    	; 0x44da <DIO_SetPinValue+0x1fe>
	{
		if (Value == HIGH)
    4306:	8b 81       	ldd	r24, Y+3	; 0x03
    4308:	81 30       	cpi	r24, 0x01	; 1
    430a:	09 f0       	breq	.+2      	; 0x430e <DIO_SetPinValue+0x32>
    430c:	6f c0       	rjmp	.+222    	; 0x43ec <DIO_SetPinValue+0x110>
		{
			switch (PortID)
    430e:	89 81       	ldd	r24, Y+1	; 0x01
    4310:	28 2f       	mov	r18, r24
    4312:	30 e0       	ldi	r19, 0x00	; 0
    4314:	3f 83       	std	Y+7, r19	; 0x07
    4316:	2e 83       	std	Y+6, r18	; 0x06
    4318:	8e 81       	ldd	r24, Y+6	; 0x06
    431a:	9f 81       	ldd	r25, Y+7	; 0x07
    431c:	81 30       	cpi	r24, 0x01	; 1
    431e:	91 05       	cpc	r25, r1
    4320:	49 f1       	breq	.+82     	; 0x4374 <DIO_SetPinValue+0x98>
    4322:	2e 81       	ldd	r18, Y+6	; 0x06
    4324:	3f 81       	ldd	r19, Y+7	; 0x07
    4326:	22 30       	cpi	r18, 0x02	; 2
    4328:	31 05       	cpc	r19, r1
    432a:	2c f4       	brge	.+10     	; 0x4336 <DIO_SetPinValue+0x5a>
    432c:	8e 81       	ldd	r24, Y+6	; 0x06
    432e:	9f 81       	ldd	r25, Y+7	; 0x07
    4330:	00 97       	sbiw	r24, 0x00	; 0
    4332:	61 f0       	breq	.+24     	; 0x434c <DIO_SetPinValue+0x70>
    4334:	d2 c0       	rjmp	.+420    	; 0x44da <DIO_SetPinValue+0x1fe>
    4336:	2e 81       	ldd	r18, Y+6	; 0x06
    4338:	3f 81       	ldd	r19, Y+7	; 0x07
    433a:	22 30       	cpi	r18, 0x02	; 2
    433c:	31 05       	cpc	r19, r1
    433e:	71 f1       	breq	.+92     	; 0x439c <DIO_SetPinValue+0xc0>
    4340:	8e 81       	ldd	r24, Y+6	; 0x06
    4342:	9f 81       	ldd	r25, Y+7	; 0x07
    4344:	83 30       	cpi	r24, 0x03	; 3
    4346:	91 05       	cpc	r25, r1
    4348:	e9 f1       	breq	.+122    	; 0x43c4 <DIO_SetPinValue+0xe8>
    434a:	c7 c0       	rjmp	.+398    	; 0x44da <DIO_SetPinValue+0x1fe>
			{
				case DIO_PORTA : SET_BIT(PORTA_REG,PinID); break;
    434c:	ab e3       	ldi	r26, 0x3B	; 59
    434e:	b0 e0       	ldi	r27, 0x00	; 0
    4350:	eb e3       	ldi	r30, 0x3B	; 59
    4352:	f0 e0       	ldi	r31, 0x00	; 0
    4354:	80 81       	ld	r24, Z
    4356:	48 2f       	mov	r20, r24
    4358:	8a 81       	ldd	r24, Y+2	; 0x02
    435a:	28 2f       	mov	r18, r24
    435c:	30 e0       	ldi	r19, 0x00	; 0
    435e:	81 e0       	ldi	r24, 0x01	; 1
    4360:	90 e0       	ldi	r25, 0x00	; 0
    4362:	02 2e       	mov	r0, r18
    4364:	02 c0       	rjmp	.+4      	; 0x436a <DIO_SetPinValue+0x8e>
    4366:	88 0f       	add	r24, r24
    4368:	99 1f       	adc	r25, r25
    436a:	0a 94       	dec	r0
    436c:	e2 f7       	brpl	.-8      	; 0x4366 <DIO_SetPinValue+0x8a>
    436e:	84 2b       	or	r24, r20
    4370:	8c 93       	st	X, r24
    4372:	b3 c0       	rjmp	.+358    	; 0x44da <DIO_SetPinValue+0x1fe>
				case DIO_PORTB : SET_BIT(PORTB_REG,PinID); break;
    4374:	a8 e3       	ldi	r26, 0x38	; 56
    4376:	b0 e0       	ldi	r27, 0x00	; 0
    4378:	e8 e3       	ldi	r30, 0x38	; 56
    437a:	f0 e0       	ldi	r31, 0x00	; 0
    437c:	80 81       	ld	r24, Z
    437e:	48 2f       	mov	r20, r24
    4380:	8a 81       	ldd	r24, Y+2	; 0x02
    4382:	28 2f       	mov	r18, r24
    4384:	30 e0       	ldi	r19, 0x00	; 0
    4386:	81 e0       	ldi	r24, 0x01	; 1
    4388:	90 e0       	ldi	r25, 0x00	; 0
    438a:	02 2e       	mov	r0, r18
    438c:	02 c0       	rjmp	.+4      	; 0x4392 <DIO_SetPinValue+0xb6>
    438e:	88 0f       	add	r24, r24
    4390:	99 1f       	adc	r25, r25
    4392:	0a 94       	dec	r0
    4394:	e2 f7       	brpl	.-8      	; 0x438e <DIO_SetPinValue+0xb2>
    4396:	84 2b       	or	r24, r20
    4398:	8c 93       	st	X, r24
    439a:	9f c0       	rjmp	.+318    	; 0x44da <DIO_SetPinValue+0x1fe>
				case DIO_PORTC : SET_BIT(PORTC_REG,PinID); break;
    439c:	a5 e3       	ldi	r26, 0x35	; 53
    439e:	b0 e0       	ldi	r27, 0x00	; 0
    43a0:	e5 e3       	ldi	r30, 0x35	; 53
    43a2:	f0 e0       	ldi	r31, 0x00	; 0
    43a4:	80 81       	ld	r24, Z
    43a6:	48 2f       	mov	r20, r24
    43a8:	8a 81       	ldd	r24, Y+2	; 0x02
    43aa:	28 2f       	mov	r18, r24
    43ac:	30 e0       	ldi	r19, 0x00	; 0
    43ae:	81 e0       	ldi	r24, 0x01	; 1
    43b0:	90 e0       	ldi	r25, 0x00	; 0
    43b2:	02 2e       	mov	r0, r18
    43b4:	02 c0       	rjmp	.+4      	; 0x43ba <DIO_SetPinValue+0xde>
    43b6:	88 0f       	add	r24, r24
    43b8:	99 1f       	adc	r25, r25
    43ba:	0a 94       	dec	r0
    43bc:	e2 f7       	brpl	.-8      	; 0x43b6 <DIO_SetPinValue+0xda>
    43be:	84 2b       	or	r24, r20
    43c0:	8c 93       	st	X, r24
    43c2:	8b c0       	rjmp	.+278    	; 0x44da <DIO_SetPinValue+0x1fe>
				case DIO_PORTD : SET_BIT(PORTD_REG,PinID); break;
    43c4:	a2 e3       	ldi	r26, 0x32	; 50
    43c6:	b0 e0       	ldi	r27, 0x00	; 0
    43c8:	e2 e3       	ldi	r30, 0x32	; 50
    43ca:	f0 e0       	ldi	r31, 0x00	; 0
    43cc:	80 81       	ld	r24, Z
    43ce:	48 2f       	mov	r20, r24
    43d0:	8a 81       	ldd	r24, Y+2	; 0x02
    43d2:	28 2f       	mov	r18, r24
    43d4:	30 e0       	ldi	r19, 0x00	; 0
    43d6:	81 e0       	ldi	r24, 0x01	; 1
    43d8:	90 e0       	ldi	r25, 0x00	; 0
    43da:	02 2e       	mov	r0, r18
    43dc:	02 c0       	rjmp	.+4      	; 0x43e2 <DIO_SetPinValue+0x106>
    43de:	88 0f       	add	r24, r24
    43e0:	99 1f       	adc	r25, r25
    43e2:	0a 94       	dec	r0
    43e4:	e2 f7       	brpl	.-8      	; 0x43de <DIO_SetPinValue+0x102>
    43e6:	84 2b       	or	r24, r20
    43e8:	8c 93       	st	X, r24
    43ea:	77 c0       	rjmp	.+238    	; 0x44da <DIO_SetPinValue+0x1fe>
			}	
		}
		else if (Value == LOW)
    43ec:	8b 81       	ldd	r24, Y+3	; 0x03
    43ee:	88 23       	and	r24, r24
    43f0:	09 f0       	breq	.+2      	; 0x43f4 <DIO_SetPinValue+0x118>
    43f2:	73 c0       	rjmp	.+230    	; 0x44da <DIO_SetPinValue+0x1fe>
		{
			switch (PortID)
    43f4:	89 81       	ldd	r24, Y+1	; 0x01
    43f6:	28 2f       	mov	r18, r24
    43f8:	30 e0       	ldi	r19, 0x00	; 0
    43fa:	3d 83       	std	Y+5, r19	; 0x05
    43fc:	2c 83       	std	Y+4, r18	; 0x04
    43fe:	8c 81       	ldd	r24, Y+4	; 0x04
    4400:	9d 81       	ldd	r25, Y+5	; 0x05
    4402:	81 30       	cpi	r24, 0x01	; 1
    4404:	91 05       	cpc	r25, r1
    4406:	59 f1       	breq	.+86     	; 0x445e <DIO_SetPinValue+0x182>
    4408:	2c 81       	ldd	r18, Y+4	; 0x04
    440a:	3d 81       	ldd	r19, Y+5	; 0x05
    440c:	22 30       	cpi	r18, 0x02	; 2
    440e:	31 05       	cpc	r19, r1
    4410:	2c f4       	brge	.+10     	; 0x441c <DIO_SetPinValue+0x140>
    4412:	8c 81       	ldd	r24, Y+4	; 0x04
    4414:	9d 81       	ldd	r25, Y+5	; 0x05
    4416:	00 97       	sbiw	r24, 0x00	; 0
    4418:	69 f0       	breq	.+26     	; 0x4434 <DIO_SetPinValue+0x158>
    441a:	5f c0       	rjmp	.+190    	; 0x44da <DIO_SetPinValue+0x1fe>
    441c:	2c 81       	ldd	r18, Y+4	; 0x04
    441e:	3d 81       	ldd	r19, Y+5	; 0x05
    4420:	22 30       	cpi	r18, 0x02	; 2
    4422:	31 05       	cpc	r19, r1
    4424:	89 f1       	breq	.+98     	; 0x4488 <DIO_SetPinValue+0x1ac>
    4426:	8c 81       	ldd	r24, Y+4	; 0x04
    4428:	9d 81       	ldd	r25, Y+5	; 0x05
    442a:	83 30       	cpi	r24, 0x03	; 3
    442c:	91 05       	cpc	r25, r1
    442e:	09 f4       	brne	.+2      	; 0x4432 <DIO_SetPinValue+0x156>
    4430:	40 c0       	rjmp	.+128    	; 0x44b2 <DIO_SetPinValue+0x1d6>
    4432:	53 c0       	rjmp	.+166    	; 0x44da <DIO_SetPinValue+0x1fe>
			{
				case DIO_PORTA : CLR_BIT(PORTA_REG,PinID); break;
    4434:	ab e3       	ldi	r26, 0x3B	; 59
    4436:	b0 e0       	ldi	r27, 0x00	; 0
    4438:	eb e3       	ldi	r30, 0x3B	; 59
    443a:	f0 e0       	ldi	r31, 0x00	; 0
    443c:	80 81       	ld	r24, Z
    443e:	48 2f       	mov	r20, r24
    4440:	8a 81       	ldd	r24, Y+2	; 0x02
    4442:	28 2f       	mov	r18, r24
    4444:	30 e0       	ldi	r19, 0x00	; 0
    4446:	81 e0       	ldi	r24, 0x01	; 1
    4448:	90 e0       	ldi	r25, 0x00	; 0
    444a:	02 2e       	mov	r0, r18
    444c:	02 c0       	rjmp	.+4      	; 0x4452 <DIO_SetPinValue+0x176>
    444e:	88 0f       	add	r24, r24
    4450:	99 1f       	adc	r25, r25
    4452:	0a 94       	dec	r0
    4454:	e2 f7       	brpl	.-8      	; 0x444e <DIO_SetPinValue+0x172>
    4456:	80 95       	com	r24
    4458:	84 23       	and	r24, r20
    445a:	8c 93       	st	X, r24
    445c:	3e c0       	rjmp	.+124    	; 0x44da <DIO_SetPinValue+0x1fe>
				case DIO_PORTB : CLR_BIT(PORTB_REG,PinID); break;
    445e:	a8 e3       	ldi	r26, 0x38	; 56
    4460:	b0 e0       	ldi	r27, 0x00	; 0
    4462:	e8 e3       	ldi	r30, 0x38	; 56
    4464:	f0 e0       	ldi	r31, 0x00	; 0
    4466:	80 81       	ld	r24, Z
    4468:	48 2f       	mov	r20, r24
    446a:	8a 81       	ldd	r24, Y+2	; 0x02
    446c:	28 2f       	mov	r18, r24
    446e:	30 e0       	ldi	r19, 0x00	; 0
    4470:	81 e0       	ldi	r24, 0x01	; 1
    4472:	90 e0       	ldi	r25, 0x00	; 0
    4474:	02 2e       	mov	r0, r18
    4476:	02 c0       	rjmp	.+4      	; 0x447c <DIO_SetPinValue+0x1a0>
    4478:	88 0f       	add	r24, r24
    447a:	99 1f       	adc	r25, r25
    447c:	0a 94       	dec	r0
    447e:	e2 f7       	brpl	.-8      	; 0x4478 <DIO_SetPinValue+0x19c>
    4480:	80 95       	com	r24
    4482:	84 23       	and	r24, r20
    4484:	8c 93       	st	X, r24
    4486:	29 c0       	rjmp	.+82     	; 0x44da <DIO_SetPinValue+0x1fe>
				case DIO_PORTC : CLR_BIT(PORTC_REG,PinID); break;
    4488:	a5 e3       	ldi	r26, 0x35	; 53
    448a:	b0 e0       	ldi	r27, 0x00	; 0
    448c:	e5 e3       	ldi	r30, 0x35	; 53
    448e:	f0 e0       	ldi	r31, 0x00	; 0
    4490:	80 81       	ld	r24, Z
    4492:	48 2f       	mov	r20, r24
    4494:	8a 81       	ldd	r24, Y+2	; 0x02
    4496:	28 2f       	mov	r18, r24
    4498:	30 e0       	ldi	r19, 0x00	; 0
    449a:	81 e0       	ldi	r24, 0x01	; 1
    449c:	90 e0       	ldi	r25, 0x00	; 0
    449e:	02 2e       	mov	r0, r18
    44a0:	02 c0       	rjmp	.+4      	; 0x44a6 <DIO_SetPinValue+0x1ca>
    44a2:	88 0f       	add	r24, r24
    44a4:	99 1f       	adc	r25, r25
    44a6:	0a 94       	dec	r0
    44a8:	e2 f7       	brpl	.-8      	; 0x44a2 <DIO_SetPinValue+0x1c6>
    44aa:	80 95       	com	r24
    44ac:	84 23       	and	r24, r20
    44ae:	8c 93       	st	X, r24
    44b0:	14 c0       	rjmp	.+40     	; 0x44da <DIO_SetPinValue+0x1fe>
				case DIO_PORTD : CLR_BIT(PORTD_REG,PinID); break;
    44b2:	a2 e3       	ldi	r26, 0x32	; 50
    44b4:	b0 e0       	ldi	r27, 0x00	; 0
    44b6:	e2 e3       	ldi	r30, 0x32	; 50
    44b8:	f0 e0       	ldi	r31, 0x00	; 0
    44ba:	80 81       	ld	r24, Z
    44bc:	48 2f       	mov	r20, r24
    44be:	8a 81       	ldd	r24, Y+2	; 0x02
    44c0:	28 2f       	mov	r18, r24
    44c2:	30 e0       	ldi	r19, 0x00	; 0
    44c4:	81 e0       	ldi	r24, 0x01	; 1
    44c6:	90 e0       	ldi	r25, 0x00	; 0
    44c8:	02 2e       	mov	r0, r18
    44ca:	02 c0       	rjmp	.+4      	; 0x44d0 <DIO_SetPinValue+0x1f4>
    44cc:	88 0f       	add	r24, r24
    44ce:	99 1f       	adc	r25, r25
    44d0:	0a 94       	dec	r0
    44d2:	e2 f7       	brpl	.-8      	; 0x44cc <DIO_SetPinValue+0x1f0>
    44d4:	80 95       	com	r24
    44d6:	84 23       	and	r24, r20
    44d8:	8c 93       	st	X, r24
	else 
	{
		/*           */
	
	}
}
    44da:	27 96       	adiw	r28, 0x07	; 7
    44dc:	0f b6       	in	r0, 0x3f	; 63
    44de:	f8 94       	cli
    44e0:	de bf       	out	0x3e, r29	; 62
    44e2:	0f be       	out	0x3f, r0	; 63
    44e4:	cd bf       	out	0x3d, r28	; 61
    44e6:	cf 91       	pop	r28
    44e8:	df 91       	pop	r29
    44ea:	08 95       	ret

000044ec <DIO_GETPinValue>:
/* ############################# GET BIT VALUE ##################################
x = DIO_uint_8GetPinValue(PORTA , PIN0); store the bit value to uint_8 X
*/

 uint_8 DIO_GETPinValue(uint_8 PortID , uint_8 PinID)
 {
    44ec:	df 93       	push	r29
    44ee:	cf 93       	push	r28
    44f0:	00 d0       	rcall	.+0      	; 0x44f2 <DIO_GETPinValue+0x6>
    44f2:	00 d0       	rcall	.+0      	; 0x44f4 <DIO_GETPinValue+0x8>
    44f4:	0f 92       	push	r0
    44f6:	cd b7       	in	r28, 0x3d	; 61
    44f8:	de b7       	in	r29, 0x3e	; 62
    44fa:	8a 83       	std	Y+2, r24	; 0x02
    44fc:	6b 83       	std	Y+3, r22	; 0x03
	 uint_8 Local_Value = 0xFF;  // setting initial value
    44fe:	8f ef       	ldi	r24, 0xFF	; 255
    4500:	89 83       	std	Y+1, r24	; 0x01
	 /* Range check*/
	if (PortID <4 && PinID <8)
    4502:	8a 81       	ldd	r24, Y+2	; 0x02
    4504:	84 30       	cpi	r24, 0x04	; 4
    4506:	08 f0       	brcs	.+2      	; 0x450a <DIO_GETPinValue+0x1e>
    4508:	6a c0       	rjmp	.+212    	; 0x45de <DIO_GETPinValue+0xf2>
    450a:	8b 81       	ldd	r24, Y+3	; 0x03
    450c:	88 30       	cpi	r24, 0x08	; 8
    450e:	08 f0       	brcs	.+2      	; 0x4512 <DIO_GETPinValue+0x26>
    4510:	66 c0       	rjmp	.+204    	; 0x45de <DIO_GETPinValue+0xf2>
	{
		switch (PortID)
    4512:	8a 81       	ldd	r24, Y+2	; 0x02
    4514:	28 2f       	mov	r18, r24
    4516:	30 e0       	ldi	r19, 0x00	; 0
    4518:	3d 83       	std	Y+5, r19	; 0x05
    451a:	2c 83       	std	Y+4, r18	; 0x04
    451c:	8c 81       	ldd	r24, Y+4	; 0x04
    451e:	9d 81       	ldd	r25, Y+5	; 0x05
    4520:	81 30       	cpi	r24, 0x01	; 1
    4522:	91 05       	cpc	r25, r1
    4524:	39 f1       	breq	.+78     	; 0x4574 <DIO_GETPinValue+0x88>
    4526:	2c 81       	ldd	r18, Y+4	; 0x04
    4528:	3d 81       	ldd	r19, Y+5	; 0x05
    452a:	22 30       	cpi	r18, 0x02	; 2
    452c:	31 05       	cpc	r19, r1
    452e:	2c f4       	brge	.+10     	; 0x453a <DIO_GETPinValue+0x4e>
    4530:	8c 81       	ldd	r24, Y+4	; 0x04
    4532:	9d 81       	ldd	r25, Y+5	; 0x05
    4534:	00 97       	sbiw	r24, 0x00	; 0
    4536:	61 f0       	breq	.+24     	; 0x4550 <DIO_GETPinValue+0x64>
    4538:	52 c0       	rjmp	.+164    	; 0x45de <DIO_GETPinValue+0xf2>
    453a:	2c 81       	ldd	r18, Y+4	; 0x04
    453c:	3d 81       	ldd	r19, Y+5	; 0x05
    453e:	22 30       	cpi	r18, 0x02	; 2
    4540:	31 05       	cpc	r19, r1
    4542:	51 f1       	breq	.+84     	; 0x4598 <DIO_GETPinValue+0xac>
    4544:	8c 81       	ldd	r24, Y+4	; 0x04
    4546:	9d 81       	ldd	r25, Y+5	; 0x05
    4548:	83 30       	cpi	r24, 0x03	; 3
    454a:	91 05       	cpc	r25, r1
    454c:	b9 f1       	breq	.+110    	; 0x45bc <DIO_GETPinValue+0xd0>
    454e:	47 c0       	rjmp	.+142    	; 0x45de <DIO_GETPinValue+0xf2>
			{
				case DIO_PORTA : Local_Value = GET_BIT(PINA_REG,PinID); break;
    4550:	e9 e3       	ldi	r30, 0x39	; 57
    4552:	f0 e0       	ldi	r31, 0x00	; 0
    4554:	80 81       	ld	r24, Z
    4556:	48 2f       	mov	r20, r24
    4558:	8b 81       	ldd	r24, Y+3	; 0x03
    455a:	28 2f       	mov	r18, r24
    455c:	30 e0       	ldi	r19, 0x00	; 0
    455e:	81 e0       	ldi	r24, 0x01	; 1
    4560:	90 e0       	ldi	r25, 0x00	; 0
    4562:	02 2e       	mov	r0, r18
    4564:	02 c0       	rjmp	.+4      	; 0x456a <DIO_GETPinValue+0x7e>
    4566:	88 0f       	add	r24, r24
    4568:	99 1f       	adc	r25, r25
    456a:	0a 94       	dec	r0
    456c:	e2 f7       	brpl	.-8      	; 0x4566 <DIO_GETPinValue+0x7a>
    456e:	84 23       	and	r24, r20
    4570:	89 83       	std	Y+1, r24	; 0x01
    4572:	35 c0       	rjmp	.+106    	; 0x45de <DIO_GETPinValue+0xf2>
				case DIO_PORTB : Local_Value = GET_BIT(PINB_REG,PinID); break;
    4574:	e6 e3       	ldi	r30, 0x36	; 54
    4576:	f0 e0       	ldi	r31, 0x00	; 0
    4578:	80 81       	ld	r24, Z
    457a:	48 2f       	mov	r20, r24
    457c:	8b 81       	ldd	r24, Y+3	; 0x03
    457e:	28 2f       	mov	r18, r24
    4580:	30 e0       	ldi	r19, 0x00	; 0
    4582:	81 e0       	ldi	r24, 0x01	; 1
    4584:	90 e0       	ldi	r25, 0x00	; 0
    4586:	02 2e       	mov	r0, r18
    4588:	02 c0       	rjmp	.+4      	; 0x458e <DIO_GETPinValue+0xa2>
    458a:	88 0f       	add	r24, r24
    458c:	99 1f       	adc	r25, r25
    458e:	0a 94       	dec	r0
    4590:	e2 f7       	brpl	.-8      	; 0x458a <DIO_GETPinValue+0x9e>
    4592:	84 23       	and	r24, r20
    4594:	89 83       	std	Y+1, r24	; 0x01
    4596:	23 c0       	rjmp	.+70     	; 0x45de <DIO_GETPinValue+0xf2>
				case DIO_PORTC : Local_Value = GET_BIT(PINC_REG,PinID); break;
    4598:	e3 e3       	ldi	r30, 0x33	; 51
    459a:	f0 e0       	ldi	r31, 0x00	; 0
    459c:	80 81       	ld	r24, Z
    459e:	48 2f       	mov	r20, r24
    45a0:	8b 81       	ldd	r24, Y+3	; 0x03
    45a2:	28 2f       	mov	r18, r24
    45a4:	30 e0       	ldi	r19, 0x00	; 0
    45a6:	81 e0       	ldi	r24, 0x01	; 1
    45a8:	90 e0       	ldi	r25, 0x00	; 0
    45aa:	02 2e       	mov	r0, r18
    45ac:	02 c0       	rjmp	.+4      	; 0x45b2 <DIO_GETPinValue+0xc6>
    45ae:	88 0f       	add	r24, r24
    45b0:	99 1f       	adc	r25, r25
    45b2:	0a 94       	dec	r0
    45b4:	e2 f7       	brpl	.-8      	; 0x45ae <DIO_GETPinValue+0xc2>
    45b6:	84 23       	and	r24, r20
    45b8:	89 83       	std	Y+1, r24	; 0x01
    45ba:	11 c0       	rjmp	.+34     	; 0x45de <DIO_GETPinValue+0xf2>
				case DIO_PORTD : Local_Value = GET_BIT(PIND_REG,PinID); break;
    45bc:	e0 e3       	ldi	r30, 0x30	; 48
    45be:	f0 e0       	ldi	r31, 0x00	; 0
    45c0:	80 81       	ld	r24, Z
    45c2:	48 2f       	mov	r20, r24
    45c4:	8b 81       	ldd	r24, Y+3	; 0x03
    45c6:	28 2f       	mov	r18, r24
    45c8:	30 e0       	ldi	r19, 0x00	; 0
    45ca:	81 e0       	ldi	r24, 0x01	; 1
    45cc:	90 e0       	ldi	r25, 0x00	; 0
    45ce:	02 2e       	mov	r0, r18
    45d0:	02 c0       	rjmp	.+4      	; 0x45d6 <DIO_GETPinValue+0xea>
    45d2:	88 0f       	add	r24, r24
    45d4:	99 1f       	adc	r25, r25
    45d6:	0a 94       	dec	r0
    45d8:	e2 f7       	brpl	.-8      	; 0x45d2 <DIO_GETPinValue+0xe6>
    45da:	84 23       	and	r24, r20
    45dc:	89 83       	std	Y+1, r24	; 0x01
	}			
    else
	{
		/* ERROR*/
	}
return Local_Value;	 
    45de:	89 81       	ldd	r24, Y+1	; 0x01
 }
    45e0:	0f 90       	pop	r0
    45e2:	0f 90       	pop	r0
    45e4:	0f 90       	pop	r0
    45e6:	0f 90       	pop	r0
    45e8:	0f 90       	pop	r0
    45ea:	cf 91       	pop	r28
    45ec:	df 91       	pop	r29
    45ee:	08 95       	ret

000045f0 <Dio_FlipChannel>:
 
 
 void Dio_FlipChannel(uint_8 PortID,uint_8 PinID)
 {
    45f0:	df 93       	push	r29
    45f2:	cf 93       	push	r28
    45f4:	00 d0       	rcall	.+0      	; 0x45f6 <Dio_FlipChannel+0x6>
    45f6:	00 d0       	rcall	.+0      	; 0x45f8 <Dio_FlipChannel+0x8>
    45f8:	cd b7       	in	r28, 0x3d	; 61
    45fa:	de b7       	in	r29, 0x3e	; 62
    45fc:	89 83       	std	Y+1, r24	; 0x01
    45fe:	6a 83       	std	Y+2, r22	; 0x02
	 switch (PortID)
    4600:	89 81       	ldd	r24, Y+1	; 0x01
    4602:	28 2f       	mov	r18, r24
    4604:	30 e0       	ldi	r19, 0x00	; 0
    4606:	3c 83       	std	Y+4, r19	; 0x04
    4608:	2b 83       	std	Y+3, r18	; 0x03
    460a:	8b 81       	ldd	r24, Y+3	; 0x03
    460c:	9c 81       	ldd	r25, Y+4	; 0x04
    460e:	81 30       	cpi	r24, 0x01	; 1
    4610:	91 05       	cpc	r25, r1
    4612:	49 f1       	breq	.+82     	; 0x4666 <Dio_FlipChannel+0x76>
    4614:	2b 81       	ldd	r18, Y+3	; 0x03
    4616:	3c 81       	ldd	r19, Y+4	; 0x04
    4618:	22 30       	cpi	r18, 0x02	; 2
    461a:	31 05       	cpc	r19, r1
    461c:	2c f4       	brge	.+10     	; 0x4628 <Dio_FlipChannel+0x38>
    461e:	8b 81       	ldd	r24, Y+3	; 0x03
    4620:	9c 81       	ldd	r25, Y+4	; 0x04
    4622:	00 97       	sbiw	r24, 0x00	; 0
    4624:	61 f0       	breq	.+24     	; 0x463e <Dio_FlipChannel+0x4e>
    4626:	5a c0       	rjmp	.+180    	; 0x46dc <Dio_FlipChannel+0xec>
    4628:	2b 81       	ldd	r18, Y+3	; 0x03
    462a:	3c 81       	ldd	r19, Y+4	; 0x04
    462c:	22 30       	cpi	r18, 0x02	; 2
    462e:	31 05       	cpc	r19, r1
    4630:	71 f1       	breq	.+92     	; 0x468e <Dio_FlipChannel+0x9e>
    4632:	8b 81       	ldd	r24, Y+3	; 0x03
    4634:	9c 81       	ldd	r25, Y+4	; 0x04
    4636:	83 30       	cpi	r24, 0x03	; 3
    4638:	91 05       	cpc	r25, r1
    463a:	e9 f1       	breq	.+122    	; 0x46b6 <Dio_FlipChannel+0xc6>
    463c:	4f c0       	rjmp	.+158    	; 0x46dc <Dio_FlipChannel+0xec>
	 {
		 case DIO_PORTA:
		 TOG_BIT(PORTA_REG,PinID);
    463e:	ab e3       	ldi	r26, 0x3B	; 59
    4640:	b0 e0       	ldi	r27, 0x00	; 0
    4642:	eb e3       	ldi	r30, 0x3B	; 59
    4644:	f0 e0       	ldi	r31, 0x00	; 0
    4646:	80 81       	ld	r24, Z
    4648:	48 2f       	mov	r20, r24
    464a:	8a 81       	ldd	r24, Y+2	; 0x02
    464c:	28 2f       	mov	r18, r24
    464e:	30 e0       	ldi	r19, 0x00	; 0
    4650:	81 e0       	ldi	r24, 0x01	; 1
    4652:	90 e0       	ldi	r25, 0x00	; 0
    4654:	02 2e       	mov	r0, r18
    4656:	02 c0       	rjmp	.+4      	; 0x465c <Dio_FlipChannel+0x6c>
    4658:	88 0f       	add	r24, r24
    465a:	99 1f       	adc	r25, r25
    465c:	0a 94       	dec	r0
    465e:	e2 f7       	brpl	.-8      	; 0x4658 <Dio_FlipChannel+0x68>
    4660:	84 27       	eor	r24, r20
    4662:	8c 93       	st	X, r24
    4664:	3b c0       	rjmp	.+118    	; 0x46dc <Dio_FlipChannel+0xec>
		 break;
		 case DIO_PORTB:
		 TOG_BIT(PORTB_REG,PinID);
    4666:	a8 e3       	ldi	r26, 0x38	; 56
    4668:	b0 e0       	ldi	r27, 0x00	; 0
    466a:	e8 e3       	ldi	r30, 0x38	; 56
    466c:	f0 e0       	ldi	r31, 0x00	; 0
    466e:	80 81       	ld	r24, Z
    4670:	48 2f       	mov	r20, r24
    4672:	8a 81       	ldd	r24, Y+2	; 0x02
    4674:	28 2f       	mov	r18, r24
    4676:	30 e0       	ldi	r19, 0x00	; 0
    4678:	81 e0       	ldi	r24, 0x01	; 1
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	02 2e       	mov	r0, r18
    467e:	02 c0       	rjmp	.+4      	; 0x4684 <Dio_FlipChannel+0x94>
    4680:	88 0f       	add	r24, r24
    4682:	99 1f       	adc	r25, r25
    4684:	0a 94       	dec	r0
    4686:	e2 f7       	brpl	.-8      	; 0x4680 <Dio_FlipChannel+0x90>
    4688:	84 27       	eor	r24, r20
    468a:	8c 93       	st	X, r24
    468c:	27 c0       	rjmp	.+78     	; 0x46dc <Dio_FlipChannel+0xec>
		 break;
		 case DIO_PORTC:
		 TOG_BIT(PORTC_REG,PinID);
    468e:	a5 e3       	ldi	r26, 0x35	; 53
    4690:	b0 e0       	ldi	r27, 0x00	; 0
    4692:	e5 e3       	ldi	r30, 0x35	; 53
    4694:	f0 e0       	ldi	r31, 0x00	; 0
    4696:	80 81       	ld	r24, Z
    4698:	48 2f       	mov	r20, r24
    469a:	8a 81       	ldd	r24, Y+2	; 0x02
    469c:	28 2f       	mov	r18, r24
    469e:	30 e0       	ldi	r19, 0x00	; 0
    46a0:	81 e0       	ldi	r24, 0x01	; 1
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	02 2e       	mov	r0, r18
    46a6:	02 c0       	rjmp	.+4      	; 0x46ac <Dio_FlipChannel+0xbc>
    46a8:	88 0f       	add	r24, r24
    46aa:	99 1f       	adc	r25, r25
    46ac:	0a 94       	dec	r0
    46ae:	e2 f7       	brpl	.-8      	; 0x46a8 <Dio_FlipChannel+0xb8>
    46b0:	84 27       	eor	r24, r20
    46b2:	8c 93       	st	X, r24
    46b4:	13 c0       	rjmp	.+38     	; 0x46dc <Dio_FlipChannel+0xec>
		 break;
		 case DIO_PORTD:
		 TOG_BIT(PORTD_REG,PinID);
    46b6:	a2 e3       	ldi	r26, 0x32	; 50
    46b8:	b0 e0       	ldi	r27, 0x00	; 0
    46ba:	e2 e3       	ldi	r30, 0x32	; 50
    46bc:	f0 e0       	ldi	r31, 0x00	; 0
    46be:	80 81       	ld	r24, Z
    46c0:	48 2f       	mov	r20, r24
    46c2:	8a 81       	ldd	r24, Y+2	; 0x02
    46c4:	28 2f       	mov	r18, r24
    46c6:	30 e0       	ldi	r19, 0x00	; 0
    46c8:	81 e0       	ldi	r24, 0x01	; 1
    46ca:	90 e0       	ldi	r25, 0x00	; 0
    46cc:	02 2e       	mov	r0, r18
    46ce:	02 c0       	rjmp	.+4      	; 0x46d4 <Dio_FlipChannel+0xe4>
    46d0:	88 0f       	add	r24, r24
    46d2:	99 1f       	adc	r25, r25
    46d4:	0a 94       	dec	r0
    46d6:	e2 f7       	brpl	.-8      	; 0x46d0 <Dio_FlipChannel+0xe0>
    46d8:	84 27       	eor	r24, r20
    46da:	8c 93       	st	X, r24
		 break;
	 }
 }
    46dc:	0f 90       	pop	r0
    46de:	0f 90       	pop	r0
    46e0:	0f 90       	pop	r0
    46e2:	0f 90       	pop	r0
    46e4:	cf 91       	pop	r28
    46e6:	df 91       	pop	r29
    46e8:	08 95       	ret

000046ea <Dio_WriteChannelGroup>:
*				   : mask			- DIO channel group position 
				   : data			- DIO channel group Level                                                                     
* \Return value:   : None                        
**************************************************************************************************************************/
void Dio_WriteChannelGroup(uint_8  portID, uint_8 mask, uint_8 position, uint_8 data)
{
    46ea:	df 93       	push	r29
    46ec:	cf 93       	push	r28
    46ee:	00 d0       	rcall	.+0      	; 0x46f0 <Dio_WriteChannelGroup+0x6>
    46f0:	00 d0       	rcall	.+0      	; 0x46f2 <Dio_WriteChannelGroup+0x8>
    46f2:	00 d0       	rcall	.+0      	; 0x46f4 <Dio_WriteChannelGroup+0xa>
    46f4:	cd b7       	in	r28, 0x3d	; 61
    46f6:	de b7       	in	r29, 0x3e	; 62
    46f8:	89 83       	std	Y+1, r24	; 0x01
    46fa:	6a 83       	std	Y+2, r22	; 0x02
    46fc:	4b 83       	std	Y+3, r20	; 0x03
    46fe:	2c 83       	std	Y+4, r18	; 0x04
	switch (portID)
    4700:	89 81       	ldd	r24, Y+1	; 0x01
    4702:	28 2f       	mov	r18, r24
    4704:	30 e0       	ldi	r19, 0x00	; 0
    4706:	3e 83       	std	Y+6, r19	; 0x06
    4708:	2d 83       	std	Y+5, r18	; 0x05
    470a:	6d 81       	ldd	r22, Y+5	; 0x05
    470c:	7e 81       	ldd	r23, Y+6	; 0x06
    470e:	61 30       	cpi	r22, 0x01	; 1
    4710:	71 05       	cpc	r23, r1
    4712:	89 f1       	breq	.+98     	; 0x4776 <Dio_WriteChannelGroup+0x8c>
    4714:	8d 81       	ldd	r24, Y+5	; 0x05
    4716:	9e 81       	ldd	r25, Y+6	; 0x06
    4718:	82 30       	cpi	r24, 0x02	; 2
    471a:	91 05       	cpc	r25, r1
    471c:	34 f4       	brge	.+12     	; 0x472a <Dio_WriteChannelGroup+0x40>
    471e:	2d 81       	ldd	r18, Y+5	; 0x05
    4720:	3e 81       	ldd	r19, Y+6	; 0x06
    4722:	21 15       	cp	r18, r1
    4724:	31 05       	cpc	r19, r1
    4726:	69 f0       	breq	.+26     	; 0x4742 <Dio_WriteChannelGroup+0x58>
    4728:	73 c0       	rjmp	.+230    	; 0x4810 <Dio_WriteChannelGroup+0x126>
    472a:	6d 81       	ldd	r22, Y+5	; 0x05
    472c:	7e 81       	ldd	r23, Y+6	; 0x06
    472e:	62 30       	cpi	r22, 0x02	; 2
    4730:	71 05       	cpc	r23, r1
    4732:	d9 f1       	breq	.+118    	; 0x47aa <Dio_WriteChannelGroup+0xc0>
    4734:	8d 81       	ldd	r24, Y+5	; 0x05
    4736:	9e 81       	ldd	r25, Y+6	; 0x06
    4738:	83 30       	cpi	r24, 0x03	; 3
    473a:	91 05       	cpc	r25, r1
    473c:	09 f4       	brne	.+2      	; 0x4740 <Dio_WriteChannelGroup+0x56>
    473e:	4f c0       	rjmp	.+158    	; 0x47de <Dio_WriteChannelGroup+0xf4>
    4740:	67 c0       	rjmp	.+206    	; 0x4810 <Dio_WriteChannelGroup+0x126>
	{
	case DIO_PORTA:
		PORTA_REG = (PORTA_REG & ~mask)|(data<<position) ;
    4742:	ab e3       	ldi	r26, 0x3B	; 59
    4744:	b0 e0       	ldi	r27, 0x00	; 0
    4746:	eb e3       	ldi	r30, 0x3B	; 59
    4748:	f0 e0       	ldi	r31, 0x00	; 0
    474a:	80 81       	ld	r24, Z
    474c:	98 2f       	mov	r25, r24
    474e:	8a 81       	ldd	r24, Y+2	; 0x02
    4750:	80 95       	com	r24
    4752:	49 2f       	mov	r20, r25
    4754:	48 23       	and	r20, r24
    4756:	8c 81       	ldd	r24, Y+4	; 0x04
    4758:	28 2f       	mov	r18, r24
    475a:	30 e0       	ldi	r19, 0x00	; 0
    475c:	8b 81       	ldd	r24, Y+3	; 0x03
    475e:	88 2f       	mov	r24, r24
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	b9 01       	movw	r22, r18
    4764:	02 c0       	rjmp	.+4      	; 0x476a <Dio_WriteChannelGroup+0x80>
    4766:	66 0f       	add	r22, r22
    4768:	77 1f       	adc	r23, r23
    476a:	8a 95       	dec	r24
    476c:	e2 f7       	brpl	.-8      	; 0x4766 <Dio_WriteChannelGroup+0x7c>
    476e:	cb 01       	movw	r24, r22
    4770:	84 2b       	or	r24, r20
    4772:	8c 93       	st	X, r24
    4774:	4d c0       	rjmp	.+154    	; 0x4810 <Dio_WriteChannelGroup+0x126>
		break;

	case DIO_PORTB:
		PORTB_REG = (PORTB_REG & ~mask)|(data<<position) ;
    4776:	a8 e3       	ldi	r26, 0x38	; 56
    4778:	b0 e0       	ldi	r27, 0x00	; 0
    477a:	e8 e3       	ldi	r30, 0x38	; 56
    477c:	f0 e0       	ldi	r31, 0x00	; 0
    477e:	80 81       	ld	r24, Z
    4780:	98 2f       	mov	r25, r24
    4782:	8a 81       	ldd	r24, Y+2	; 0x02
    4784:	80 95       	com	r24
    4786:	49 2f       	mov	r20, r25
    4788:	48 23       	and	r20, r24
    478a:	8c 81       	ldd	r24, Y+4	; 0x04
    478c:	28 2f       	mov	r18, r24
    478e:	30 e0       	ldi	r19, 0x00	; 0
    4790:	8b 81       	ldd	r24, Y+3	; 0x03
    4792:	88 2f       	mov	r24, r24
    4794:	90 e0       	ldi	r25, 0x00	; 0
    4796:	b9 01       	movw	r22, r18
    4798:	02 c0       	rjmp	.+4      	; 0x479e <Dio_WriteChannelGroup+0xb4>
    479a:	66 0f       	add	r22, r22
    479c:	77 1f       	adc	r23, r23
    479e:	8a 95       	dec	r24
    47a0:	e2 f7       	brpl	.-8      	; 0x479a <Dio_WriteChannelGroup+0xb0>
    47a2:	cb 01       	movw	r24, r22
    47a4:	84 2b       	or	r24, r20
    47a6:	8c 93       	st	X, r24
    47a8:	33 c0       	rjmp	.+102    	; 0x4810 <Dio_WriteChannelGroup+0x126>
		break;
	case DIO_PORTC:
		PORTC_REG = (PORTC_REG & ~mask)|(data<<position) ;
    47aa:	a5 e3       	ldi	r26, 0x35	; 53
    47ac:	b0 e0       	ldi	r27, 0x00	; 0
    47ae:	e5 e3       	ldi	r30, 0x35	; 53
    47b0:	f0 e0       	ldi	r31, 0x00	; 0
    47b2:	80 81       	ld	r24, Z
    47b4:	98 2f       	mov	r25, r24
    47b6:	8a 81       	ldd	r24, Y+2	; 0x02
    47b8:	80 95       	com	r24
    47ba:	49 2f       	mov	r20, r25
    47bc:	48 23       	and	r20, r24
    47be:	8c 81       	ldd	r24, Y+4	; 0x04
    47c0:	28 2f       	mov	r18, r24
    47c2:	30 e0       	ldi	r19, 0x00	; 0
    47c4:	8b 81       	ldd	r24, Y+3	; 0x03
    47c6:	88 2f       	mov	r24, r24
    47c8:	90 e0       	ldi	r25, 0x00	; 0
    47ca:	b9 01       	movw	r22, r18
    47cc:	02 c0       	rjmp	.+4      	; 0x47d2 <Dio_WriteChannelGroup+0xe8>
    47ce:	66 0f       	add	r22, r22
    47d0:	77 1f       	adc	r23, r23
    47d2:	8a 95       	dec	r24
    47d4:	e2 f7       	brpl	.-8      	; 0x47ce <Dio_WriteChannelGroup+0xe4>
    47d6:	cb 01       	movw	r24, r22
    47d8:	84 2b       	or	r24, r20
    47da:	8c 93       	st	X, r24
    47dc:	19 c0       	rjmp	.+50     	; 0x4810 <Dio_WriteChannelGroup+0x126>
		break;
	case DIO_PORTD:
		PORTD_REG = (PORTD_REG & ~mask)|(data<<position) ;
    47de:	a2 e3       	ldi	r26, 0x32	; 50
    47e0:	b0 e0       	ldi	r27, 0x00	; 0
    47e2:	e2 e3       	ldi	r30, 0x32	; 50
    47e4:	f0 e0       	ldi	r31, 0x00	; 0
    47e6:	80 81       	ld	r24, Z
    47e8:	98 2f       	mov	r25, r24
    47ea:	8a 81       	ldd	r24, Y+2	; 0x02
    47ec:	80 95       	com	r24
    47ee:	49 2f       	mov	r20, r25
    47f0:	48 23       	and	r20, r24
    47f2:	8c 81       	ldd	r24, Y+4	; 0x04
    47f4:	28 2f       	mov	r18, r24
    47f6:	30 e0       	ldi	r19, 0x00	; 0
    47f8:	8b 81       	ldd	r24, Y+3	; 0x03
    47fa:	88 2f       	mov	r24, r24
    47fc:	90 e0       	ldi	r25, 0x00	; 0
    47fe:	b9 01       	movw	r22, r18
    4800:	02 c0       	rjmp	.+4      	; 0x4806 <Dio_WriteChannelGroup+0x11c>
    4802:	66 0f       	add	r22, r22
    4804:	77 1f       	adc	r23, r23
    4806:	8a 95       	dec	r24
    4808:	e2 f7       	brpl	.-8      	; 0x4802 <Dio_WriteChannelGroup+0x118>
    480a:	cb 01       	movw	r24, r22
    480c:	84 2b       	or	r24, r20
    480e:	8c 93       	st	X, r24
		break;
	}	
}
    4810:	26 96       	adiw	r28, 0x06	; 6
    4812:	0f b6       	in	r0, 0x3f	; 63
    4814:	f8 94       	cli
    4816:	de bf       	out	0x3e, r29	; 62
    4818:	0f be       	out	0x3f, r0	; 63
    481a:	cd bf       	out	0x3d, r28	; 61
    481c:	cf 91       	pop	r28
    481e:	df 91       	pop	r29
    4820:	08 95       	ret

00004822 <Dio_ReadChannelGroup>:
*				   : mask			- DIO channel group mask
				   : position		- DIO channel group position
* \Return value:   : None
**************************************************************************************************************************/
uint_8 Dio_ReadChannelGroup(uint_8 portID, uint_8 mask, uint_8 position)
{
    4822:	df 93       	push	r29
    4824:	cf 93       	push	r28
    4826:	00 d0       	rcall	.+0      	; 0x4828 <Dio_ReadChannelGroup+0x6>
    4828:	00 d0       	rcall	.+0      	; 0x482a <Dio_ReadChannelGroup+0x8>
    482a:	00 d0       	rcall	.+0      	; 0x482c <Dio_ReadChannelGroup+0xa>
    482c:	cd b7       	in	r28, 0x3d	; 61
    482e:	de b7       	in	r29, 0x3e	; 62
    4830:	8a 83       	std	Y+2, r24	; 0x02
    4832:	6b 83       	std	Y+3, r22	; 0x03
    4834:	4c 83       	std	Y+4, r20	; 0x04
	uint_8 ret_Value=0;
    4836:	19 82       	std	Y+1, r1	; 0x01

	switch (portID)
    4838:	8a 81       	ldd	r24, Y+2	; 0x02
    483a:	28 2f       	mov	r18, r24
    483c:	30 e0       	ldi	r19, 0x00	; 0
    483e:	3e 83       	std	Y+6, r19	; 0x06
    4840:	2d 83       	std	Y+5, r18	; 0x05
    4842:	4d 81       	ldd	r20, Y+5	; 0x05
    4844:	5e 81       	ldd	r21, Y+6	; 0x06
    4846:	41 30       	cpi	r20, 0x01	; 1
    4848:	51 05       	cpc	r21, r1
    484a:	61 f1       	breq	.+88     	; 0x48a4 <Dio_ReadChannelGroup+0x82>
    484c:	8d 81       	ldd	r24, Y+5	; 0x05
    484e:	9e 81       	ldd	r25, Y+6	; 0x06
    4850:	82 30       	cpi	r24, 0x02	; 2
    4852:	91 05       	cpc	r25, r1
    4854:	34 f4       	brge	.+12     	; 0x4862 <Dio_ReadChannelGroup+0x40>
    4856:	2d 81       	ldd	r18, Y+5	; 0x05
    4858:	3e 81       	ldd	r19, Y+6	; 0x06
    485a:	21 15       	cp	r18, r1
    485c:	31 05       	cpc	r19, r1
    485e:	69 f0       	breq	.+26     	; 0x487a <Dio_ReadChannelGroup+0x58>
    4860:	5f c0       	rjmp	.+190    	; 0x4920 <Dio_ReadChannelGroup+0xfe>
    4862:	4d 81       	ldd	r20, Y+5	; 0x05
    4864:	5e 81       	ldd	r21, Y+6	; 0x06
    4866:	42 30       	cpi	r20, 0x02	; 2
    4868:	51 05       	cpc	r21, r1
    486a:	89 f1       	breq	.+98     	; 0x48ce <Dio_ReadChannelGroup+0xac>
    486c:	8d 81       	ldd	r24, Y+5	; 0x05
    486e:	9e 81       	ldd	r25, Y+6	; 0x06
    4870:	83 30       	cpi	r24, 0x03	; 3
    4872:	91 05       	cpc	r25, r1
    4874:	09 f4       	brne	.+2      	; 0x4878 <Dio_ReadChannelGroup+0x56>
    4876:	40 c0       	rjmp	.+128    	; 0x48f8 <Dio_ReadChannelGroup+0xd6>
    4878:	53 c0       	rjmp	.+166    	; 0x4920 <Dio_ReadChannelGroup+0xfe>
	{
	case DIO_PORTA:
		ret_Value=PORTA_REG & mask;
    487a:	eb e3       	ldi	r30, 0x3B	; 59
    487c:	f0 e0       	ldi	r31, 0x00	; 0
    487e:	90 81       	ld	r25, Z
    4880:	8b 81       	ldd	r24, Y+3	; 0x03
    4882:	89 23       	and	r24, r25
    4884:	89 83       	std	Y+1, r24	; 0x01
		ret_Value=ret_Value<<position;
    4886:	89 81       	ldd	r24, Y+1	; 0x01
    4888:	28 2f       	mov	r18, r24
    488a:	30 e0       	ldi	r19, 0x00	; 0
    488c:	8c 81       	ldd	r24, Y+4	; 0x04
    488e:	88 2f       	mov	r24, r24
    4890:	90 e0       	ldi	r25, 0x00	; 0
    4892:	a9 01       	movw	r20, r18
    4894:	02 c0       	rjmp	.+4      	; 0x489a <Dio_ReadChannelGroup+0x78>
    4896:	44 0f       	add	r20, r20
    4898:	55 1f       	adc	r21, r21
    489a:	8a 95       	dec	r24
    489c:	e2 f7       	brpl	.-8      	; 0x4896 <Dio_ReadChannelGroup+0x74>
    489e:	ca 01       	movw	r24, r20
    48a0:	89 83       	std	Y+1, r24	; 0x01
    48a2:	3e c0       	rjmp	.+124    	; 0x4920 <Dio_ReadChannelGroup+0xfe>
		break;
	case DIO_PORTB:
		ret_Value=PORTB_REG & mask;
    48a4:	e8 e3       	ldi	r30, 0x38	; 56
    48a6:	f0 e0       	ldi	r31, 0x00	; 0
    48a8:	90 81       	ld	r25, Z
    48aa:	8b 81       	ldd	r24, Y+3	; 0x03
    48ac:	89 23       	and	r24, r25
    48ae:	89 83       	std	Y+1, r24	; 0x01
		ret_Value=ret_Value<<position;
    48b0:	89 81       	ldd	r24, Y+1	; 0x01
    48b2:	28 2f       	mov	r18, r24
    48b4:	30 e0       	ldi	r19, 0x00	; 0
    48b6:	8c 81       	ldd	r24, Y+4	; 0x04
    48b8:	88 2f       	mov	r24, r24
    48ba:	90 e0       	ldi	r25, 0x00	; 0
    48bc:	a9 01       	movw	r20, r18
    48be:	02 c0       	rjmp	.+4      	; 0x48c4 <Dio_ReadChannelGroup+0xa2>
    48c0:	44 0f       	add	r20, r20
    48c2:	55 1f       	adc	r21, r21
    48c4:	8a 95       	dec	r24
    48c6:	e2 f7       	brpl	.-8      	; 0x48c0 <Dio_ReadChannelGroup+0x9e>
    48c8:	ca 01       	movw	r24, r20
    48ca:	89 83       	std	Y+1, r24	; 0x01
    48cc:	29 c0       	rjmp	.+82     	; 0x4920 <Dio_ReadChannelGroup+0xfe>
		break;
	case DIO_PORTC:
		ret_Value=PORTC_REG & mask;
    48ce:	e5 e3       	ldi	r30, 0x35	; 53
    48d0:	f0 e0       	ldi	r31, 0x00	; 0
    48d2:	90 81       	ld	r25, Z
    48d4:	8b 81       	ldd	r24, Y+3	; 0x03
    48d6:	89 23       	and	r24, r25
    48d8:	89 83       	std	Y+1, r24	; 0x01
		ret_Value=ret_Value<<position;
    48da:	89 81       	ldd	r24, Y+1	; 0x01
    48dc:	28 2f       	mov	r18, r24
    48de:	30 e0       	ldi	r19, 0x00	; 0
    48e0:	8c 81       	ldd	r24, Y+4	; 0x04
    48e2:	88 2f       	mov	r24, r24
    48e4:	90 e0       	ldi	r25, 0x00	; 0
    48e6:	a9 01       	movw	r20, r18
    48e8:	02 c0       	rjmp	.+4      	; 0x48ee <Dio_ReadChannelGroup+0xcc>
    48ea:	44 0f       	add	r20, r20
    48ec:	55 1f       	adc	r21, r21
    48ee:	8a 95       	dec	r24
    48f0:	e2 f7       	brpl	.-8      	; 0x48ea <Dio_ReadChannelGroup+0xc8>
    48f2:	ca 01       	movw	r24, r20
    48f4:	89 83       	std	Y+1, r24	; 0x01
    48f6:	14 c0       	rjmp	.+40     	; 0x4920 <Dio_ReadChannelGroup+0xfe>
		break;
	case DIO_PORTD:
		ret_Value=PORTD_REG & mask;
    48f8:	e2 e3       	ldi	r30, 0x32	; 50
    48fa:	f0 e0       	ldi	r31, 0x00	; 0
    48fc:	90 81       	ld	r25, Z
    48fe:	8b 81       	ldd	r24, Y+3	; 0x03
    4900:	89 23       	and	r24, r25
    4902:	89 83       	std	Y+1, r24	; 0x01
		ret_Value=ret_Value<<position;
    4904:	89 81       	ldd	r24, Y+1	; 0x01
    4906:	28 2f       	mov	r18, r24
    4908:	30 e0       	ldi	r19, 0x00	; 0
    490a:	8c 81       	ldd	r24, Y+4	; 0x04
    490c:	88 2f       	mov	r24, r24
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	a9 01       	movw	r20, r18
    4912:	02 c0       	rjmp	.+4      	; 0x4918 <Dio_ReadChannelGroup+0xf6>
    4914:	44 0f       	add	r20, r20
    4916:	55 1f       	adc	r21, r21
    4918:	8a 95       	dec	r24
    491a:	e2 f7       	brpl	.-8      	; 0x4914 <Dio_ReadChannelGroup+0xf2>
    491c:	ca 01       	movw	r24, r20
    491e:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return ret_Value;
    4920:	89 81       	ldd	r24, Y+1	; 0x01
    4922:	26 96       	adiw	r28, 0x06	; 6
    4924:	0f b6       	in	r0, 0x3f	; 63
    4926:	f8 94       	cli
    4928:	de bf       	out	0x3e, r29	; 62
    492a:	0f be       	out	0x3f, r0	; 63
    492c:	cd bf       	out	0x3d, r28	; 61
    492e:	cf 91       	pop	r28
    4930:	df 91       	pop	r29
    4932:	08 95       	ret

00004934 <Led_Init>:
 **********************************/

#include "Led_Interface.h"

void Led_Init(void)
{
    4934:	df 93       	push	r29
    4936:	cf 93       	push	r28
    4938:	cd b7       	in	r28, 0x3d	; 61
    493a:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDirection(LED0_PORT, LED0_CHANNEL, OUTPUT);
    493c:	82 e0       	ldi	r24, 0x02	; 2
    493e:	62 e0       	ldi	r22, 0x02	; 2
    4940:	41 e0       	ldi	r20, 0x01	; 1
    4942:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	DIO_SetPinDirection(LED1_PORT, LED1_CHANNEL, OUTPUT);
    4946:	82 e0       	ldi	r24, 0x02	; 2
    4948:	67 e0       	ldi	r22, 0x07	; 7
    494a:	41 e0       	ldi	r20, 0x01	; 1
    494c:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
	DIO_SetPinDirection(LED2_PORT, LED2_CHANNEL, OUTPUT);
    4950:	83 e0       	ldi	r24, 0x03	; 3
    4952:	63 e0       	ldi	r22, 0x03	; 3
    4954:	41 e0       	ldi	r20, 0x01	; 1
    4956:	0e 94 b3 1f 	call	0x3f66	; 0x3f66 <DIO_SetPinDirection>
}
    495a:	cf 91       	pop	r28
    495c:	df 91       	pop	r29
    495e:	08 95       	ret

00004960 <Led_ON>:
void Led_ON(Led_ID led)
{
    4960:	df 93       	push	r29
    4962:	cf 93       	push	r28
    4964:	00 d0       	rcall	.+0      	; 0x4966 <Led_ON+0x6>
    4966:	0f 92       	push	r0
    4968:	cd b7       	in	r28, 0x3d	; 61
    496a:	de b7       	in	r29, 0x3e	; 62
    496c:	89 83       	std	Y+1, r24	; 0x01
	switch (led)
    496e:	89 81       	ldd	r24, Y+1	; 0x01
    4970:	28 2f       	mov	r18, r24
    4972:	30 e0       	ldi	r19, 0x00	; 0
    4974:	3b 83       	std	Y+3, r19	; 0x03
    4976:	2a 83       	std	Y+2, r18	; 0x02
    4978:	8a 81       	ldd	r24, Y+2	; 0x02
    497a:	9b 81       	ldd	r25, Y+3	; 0x03
    497c:	81 30       	cpi	r24, 0x01	; 1
    497e:	91 05       	cpc	r25, r1
    4980:	79 f0       	breq	.+30     	; 0x49a0 <Led_ON+0x40>
    4982:	2a 81       	ldd	r18, Y+2	; 0x02
    4984:	3b 81       	ldd	r19, Y+3	; 0x03
    4986:	22 30       	cpi	r18, 0x02	; 2
    4988:	31 05       	cpc	r19, r1
    498a:	81 f0       	breq	.+32     	; 0x49ac <Led_ON+0x4c>
    498c:	8a 81       	ldd	r24, Y+2	; 0x02
    498e:	9b 81       	ldd	r25, Y+3	; 0x03
    4990:	00 97       	sbiw	r24, 0x00	; 0
    4992:	89 f4       	brne	.+34     	; 0x49b6 <Led_ON+0x56>
	{
	case LED0:
#if (LED0_CONNECTION == FORWARD)
		DIO_SetPinValue(LED0_PORT,LED0_CHANNEL,HIGH);
    4994:	82 e0       	ldi	r24, 0x02	; 2
    4996:	62 e0       	ldi	r22, 0x02	; 2
    4998:	41 e0       	ldi	r20, 0x01	; 1
    499a:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    499e:	0b c0       	rjmp	.+22     	; 0x49b6 <Led_ON+0x56>
		DIO_SetPinValue(LED0_PORT,LED0_CHANNEL,LOW);
#endif
		break;
	case LED1:
#if (LED1_CONNECTION == FORWARD)
		DIO_SetPinValue(LED1_PORT,LED1_CHANNEL,HIGH);
    49a0:	82 e0       	ldi	r24, 0x02	; 2
    49a2:	67 e0       	ldi	r22, 0x07	; 7
    49a4:	41 e0       	ldi	r20, 0x01	; 1
    49a6:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    49aa:	05 c0       	rjmp	.+10     	; 0x49b6 <Led_ON+0x56>
		DIO_SetPinValue(LED1_PORT,LED1_CHANNEL,LOW);
#endif
		break;
	case LED2:
#if (LED2_CONNECTION == FORWARD)
		DIO_SetPinValue(LED2_PORT,LED2_CHANNEL,HIGH);
    49ac:	83 e0       	ldi	r24, 0x03	; 3
    49ae:	63 e0       	ldi	r22, 0x03	; 3
    49b0:	41 e0       	ldi	r20, 0x01	; 1
    49b2:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
#elif (LED2_CONNECTION == REVERSE)
		DIO_SetPinValue(LED2_PORT,LED2_CHANNEL,LOW);
#endif
		break;
	}
}
    49b6:	0f 90       	pop	r0
    49b8:	0f 90       	pop	r0
    49ba:	0f 90       	pop	r0
    49bc:	cf 91       	pop	r28
    49be:	df 91       	pop	r29
    49c0:	08 95       	ret

000049c2 <Led_OFF>:
void Led_OFF(Led_ID led)
{
    49c2:	df 93       	push	r29
    49c4:	cf 93       	push	r28
    49c6:	00 d0       	rcall	.+0      	; 0x49c8 <Led_OFF+0x6>
    49c8:	0f 92       	push	r0
    49ca:	cd b7       	in	r28, 0x3d	; 61
    49cc:	de b7       	in	r29, 0x3e	; 62
    49ce:	89 83       	std	Y+1, r24	; 0x01
	switch (led)
    49d0:	89 81       	ldd	r24, Y+1	; 0x01
    49d2:	28 2f       	mov	r18, r24
    49d4:	30 e0       	ldi	r19, 0x00	; 0
    49d6:	3b 83       	std	Y+3, r19	; 0x03
    49d8:	2a 83       	std	Y+2, r18	; 0x02
    49da:	8a 81       	ldd	r24, Y+2	; 0x02
    49dc:	9b 81       	ldd	r25, Y+3	; 0x03
    49de:	81 30       	cpi	r24, 0x01	; 1
    49e0:	91 05       	cpc	r25, r1
    49e2:	79 f0       	breq	.+30     	; 0x4a02 <Led_OFF+0x40>
    49e4:	2a 81       	ldd	r18, Y+2	; 0x02
    49e6:	3b 81       	ldd	r19, Y+3	; 0x03
    49e8:	22 30       	cpi	r18, 0x02	; 2
    49ea:	31 05       	cpc	r19, r1
    49ec:	81 f0       	breq	.+32     	; 0x4a0e <Led_OFF+0x4c>
    49ee:	8a 81       	ldd	r24, Y+2	; 0x02
    49f0:	9b 81       	ldd	r25, Y+3	; 0x03
    49f2:	00 97       	sbiw	r24, 0x00	; 0
    49f4:	89 f4       	brne	.+34     	; 0x4a18 <Led_OFF+0x56>
	{
	case LED0:
#if (LED0_CONNECTION == FORWARD)
		DIO_SetPinValue(LED0_PORT,LED0_CHANNEL,LOW);
    49f6:	82 e0       	ldi	r24, 0x02	; 2
    49f8:	62 e0       	ldi	r22, 0x02	; 2
    49fa:	40 e0       	ldi	r20, 0x00	; 0
    49fc:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    4a00:	0b c0       	rjmp	.+22     	; 0x4a18 <Led_OFF+0x56>
#endif

		break;
	case LED1:
#if (LED1_CONNECTION == FORWARD)
		DIO_SetPinValue(LED1_PORT,LED1_CHANNEL,LOW);
    4a02:	82 e0       	ldi	r24, 0x02	; 2
    4a04:	67 e0       	ldi	r22, 0x07	; 7
    4a06:	40 e0       	ldi	r20, 0x00	; 0
    4a08:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    4a0c:	05 c0       	rjmp	.+10     	; 0x4a18 <Led_OFF+0x56>
		DIO_SetPinValue(LED1_PORT,LED1_CHANNEL,HIGH);
#endif
		break;
	case LED2:
#if (LED2_CONNECTION == FORWARD)
		DIO_SetPinValue(LED2_PORT,LED2_CHANNEL,LOW);
    4a0e:	83 e0       	ldi	r24, 0x03	; 3
    4a10:	63 e0       	ldi	r22, 0x03	; 3
    4a12:	40 e0       	ldi	r20, 0x00	; 0
    4a14:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
#elif (LED2_CONNECTION == REVERSE)
		DIO_SetPinValue(LED2_PORT,LED2_CHANNEL,HIGH);
#endif
		break;
	}
}
    4a18:	0f 90       	pop	r0
    4a1a:	0f 90       	pop	r0
    4a1c:	0f 90       	pop	r0
    4a1e:	cf 91       	pop	r28
    4a20:	df 91       	pop	r29
    4a22:	08 95       	ret

00004a24 <Led_Toggle>:
void Led_Toggle(Led_ID led)
{
    4a24:	df 93       	push	r29
    4a26:	cf 93       	push	r28
    4a28:	00 d0       	rcall	.+0      	; 0x4a2a <Led_Toggle+0x6>
    4a2a:	0f 92       	push	r0
    4a2c:	cd b7       	in	r28, 0x3d	; 61
    4a2e:	de b7       	in	r29, 0x3e	; 62
    4a30:	89 83       	std	Y+1, r24	; 0x01
	switch (led)
    4a32:	89 81       	ldd	r24, Y+1	; 0x01
    4a34:	28 2f       	mov	r18, r24
    4a36:	30 e0       	ldi	r19, 0x00	; 0
    4a38:	3b 83       	std	Y+3, r19	; 0x03
    4a3a:	2a 83       	std	Y+2, r18	; 0x02
    4a3c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a3e:	9b 81       	ldd	r25, Y+3	; 0x03
    4a40:	81 30       	cpi	r24, 0x01	; 1
    4a42:	91 05       	cpc	r25, r1
    4a44:	71 f0       	breq	.+28     	; 0x4a62 <Led_Toggle+0x3e>
    4a46:	2a 81       	ldd	r18, Y+2	; 0x02
    4a48:	3b 81       	ldd	r19, Y+3	; 0x03
    4a4a:	22 30       	cpi	r18, 0x02	; 2
    4a4c:	31 05       	cpc	r19, r1
    4a4e:	71 f0       	breq	.+28     	; 0x4a6c <Led_Toggle+0x48>
    4a50:	8a 81       	ldd	r24, Y+2	; 0x02
    4a52:	9b 81       	ldd	r25, Y+3	; 0x03
    4a54:	00 97       	sbiw	r24, 0x00	; 0
    4a56:	71 f4       	brne	.+28     	; 0x4a74 <Led_Toggle+0x50>
	{
	case LED0:
		Dio_FlipChannel(LED0_PORT,LED0_CHANNEL);
    4a58:	82 e0       	ldi	r24, 0x02	; 2
    4a5a:	62 e0       	ldi	r22, 0x02	; 2
    4a5c:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <Dio_FlipChannel>
    4a60:	09 c0       	rjmp	.+18     	; 0x4a74 <Led_Toggle+0x50>
		break;
	case LED1:
		Dio_FlipChannel(LED1_PORT,LED1_CHANNEL);
    4a62:	82 e0       	ldi	r24, 0x02	; 2
    4a64:	67 e0       	ldi	r22, 0x07	; 7
    4a66:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <Dio_FlipChannel>
    4a6a:	04 c0       	rjmp	.+8      	; 0x4a74 <Led_Toggle+0x50>
		break;
	case LED2:
		Dio_FlipChannel(LED2_PORT,LED2_CHANNEL);
    4a6c:	83 e0       	ldi	r24, 0x03	; 3
    4a6e:	63 e0       	ldi	r22, 0x03	; 3
    4a70:	0e 94 f8 22 	call	0x45f0	; 0x45f0 <Dio_FlipChannel>
		break;
	}
}
    4a74:	0f 90       	pop	r0
    4a76:	0f 90       	pop	r0
    4a78:	0f 90       	pop	r0
    4a7a:	cf 91       	pop	r28
    4a7c:	df 91       	pop	r29
    4a7e:	08 95       	ret

00004a80 <LCD_Init>:
#define NULL ((void*) 0)
#endif

/*///////////////////                   8 BIT MODE  //////////  ////////////////////*/
void LCD_Init(void)
{
    4a80:	df 93       	push	r29
    4a82:	cf 93       	push	r28
    4a84:	cd b7       	in	r28, 0x3d	; 61
    4a86:	de b7       	in	r29, 0x3e	; 62
    4a88:	2e 97       	sbiw	r28, 0x0e	; 14
    4a8a:	0f b6       	in	r0, 0x3f	; 63
    4a8c:	f8 94       	cli
    4a8e:	de bf       	out	0x3e, r29	; 62
    4a90:	0f be       	out	0x3f, r0	; 63
    4a92:	cd bf       	out	0x3d, r28	; 61
DIO_SetPortDirection(LCD_DATA_PORT ,OUTPUT);	          /* Make LCD command port direction as o/p */
    4a94:	eb e3       	ldi	r30, 0x3B	; 59
    4a96:	f0 e0       	ldi	r31, 0x00	; 0
    4a98:	80 81       	ld	r24, Z
    4a9a:	61 e0       	ldi	r22, 0x01	; 1
    4a9c:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <DIO_SetPortDirection>
DIO_SetPortDirection(LCD_CONTROL_PORT ,OUTPUT);	         /* Make LCD command port direction as o/p */
    4aa0:	81 e0       	ldi	r24, 0x01	; 1
    4aa2:	61 e0       	ldi	r22, 0x01	; 1
    4aa4:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <DIO_SetPortDirection>
    4aa8:	80 e0       	ldi	r24, 0x00	; 0
    4aaa:	90 e0       	ldi	r25, 0x00	; 0
    4aac:	a0 e7       	ldi	r26, 0x70	; 112
    4aae:	b1 e4       	ldi	r27, 0x41	; 65
    4ab0:	8b 87       	std	Y+11, r24	; 0x0b
    4ab2:	9c 87       	std	Y+12, r25	; 0x0c
    4ab4:	ad 87       	std	Y+13, r26	; 0x0d
    4ab6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4ab8:	6b 85       	ldd	r22, Y+11	; 0x0b
    4aba:	7c 85       	ldd	r23, Y+12	; 0x0c
    4abc:	8d 85       	ldd	r24, Y+13	; 0x0d
    4abe:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ac0:	20 e0       	ldi	r18, 0x00	; 0
    4ac2:	30 e0       	ldi	r19, 0x00	; 0
    4ac4:	4a e7       	ldi	r20, 0x7A	; 122
    4ac6:	55 e4       	ldi	r21, 0x45	; 69
    4ac8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4acc:	dc 01       	movw	r26, r24
    4ace:	cb 01       	movw	r24, r22
    4ad0:	8f 83       	std	Y+7, r24	; 0x07
    4ad2:	98 87       	std	Y+8, r25	; 0x08
    4ad4:	a9 87       	std	Y+9, r26	; 0x09
    4ad6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4ad8:	6f 81       	ldd	r22, Y+7	; 0x07
    4ada:	78 85       	ldd	r23, Y+8	; 0x08
    4adc:	89 85       	ldd	r24, Y+9	; 0x09
    4ade:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ae0:	20 e0       	ldi	r18, 0x00	; 0
    4ae2:	30 e0       	ldi	r19, 0x00	; 0
    4ae4:	40 e8       	ldi	r20, 0x80	; 128
    4ae6:	5f e3       	ldi	r21, 0x3F	; 63
    4ae8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4aec:	88 23       	and	r24, r24
    4aee:	2c f4       	brge	.+10     	; 0x4afa <LCD_Init+0x7a>
		__ticks = 1;
    4af0:	81 e0       	ldi	r24, 0x01	; 1
    4af2:	90 e0       	ldi	r25, 0x00	; 0
    4af4:	9e 83       	std	Y+6, r25	; 0x06
    4af6:	8d 83       	std	Y+5, r24	; 0x05
    4af8:	3f c0       	rjmp	.+126    	; 0x4b78 <LCD_Init+0xf8>
	else if (__tmp > 65535)
    4afa:	6f 81       	ldd	r22, Y+7	; 0x07
    4afc:	78 85       	ldd	r23, Y+8	; 0x08
    4afe:	89 85       	ldd	r24, Y+9	; 0x09
    4b00:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b02:	20 e0       	ldi	r18, 0x00	; 0
    4b04:	3f ef       	ldi	r19, 0xFF	; 255
    4b06:	4f e7       	ldi	r20, 0x7F	; 127
    4b08:	57 e4       	ldi	r21, 0x47	; 71
    4b0a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4b0e:	18 16       	cp	r1, r24
    4b10:	4c f5       	brge	.+82     	; 0x4b64 <LCD_Init+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4b12:	6b 85       	ldd	r22, Y+11	; 0x0b
    4b14:	7c 85       	ldd	r23, Y+12	; 0x0c
    4b16:	8d 85       	ldd	r24, Y+13	; 0x0d
    4b18:	9e 85       	ldd	r25, Y+14	; 0x0e
    4b1a:	20 e0       	ldi	r18, 0x00	; 0
    4b1c:	30 e0       	ldi	r19, 0x00	; 0
    4b1e:	40 e2       	ldi	r20, 0x20	; 32
    4b20:	51 e4       	ldi	r21, 0x41	; 65
    4b22:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b26:	dc 01       	movw	r26, r24
    4b28:	cb 01       	movw	r24, r22
    4b2a:	bc 01       	movw	r22, r24
    4b2c:	cd 01       	movw	r24, r26
    4b2e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b32:	dc 01       	movw	r26, r24
    4b34:	cb 01       	movw	r24, r22
    4b36:	9e 83       	std	Y+6, r25	; 0x06
    4b38:	8d 83       	std	Y+5, r24	; 0x05
    4b3a:	0f c0       	rjmp	.+30     	; 0x4b5a <LCD_Init+0xda>
    4b3c:	80 e9       	ldi	r24, 0x90	; 144
    4b3e:	91 e0       	ldi	r25, 0x01	; 1
    4b40:	9c 83       	std	Y+4, r25	; 0x04
    4b42:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4b44:	8b 81       	ldd	r24, Y+3	; 0x03
    4b46:	9c 81       	ldd	r25, Y+4	; 0x04
    4b48:	01 97       	sbiw	r24, 0x01	; 1
    4b4a:	f1 f7       	brne	.-4      	; 0x4b48 <LCD_Init+0xc8>
    4b4c:	9c 83       	std	Y+4, r25	; 0x04
    4b4e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b50:	8d 81       	ldd	r24, Y+5	; 0x05
    4b52:	9e 81       	ldd	r25, Y+6	; 0x06
    4b54:	01 97       	sbiw	r24, 0x01	; 1
    4b56:	9e 83       	std	Y+6, r25	; 0x06
    4b58:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b5a:	8d 81       	ldd	r24, Y+5	; 0x05
    4b5c:	9e 81       	ldd	r25, Y+6	; 0x06
    4b5e:	00 97       	sbiw	r24, 0x00	; 0
    4b60:	69 f7       	brne	.-38     	; 0x4b3c <LCD_Init+0xbc>
    4b62:	14 c0       	rjmp	.+40     	; 0x4b8c <LCD_Init+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b64:	6f 81       	ldd	r22, Y+7	; 0x07
    4b66:	78 85       	ldd	r23, Y+8	; 0x08
    4b68:	89 85       	ldd	r24, Y+9	; 0x09
    4b6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b70:	dc 01       	movw	r26, r24
    4b72:	cb 01       	movw	r24, r22
    4b74:	9e 83       	std	Y+6, r25	; 0x06
    4b76:	8d 83       	std	Y+5, r24	; 0x05
    4b78:	8d 81       	ldd	r24, Y+5	; 0x05
    4b7a:	9e 81       	ldd	r25, Y+6	; 0x06
    4b7c:	9a 83       	std	Y+2, r25	; 0x02
    4b7e:	89 83       	std	Y+1, r24	; 0x01
    4b80:	89 81       	ldd	r24, Y+1	; 0x01
    4b82:	9a 81       	ldd	r25, Y+2	; 0x02
    4b84:	01 97       	sbiw	r24, 0x01	; 1
    4b86:	f1 f7       	brne	.-4      	; 0x4b84 <LCD_Init+0x104>
    4b88:	9a 83       	std	Y+2, r25	; 0x02
    4b8a:	89 83       	std	Y+1, r24	; 0x01
_delay_ms(15);		/* LCD Power ON delay always >15ms */
LCD_Command (0x38);	/* Initialization of 16X2 LCD in 8bit mode */
    4b8c:	88 e3       	ldi	r24, 0x38	; 56
    4b8e:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <LCD_Command>
LCD_Command (0x0C);	/* Display ON Cursor OFF */
    4b92:	8c e0       	ldi	r24, 0x0C	; 12
    4b94:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <LCD_Command>
LCD_Command (0x06);	/* Auto Increment cursor */
    4b98:	86 e0       	ldi	r24, 0x06	; 6
    4b9a:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <LCD_Command>
LCD_Command (0x01);	/* clear display */
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <LCD_Command>
LCD_Command (0x80);	/* cursor at home position */
    4ba4:	80 e8       	ldi	r24, 0x80	; 128
    4ba6:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <LCD_Command>
}
    4baa:	2e 96       	adiw	r28, 0x0e	; 14
    4bac:	0f b6       	in	r0, 0x3f	; 63
    4bae:	f8 94       	cli
    4bb0:	de bf       	out	0x3e, r29	; 62
    4bb2:	0f be       	out	0x3f, r0	; 63
    4bb4:	cd bf       	out	0x3d, r28	; 61
    4bb6:	cf 91       	pop	r28
    4bb8:	df 91       	pop	r29
    4bba:	08 95       	ret

00004bbc <LCD_WriteChar>:


void LCD_WriteChar(uint_8 Data)	
{
    4bbc:	df 93       	push	r29
    4bbe:	cf 93       	push	r28
    4bc0:	cd b7       	in	r28, 0x3d	; 61
    4bc2:	de b7       	in	r29, 0x3e	; 62
    4bc4:	6d 97       	sbiw	r28, 0x1d	; 29
    4bc6:	0f b6       	in	r0, 0x3f	; 63
    4bc8:	f8 94       	cli
    4bca:	de bf       	out	0x3e, r29	; 62
    4bcc:	0f be       	out	0x3f, r0	; 63
    4bce:	cd bf       	out	0x3d, r28	; 61
    4bd0:	8d 8f       	std	Y+29, r24	; 0x1d
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RS , HIGH);
    4bd2:	81 e0       	ldi	r24, 0x01	; 1
    4bd4:	61 e0       	ldi	r22, 0x01	; 1
    4bd6:	41 e0       	ldi	r20, 0x01	; 1
    4bd8:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RW , LOW);
    4bdc:	81 e0       	ldi	r24, 0x01	; 1
    4bde:	62 e0       	ldi	r22, 0x02	; 2
    4be0:	40 e0       	ldi	r20, 0x00	; 0
    4be2:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , HIGH);
    4be6:	81 e0       	ldi	r24, 0x01	; 1
    4be8:	63 e0       	ldi	r22, 0x03	; 3
    4bea:	41 e0       	ldi	r20, 0x01	; 1
    4bec:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPortValue(LCD_DATA_PORT , Data);
    4bf0:	eb e3       	ldi	r30, 0x3B	; 59
    4bf2:	f0 e0       	ldi	r31, 0x00	; 0
    4bf4:	80 81       	ld	r24, Z
    4bf6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4bf8:	0e 94 bb 20 	call	0x4176	; 0x4176 <DIO_SetPortValue>
    4bfc:	80 e0       	ldi	r24, 0x00	; 0
    4bfe:	90 e0       	ldi	r25, 0x00	; 0
    4c00:	a0 ea       	ldi	r26, 0xA0	; 160
    4c02:	b0 e4       	ldi	r27, 0x40	; 64
    4c04:	89 8f       	std	Y+25, r24	; 0x19
    4c06:	9a 8f       	std	Y+26, r25	; 0x1a
    4c08:	ab 8f       	std	Y+27, r26	; 0x1b
    4c0a:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4c0c:	69 8d       	ldd	r22, Y+25	; 0x19
    4c0e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4c10:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4c12:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4c14:	20 e0       	ldi	r18, 0x00	; 0
    4c16:	30 e0       	ldi	r19, 0x00	; 0
    4c18:	4a e7       	ldi	r20, 0x7A	; 122
    4c1a:	55 e4       	ldi	r21, 0x45	; 69
    4c1c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c20:	dc 01       	movw	r26, r24
    4c22:	cb 01       	movw	r24, r22
    4c24:	8d 8b       	std	Y+21, r24	; 0x15
    4c26:	9e 8b       	std	Y+22, r25	; 0x16
    4c28:	af 8b       	std	Y+23, r26	; 0x17
    4c2a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4c2c:	6d 89       	ldd	r22, Y+21	; 0x15
    4c2e:	7e 89       	ldd	r23, Y+22	; 0x16
    4c30:	8f 89       	ldd	r24, Y+23	; 0x17
    4c32:	98 8d       	ldd	r25, Y+24	; 0x18
    4c34:	20 e0       	ldi	r18, 0x00	; 0
    4c36:	30 e0       	ldi	r19, 0x00	; 0
    4c38:	40 e8       	ldi	r20, 0x80	; 128
    4c3a:	5f e3       	ldi	r21, 0x3F	; 63
    4c3c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4c40:	88 23       	and	r24, r24
    4c42:	2c f4       	brge	.+10     	; 0x4c4e <LCD_WriteChar+0x92>
		__ticks = 1;
    4c44:	81 e0       	ldi	r24, 0x01	; 1
    4c46:	90 e0       	ldi	r25, 0x00	; 0
    4c48:	9c 8b       	std	Y+20, r25	; 0x14
    4c4a:	8b 8b       	std	Y+19, r24	; 0x13
    4c4c:	3f c0       	rjmp	.+126    	; 0x4ccc <LCD_WriteChar+0x110>
	else if (__tmp > 65535)
    4c4e:	6d 89       	ldd	r22, Y+21	; 0x15
    4c50:	7e 89       	ldd	r23, Y+22	; 0x16
    4c52:	8f 89       	ldd	r24, Y+23	; 0x17
    4c54:	98 8d       	ldd	r25, Y+24	; 0x18
    4c56:	20 e0       	ldi	r18, 0x00	; 0
    4c58:	3f ef       	ldi	r19, 0xFF	; 255
    4c5a:	4f e7       	ldi	r20, 0x7F	; 127
    4c5c:	57 e4       	ldi	r21, 0x47	; 71
    4c5e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4c62:	18 16       	cp	r1, r24
    4c64:	4c f5       	brge	.+82     	; 0x4cb8 <LCD_WriteChar+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4c66:	69 8d       	ldd	r22, Y+25	; 0x19
    4c68:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4c6a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4c6c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4c6e:	20 e0       	ldi	r18, 0x00	; 0
    4c70:	30 e0       	ldi	r19, 0x00	; 0
    4c72:	40 e2       	ldi	r20, 0x20	; 32
    4c74:	51 e4       	ldi	r21, 0x41	; 65
    4c76:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c7a:	dc 01       	movw	r26, r24
    4c7c:	cb 01       	movw	r24, r22
    4c7e:	bc 01       	movw	r22, r24
    4c80:	cd 01       	movw	r24, r26
    4c82:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c86:	dc 01       	movw	r26, r24
    4c88:	cb 01       	movw	r24, r22
    4c8a:	9c 8b       	std	Y+20, r25	; 0x14
    4c8c:	8b 8b       	std	Y+19, r24	; 0x13
    4c8e:	0f c0       	rjmp	.+30     	; 0x4cae <LCD_WriteChar+0xf2>
    4c90:	80 e9       	ldi	r24, 0x90	; 144
    4c92:	91 e0       	ldi	r25, 0x01	; 1
    4c94:	9a 8b       	std	Y+18, r25	; 0x12
    4c96:	89 8b       	std	Y+17, r24	; 0x11
    4c98:	89 89       	ldd	r24, Y+17	; 0x11
    4c9a:	9a 89       	ldd	r25, Y+18	; 0x12
    4c9c:	01 97       	sbiw	r24, 0x01	; 1
    4c9e:	f1 f7       	brne	.-4      	; 0x4c9c <LCD_WriteChar+0xe0>
    4ca0:	9a 8b       	std	Y+18, r25	; 0x12
    4ca2:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ca4:	8b 89       	ldd	r24, Y+19	; 0x13
    4ca6:	9c 89       	ldd	r25, Y+20	; 0x14
    4ca8:	01 97       	sbiw	r24, 0x01	; 1
    4caa:	9c 8b       	std	Y+20, r25	; 0x14
    4cac:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4cae:	8b 89       	ldd	r24, Y+19	; 0x13
    4cb0:	9c 89       	ldd	r25, Y+20	; 0x14
    4cb2:	00 97       	sbiw	r24, 0x00	; 0
    4cb4:	69 f7       	brne	.-38     	; 0x4c90 <LCD_WriteChar+0xd4>
    4cb6:	14 c0       	rjmp	.+40     	; 0x4ce0 <LCD_WriteChar+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4cb8:	6d 89       	ldd	r22, Y+21	; 0x15
    4cba:	7e 89       	ldd	r23, Y+22	; 0x16
    4cbc:	8f 89       	ldd	r24, Y+23	; 0x17
    4cbe:	98 8d       	ldd	r25, Y+24	; 0x18
    4cc0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4cc4:	dc 01       	movw	r26, r24
    4cc6:	cb 01       	movw	r24, r22
    4cc8:	9c 8b       	std	Y+20, r25	; 0x14
    4cca:	8b 8b       	std	Y+19, r24	; 0x13
    4ccc:	8b 89       	ldd	r24, Y+19	; 0x13
    4cce:	9c 89       	ldd	r25, Y+20	; 0x14
    4cd0:	98 8b       	std	Y+16, r25	; 0x10
    4cd2:	8f 87       	std	Y+15, r24	; 0x0f
    4cd4:	8f 85       	ldd	r24, Y+15	; 0x0f
    4cd6:	98 89       	ldd	r25, Y+16	; 0x10
    4cd8:	01 97       	sbiw	r24, 0x01	; 1
    4cda:	f1 f7       	brne	.-4      	; 0x4cd8 <LCD_WriteChar+0x11c>
    4cdc:	98 8b       	std	Y+16, r25	; 0x10
    4cde:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , LOW);
    4ce0:	81 e0       	ldi	r24, 0x01	; 1
    4ce2:	63 e0       	ldi	r22, 0x03	; 3
    4ce4:	40 e0       	ldi	r20, 0x00	; 0
    4ce6:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    4cea:	80 e0       	ldi	r24, 0x00	; 0
    4cec:	90 e0       	ldi	r25, 0x00	; 0
    4cee:	a0 ea       	ldi	r26, 0xA0	; 160
    4cf0:	b0 e4       	ldi	r27, 0x40	; 64
    4cf2:	8b 87       	std	Y+11, r24	; 0x0b
    4cf4:	9c 87       	std	Y+12, r25	; 0x0c
    4cf6:	ad 87       	std	Y+13, r26	; 0x0d
    4cf8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4cfa:	6b 85       	ldd	r22, Y+11	; 0x0b
    4cfc:	7c 85       	ldd	r23, Y+12	; 0x0c
    4cfe:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d00:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d02:	20 e0       	ldi	r18, 0x00	; 0
    4d04:	30 e0       	ldi	r19, 0x00	; 0
    4d06:	4a e7       	ldi	r20, 0x7A	; 122
    4d08:	55 e4       	ldi	r21, 0x45	; 69
    4d0a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d0e:	dc 01       	movw	r26, r24
    4d10:	cb 01       	movw	r24, r22
    4d12:	8f 83       	std	Y+7, r24	; 0x07
    4d14:	98 87       	std	Y+8, r25	; 0x08
    4d16:	a9 87       	std	Y+9, r26	; 0x09
    4d18:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4d1a:	6f 81       	ldd	r22, Y+7	; 0x07
    4d1c:	78 85       	ldd	r23, Y+8	; 0x08
    4d1e:	89 85       	ldd	r24, Y+9	; 0x09
    4d20:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d22:	20 e0       	ldi	r18, 0x00	; 0
    4d24:	30 e0       	ldi	r19, 0x00	; 0
    4d26:	40 e8       	ldi	r20, 0x80	; 128
    4d28:	5f e3       	ldi	r21, 0x3F	; 63
    4d2a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4d2e:	88 23       	and	r24, r24
    4d30:	2c f4       	brge	.+10     	; 0x4d3c <LCD_WriteChar+0x180>
		__ticks = 1;
    4d32:	81 e0       	ldi	r24, 0x01	; 1
    4d34:	90 e0       	ldi	r25, 0x00	; 0
    4d36:	9e 83       	std	Y+6, r25	; 0x06
    4d38:	8d 83       	std	Y+5, r24	; 0x05
    4d3a:	3f c0       	rjmp	.+126    	; 0x4dba <LCD_WriteChar+0x1fe>
	else if (__tmp > 65535)
    4d3c:	6f 81       	ldd	r22, Y+7	; 0x07
    4d3e:	78 85       	ldd	r23, Y+8	; 0x08
    4d40:	89 85       	ldd	r24, Y+9	; 0x09
    4d42:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d44:	20 e0       	ldi	r18, 0x00	; 0
    4d46:	3f ef       	ldi	r19, 0xFF	; 255
    4d48:	4f e7       	ldi	r20, 0x7F	; 127
    4d4a:	57 e4       	ldi	r21, 0x47	; 71
    4d4c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4d50:	18 16       	cp	r1, r24
    4d52:	4c f5       	brge	.+82     	; 0x4da6 <LCD_WriteChar+0x1ea>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d54:	6b 85       	ldd	r22, Y+11	; 0x0b
    4d56:	7c 85       	ldd	r23, Y+12	; 0x0c
    4d58:	8d 85       	ldd	r24, Y+13	; 0x0d
    4d5a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4d5c:	20 e0       	ldi	r18, 0x00	; 0
    4d5e:	30 e0       	ldi	r19, 0x00	; 0
    4d60:	40 e2       	ldi	r20, 0x20	; 32
    4d62:	51 e4       	ldi	r21, 0x41	; 65
    4d64:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d68:	dc 01       	movw	r26, r24
    4d6a:	cb 01       	movw	r24, r22
    4d6c:	bc 01       	movw	r22, r24
    4d6e:	cd 01       	movw	r24, r26
    4d70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d74:	dc 01       	movw	r26, r24
    4d76:	cb 01       	movw	r24, r22
    4d78:	9e 83       	std	Y+6, r25	; 0x06
    4d7a:	8d 83       	std	Y+5, r24	; 0x05
    4d7c:	0f c0       	rjmp	.+30     	; 0x4d9c <LCD_WriteChar+0x1e0>
    4d7e:	80 e9       	ldi	r24, 0x90	; 144
    4d80:	91 e0       	ldi	r25, 0x01	; 1
    4d82:	9c 83       	std	Y+4, r25	; 0x04
    4d84:	8b 83       	std	Y+3, r24	; 0x03
    4d86:	8b 81       	ldd	r24, Y+3	; 0x03
    4d88:	9c 81       	ldd	r25, Y+4	; 0x04
    4d8a:	01 97       	sbiw	r24, 0x01	; 1
    4d8c:	f1 f7       	brne	.-4      	; 0x4d8a <LCD_WriteChar+0x1ce>
    4d8e:	9c 83       	std	Y+4, r25	; 0x04
    4d90:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4d92:	8d 81       	ldd	r24, Y+5	; 0x05
    4d94:	9e 81       	ldd	r25, Y+6	; 0x06
    4d96:	01 97       	sbiw	r24, 0x01	; 1
    4d98:	9e 83       	std	Y+6, r25	; 0x06
    4d9a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d9e:	9e 81       	ldd	r25, Y+6	; 0x06
    4da0:	00 97       	sbiw	r24, 0x00	; 0
    4da2:	69 f7       	brne	.-38     	; 0x4d7e <LCD_WriteChar+0x1c2>
    4da4:	14 c0       	rjmp	.+40     	; 0x4dce <LCD_WriteChar+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4da6:	6f 81       	ldd	r22, Y+7	; 0x07
    4da8:	78 85       	ldd	r23, Y+8	; 0x08
    4daa:	89 85       	ldd	r24, Y+9	; 0x09
    4dac:	9a 85       	ldd	r25, Y+10	; 0x0a
    4dae:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4db2:	dc 01       	movw	r26, r24
    4db4:	cb 01       	movw	r24, r22
    4db6:	9e 83       	std	Y+6, r25	; 0x06
    4db8:	8d 83       	std	Y+5, r24	; 0x05
    4dba:	8d 81       	ldd	r24, Y+5	; 0x05
    4dbc:	9e 81       	ldd	r25, Y+6	; 0x06
    4dbe:	9a 83       	std	Y+2, r25	; 0x02
    4dc0:	89 83       	std	Y+1, r24	; 0x01
    4dc2:	89 81       	ldd	r24, Y+1	; 0x01
    4dc4:	9a 81       	ldd	r25, Y+2	; 0x02
    4dc6:	01 97       	sbiw	r24, 0x01	; 1
    4dc8:	f1 f7       	brne	.-4      	; 0x4dc6 <LCD_WriteChar+0x20a>
    4dca:	9a 83       	std	Y+2, r25	; 0x02
    4dcc:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
	
}
    4dce:	6d 96       	adiw	r28, 0x1d	; 29
    4dd0:	0f b6       	in	r0, 0x3f	; 63
    4dd2:	f8 94       	cli
    4dd4:	de bf       	out	0x3e, r29	; 62
    4dd6:	0f be       	out	0x3f, r0	; 63
    4dd8:	cd bf       	out	0x3d, r28	; 61
    4dda:	cf 91       	pop	r28
    4ddc:	df 91       	pop	r29
    4dde:	08 95       	ret

00004de0 <LCD_Command>:
void LCD_Command(uint_8 Data)	
{
    4de0:	df 93       	push	r29
    4de2:	cf 93       	push	r28
    4de4:	cd b7       	in	r28, 0x3d	; 61
    4de6:	de b7       	in	r29, 0x3e	; 62
    4de8:	6d 97       	sbiw	r28, 0x1d	; 29
    4dea:	0f b6       	in	r0, 0x3f	; 63
    4dec:	f8 94       	cli
    4dee:	de bf       	out	0x3e, r29	; 62
    4df0:	0f be       	out	0x3f, r0	; 63
    4df2:	cd bf       	out	0x3d, r28	; 61
    4df4:	8d 8f       	std	Y+29, r24	; 0x1d
	    DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RS , LOW);
    4df6:	81 e0       	ldi	r24, 0x01	; 1
    4df8:	61 e0       	ldi	r22, 0x01	; 1
    4dfa:	40 e0       	ldi	r20, 0x00	; 0
    4dfc:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
		DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RW , LOW);
    4e00:	81 e0       	ldi	r24, 0x01	; 1
    4e02:	62 e0       	ldi	r22, 0x02	; 2
    4e04:	40 e0       	ldi	r20, 0x00	; 0
    4e06:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
		DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , HIGH);
    4e0a:	81 e0       	ldi	r24, 0x01	; 1
    4e0c:	63 e0       	ldi	r22, 0x03	; 3
    4e0e:	41 e0       	ldi	r20, 0x01	; 1
    4e10:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
		DIO_SetPortValue(LCD_DATA_PORT , Data);
    4e14:	eb e3       	ldi	r30, 0x3B	; 59
    4e16:	f0 e0       	ldi	r31, 0x00	; 0
    4e18:	80 81       	ld	r24, Z
    4e1a:	6d 8d       	ldd	r22, Y+29	; 0x1d
    4e1c:	0e 94 bb 20 	call	0x4176	; 0x4176 <DIO_SetPortValue>
    4e20:	80 e0       	ldi	r24, 0x00	; 0
    4e22:	90 e0       	ldi	r25, 0x00	; 0
    4e24:	a0 ea       	ldi	r26, 0xA0	; 160
    4e26:	b0 e4       	ldi	r27, 0x40	; 64
    4e28:	89 8f       	std	Y+25, r24	; 0x19
    4e2a:	9a 8f       	std	Y+26, r25	; 0x1a
    4e2c:	ab 8f       	std	Y+27, r26	; 0x1b
    4e2e:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e30:	69 8d       	ldd	r22, Y+25	; 0x19
    4e32:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4e34:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4e36:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4e38:	20 e0       	ldi	r18, 0x00	; 0
    4e3a:	30 e0       	ldi	r19, 0x00	; 0
    4e3c:	4a e7       	ldi	r20, 0x7A	; 122
    4e3e:	55 e4       	ldi	r21, 0x45	; 69
    4e40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e44:	dc 01       	movw	r26, r24
    4e46:	cb 01       	movw	r24, r22
    4e48:	8d 8b       	std	Y+21, r24	; 0x15
    4e4a:	9e 8b       	std	Y+22, r25	; 0x16
    4e4c:	af 8b       	std	Y+23, r26	; 0x17
    4e4e:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4e50:	6d 89       	ldd	r22, Y+21	; 0x15
    4e52:	7e 89       	ldd	r23, Y+22	; 0x16
    4e54:	8f 89       	ldd	r24, Y+23	; 0x17
    4e56:	98 8d       	ldd	r25, Y+24	; 0x18
    4e58:	20 e0       	ldi	r18, 0x00	; 0
    4e5a:	30 e0       	ldi	r19, 0x00	; 0
    4e5c:	40 e8       	ldi	r20, 0x80	; 128
    4e5e:	5f e3       	ldi	r21, 0x3F	; 63
    4e60:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4e64:	88 23       	and	r24, r24
    4e66:	2c f4       	brge	.+10     	; 0x4e72 <LCD_Command+0x92>
		__ticks = 1;
    4e68:	81 e0       	ldi	r24, 0x01	; 1
    4e6a:	90 e0       	ldi	r25, 0x00	; 0
    4e6c:	9c 8b       	std	Y+20, r25	; 0x14
    4e6e:	8b 8b       	std	Y+19, r24	; 0x13
    4e70:	3f c0       	rjmp	.+126    	; 0x4ef0 <LCD_Command+0x110>
	else if (__tmp > 65535)
    4e72:	6d 89       	ldd	r22, Y+21	; 0x15
    4e74:	7e 89       	ldd	r23, Y+22	; 0x16
    4e76:	8f 89       	ldd	r24, Y+23	; 0x17
    4e78:	98 8d       	ldd	r25, Y+24	; 0x18
    4e7a:	20 e0       	ldi	r18, 0x00	; 0
    4e7c:	3f ef       	ldi	r19, 0xFF	; 255
    4e7e:	4f e7       	ldi	r20, 0x7F	; 127
    4e80:	57 e4       	ldi	r21, 0x47	; 71
    4e82:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4e86:	18 16       	cp	r1, r24
    4e88:	4c f5       	brge	.+82     	; 0x4edc <LCD_Command+0xfc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e8a:	69 8d       	ldd	r22, Y+25	; 0x19
    4e8c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4e8e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4e90:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4e92:	20 e0       	ldi	r18, 0x00	; 0
    4e94:	30 e0       	ldi	r19, 0x00	; 0
    4e96:	40 e2       	ldi	r20, 0x20	; 32
    4e98:	51 e4       	ldi	r21, 0x41	; 65
    4e9a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e9e:	dc 01       	movw	r26, r24
    4ea0:	cb 01       	movw	r24, r22
    4ea2:	bc 01       	movw	r22, r24
    4ea4:	cd 01       	movw	r24, r26
    4ea6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4eaa:	dc 01       	movw	r26, r24
    4eac:	cb 01       	movw	r24, r22
    4eae:	9c 8b       	std	Y+20, r25	; 0x14
    4eb0:	8b 8b       	std	Y+19, r24	; 0x13
    4eb2:	0f c0       	rjmp	.+30     	; 0x4ed2 <LCD_Command+0xf2>
    4eb4:	80 e9       	ldi	r24, 0x90	; 144
    4eb6:	91 e0       	ldi	r25, 0x01	; 1
    4eb8:	9a 8b       	std	Y+18, r25	; 0x12
    4eba:	89 8b       	std	Y+17, r24	; 0x11
    4ebc:	89 89       	ldd	r24, Y+17	; 0x11
    4ebe:	9a 89       	ldd	r25, Y+18	; 0x12
    4ec0:	01 97       	sbiw	r24, 0x01	; 1
    4ec2:	f1 f7       	brne	.-4      	; 0x4ec0 <LCD_Command+0xe0>
    4ec4:	9a 8b       	std	Y+18, r25	; 0x12
    4ec6:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ec8:	8b 89       	ldd	r24, Y+19	; 0x13
    4eca:	9c 89       	ldd	r25, Y+20	; 0x14
    4ecc:	01 97       	sbiw	r24, 0x01	; 1
    4ece:	9c 8b       	std	Y+20, r25	; 0x14
    4ed0:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ed2:	8b 89       	ldd	r24, Y+19	; 0x13
    4ed4:	9c 89       	ldd	r25, Y+20	; 0x14
    4ed6:	00 97       	sbiw	r24, 0x00	; 0
    4ed8:	69 f7       	brne	.-38     	; 0x4eb4 <LCD_Command+0xd4>
    4eda:	14 c0       	rjmp	.+40     	; 0x4f04 <LCD_Command+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4edc:	6d 89       	ldd	r22, Y+21	; 0x15
    4ede:	7e 89       	ldd	r23, Y+22	; 0x16
    4ee0:	8f 89       	ldd	r24, Y+23	; 0x17
    4ee2:	98 8d       	ldd	r25, Y+24	; 0x18
    4ee4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ee8:	dc 01       	movw	r26, r24
    4eea:	cb 01       	movw	r24, r22
    4eec:	9c 8b       	std	Y+20, r25	; 0x14
    4eee:	8b 8b       	std	Y+19, r24	; 0x13
    4ef0:	8b 89       	ldd	r24, Y+19	; 0x13
    4ef2:	9c 89       	ldd	r25, Y+20	; 0x14
    4ef4:	98 8b       	std	Y+16, r25	; 0x10
    4ef6:	8f 87       	std	Y+15, r24	; 0x0f
    4ef8:	8f 85       	ldd	r24, Y+15	; 0x0f
    4efa:	98 89       	ldd	r25, Y+16	; 0x10
    4efc:	01 97       	sbiw	r24, 0x01	; 1
    4efe:	f1 f7       	brne	.-4      	; 0x4efc <LCD_Command+0x11c>
    4f00:	98 8b       	std	Y+16, r25	; 0x10
    4f02:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
			DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , LOW);
    4f04:	81 e0       	ldi	r24, 0x01	; 1
    4f06:	63 e0       	ldi	r22, 0x03	; 3
    4f08:	40 e0       	ldi	r20, 0x00	; 0
    4f0a:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    4f0e:	80 e0       	ldi	r24, 0x00	; 0
    4f10:	90 e0       	ldi	r25, 0x00	; 0
    4f12:	a0 ea       	ldi	r26, 0xA0	; 160
    4f14:	b0 e4       	ldi	r27, 0x40	; 64
    4f16:	8b 87       	std	Y+11, r24	; 0x0b
    4f18:	9c 87       	std	Y+12, r25	; 0x0c
    4f1a:	ad 87       	std	Y+13, r26	; 0x0d
    4f1c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4f1e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f20:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f22:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f24:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f26:	20 e0       	ldi	r18, 0x00	; 0
    4f28:	30 e0       	ldi	r19, 0x00	; 0
    4f2a:	4a e7       	ldi	r20, 0x7A	; 122
    4f2c:	55 e4       	ldi	r21, 0x45	; 69
    4f2e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f32:	dc 01       	movw	r26, r24
    4f34:	cb 01       	movw	r24, r22
    4f36:	8f 83       	std	Y+7, r24	; 0x07
    4f38:	98 87       	std	Y+8, r25	; 0x08
    4f3a:	a9 87       	std	Y+9, r26	; 0x09
    4f3c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4f3e:	6f 81       	ldd	r22, Y+7	; 0x07
    4f40:	78 85       	ldd	r23, Y+8	; 0x08
    4f42:	89 85       	ldd	r24, Y+9	; 0x09
    4f44:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f46:	20 e0       	ldi	r18, 0x00	; 0
    4f48:	30 e0       	ldi	r19, 0x00	; 0
    4f4a:	40 e8       	ldi	r20, 0x80	; 128
    4f4c:	5f e3       	ldi	r21, 0x3F	; 63
    4f4e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    4f52:	88 23       	and	r24, r24
    4f54:	2c f4       	brge	.+10     	; 0x4f60 <LCD_Command+0x180>
		__ticks = 1;
    4f56:	81 e0       	ldi	r24, 0x01	; 1
    4f58:	90 e0       	ldi	r25, 0x00	; 0
    4f5a:	9e 83       	std	Y+6, r25	; 0x06
    4f5c:	8d 83       	std	Y+5, r24	; 0x05
    4f5e:	3f c0       	rjmp	.+126    	; 0x4fde <LCD_Command+0x1fe>
	else if (__tmp > 65535)
    4f60:	6f 81       	ldd	r22, Y+7	; 0x07
    4f62:	78 85       	ldd	r23, Y+8	; 0x08
    4f64:	89 85       	ldd	r24, Y+9	; 0x09
    4f66:	9a 85       	ldd	r25, Y+10	; 0x0a
    4f68:	20 e0       	ldi	r18, 0x00	; 0
    4f6a:	3f ef       	ldi	r19, 0xFF	; 255
    4f6c:	4f e7       	ldi	r20, 0x7F	; 127
    4f6e:	57 e4       	ldi	r21, 0x47	; 71
    4f70:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    4f74:	18 16       	cp	r1, r24
    4f76:	4c f5       	brge	.+82     	; 0x4fca <LCD_Command+0x1ea>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4f78:	6b 85       	ldd	r22, Y+11	; 0x0b
    4f7a:	7c 85       	ldd	r23, Y+12	; 0x0c
    4f7c:	8d 85       	ldd	r24, Y+13	; 0x0d
    4f7e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4f80:	20 e0       	ldi	r18, 0x00	; 0
    4f82:	30 e0       	ldi	r19, 0x00	; 0
    4f84:	40 e2       	ldi	r20, 0x20	; 32
    4f86:	51 e4       	ldi	r21, 0x41	; 65
    4f88:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4f8c:	dc 01       	movw	r26, r24
    4f8e:	cb 01       	movw	r24, r22
    4f90:	bc 01       	movw	r22, r24
    4f92:	cd 01       	movw	r24, r26
    4f94:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4f98:	dc 01       	movw	r26, r24
    4f9a:	cb 01       	movw	r24, r22
    4f9c:	9e 83       	std	Y+6, r25	; 0x06
    4f9e:	8d 83       	std	Y+5, r24	; 0x05
    4fa0:	0f c0       	rjmp	.+30     	; 0x4fc0 <LCD_Command+0x1e0>
    4fa2:	80 e9       	ldi	r24, 0x90	; 144
    4fa4:	91 e0       	ldi	r25, 0x01	; 1
    4fa6:	9c 83       	std	Y+4, r25	; 0x04
    4fa8:	8b 83       	std	Y+3, r24	; 0x03
    4faa:	8b 81       	ldd	r24, Y+3	; 0x03
    4fac:	9c 81       	ldd	r25, Y+4	; 0x04
    4fae:	01 97       	sbiw	r24, 0x01	; 1
    4fb0:	f1 f7       	brne	.-4      	; 0x4fae <LCD_Command+0x1ce>
    4fb2:	9c 83       	std	Y+4, r25	; 0x04
    4fb4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4fb6:	8d 81       	ldd	r24, Y+5	; 0x05
    4fb8:	9e 81       	ldd	r25, Y+6	; 0x06
    4fba:	01 97       	sbiw	r24, 0x01	; 1
    4fbc:	9e 83       	std	Y+6, r25	; 0x06
    4fbe:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4fc0:	8d 81       	ldd	r24, Y+5	; 0x05
    4fc2:	9e 81       	ldd	r25, Y+6	; 0x06
    4fc4:	00 97       	sbiw	r24, 0x00	; 0
    4fc6:	69 f7       	brne	.-38     	; 0x4fa2 <LCD_Command+0x1c2>
    4fc8:	14 c0       	rjmp	.+40     	; 0x4ff2 <LCD_Command+0x212>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4fca:	6f 81       	ldd	r22, Y+7	; 0x07
    4fcc:	78 85       	ldd	r23, Y+8	; 0x08
    4fce:	89 85       	ldd	r24, Y+9	; 0x09
    4fd0:	9a 85       	ldd	r25, Y+10	; 0x0a
    4fd2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4fd6:	dc 01       	movw	r26, r24
    4fd8:	cb 01       	movw	r24, r22
    4fda:	9e 83       	std	Y+6, r25	; 0x06
    4fdc:	8d 83       	std	Y+5, r24	; 0x05
    4fde:	8d 81       	ldd	r24, Y+5	; 0x05
    4fe0:	9e 81       	ldd	r25, Y+6	; 0x06
    4fe2:	9a 83       	std	Y+2, r25	; 0x02
    4fe4:	89 83       	std	Y+1, r24	; 0x01
    4fe6:	89 81       	ldd	r24, Y+1	; 0x01
    4fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    4fea:	01 97       	sbiw	r24, 0x01	; 1
    4fec:	f1 f7       	brne	.-4      	; 0x4fea <LCD_Command+0x20a>
    4fee:	9a 83       	std	Y+2, r25	; 0x02
    4ff0:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(5);
}
    4ff2:	6d 96       	adiw	r28, 0x1d	; 29
    4ff4:	0f b6       	in	r0, 0x3f	; 63
    4ff6:	f8 94       	cli
    4ff8:	de bf       	out	0x3e, r29	; 62
    4ffa:	0f be       	out	0x3f, r0	; 63
    4ffc:	cd bf       	out	0x3d, r28	; 61
    4ffe:	cf 91       	pop	r28
    5000:	df 91       	pop	r29
    5002:	08 95       	ret

00005004 <LCD_WRITE_STRING>:
void LCD_WRITE_STRING(char  STRING[] )
{
    5004:	df 93       	push	r29
    5006:	cf 93       	push	r28
    5008:	00 d0       	rcall	.+0      	; 0x500a <LCD_WRITE_STRING+0x6>
    500a:	0f 92       	push	r0
    500c:	cd b7       	in	r28, 0x3d	; 61
    500e:	de b7       	in	r29, 0x3e	; 62
    5010:	9b 83       	std	Y+3, r25	; 0x03
    5012:	8a 83       	std	Y+2, r24	; 0x02
	uint_8 i = 0;
    5014:	19 82       	std	Y+1, r1	; 0x01
    5016:	0e c0       	rjmp	.+28     	; 0x5034 <LCD_WRITE_STRING+0x30>
	while( STRING[i] != '\0' )
	{
	LCD_WriteChar( STRING[i]);
    5018:	89 81       	ldd	r24, Y+1	; 0x01
    501a:	28 2f       	mov	r18, r24
    501c:	30 e0       	ldi	r19, 0x00	; 0
    501e:	8a 81       	ldd	r24, Y+2	; 0x02
    5020:	9b 81       	ldd	r25, Y+3	; 0x03
    5022:	fc 01       	movw	r30, r24
    5024:	e2 0f       	add	r30, r18
    5026:	f3 1f       	adc	r31, r19
    5028:	80 81       	ld	r24, Z
    502a:	0e 94 de 25 	call	0x4bbc	; 0x4bbc <LCD_WriteChar>
	i++;	
    502e:	89 81       	ldd	r24, Y+1	; 0x01
    5030:	8f 5f       	subi	r24, 0xFF	; 255
    5032:	89 83       	std	Y+1, r24	; 0x01
			_delay_ms(5);
}
void LCD_WRITE_STRING(char  STRING[] )
{
	uint_8 i = 0;
	while( STRING[i] != '\0' )
    5034:	89 81       	ldd	r24, Y+1	; 0x01
    5036:	28 2f       	mov	r18, r24
    5038:	30 e0       	ldi	r19, 0x00	; 0
    503a:	8a 81       	ldd	r24, Y+2	; 0x02
    503c:	9b 81       	ldd	r25, Y+3	; 0x03
    503e:	fc 01       	movw	r30, r24
    5040:	e2 0f       	add	r30, r18
    5042:	f3 1f       	adc	r31, r19
    5044:	80 81       	ld	r24, Z
    5046:	88 23       	and	r24, r24
    5048:	39 f7       	brne	.-50     	; 0x5018 <LCD_WRITE_STRING+0x14>
	LCD_WriteChar( STRING[i]);
	i++;	
	
	}
	
}
    504a:	0f 90       	pop	r0
    504c:	0f 90       	pop	r0
    504e:	0f 90       	pop	r0
    5050:	cf 91       	pop	r28
    5052:	df 91       	pop	r29
    5054:	08 95       	ret

00005056 <LCD_Init_4bit>:
/*///////////////////                   4BIT MODE  //////////  ////////////////////*/

void LCD_Init_4bit (void)  /* LCD Initialize function */
{
    5056:	df 93       	push	r29
    5058:	cf 93       	push	r28
    505a:	cd b7       	in	r28, 0x3d	; 61
    505c:	de b7       	in	r29, 0x3e	; 62
    505e:	2e 97       	sbiw	r28, 0x0e	; 14
    5060:	0f b6       	in	r0, 0x3f	; 63
    5062:	f8 94       	cli
    5064:	de bf       	out	0x3e, r29	; 62
    5066:	0f be       	out	0x3f, r0	; 63
    5068:	cd bf       	out	0x3d, r28	; 61
	DIO_SetPortDirection(LCD_DATA_PORT ,OUTPUT);/* Make LCD Data port direction as o/p */
    506a:	eb e3       	ldi	r30, 0x3B	; 59
    506c:	f0 e0       	ldi	r31, 0x00	; 0
    506e:	80 81       	ld	r24, Z
    5070:	61 e0       	ldi	r22, 0x01	; 1
    5072:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <DIO_SetPortDirection>
	DIO_SetPortDirection(LCD_CONTROL_PORT ,OUTPUT);	  /* Make LCD command port direction as o/p */
    5076:	81 e0       	ldi	r24, 0x01	; 1
    5078:	61 e0       	ldi	r22, 0x01	; 1
    507a:	0e 94 00 1f 	call	0x3e00	; 0x3e00 <DIO_SetPortDirection>
    507e:	80 e0       	ldi	r24, 0x00	; 0
    5080:	90 e0       	ldi	r25, 0x00	; 0
    5082:	a0 e7       	ldi	r26, 0x70	; 112
    5084:	b1 e4       	ldi	r27, 0x41	; 65
    5086:	8b 87       	std	Y+11, r24	; 0x0b
    5088:	9c 87       	std	Y+12, r25	; 0x0c
    508a:	ad 87       	std	Y+13, r26	; 0x0d
    508c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    508e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5090:	7c 85       	ldd	r23, Y+12	; 0x0c
    5092:	8d 85       	ldd	r24, Y+13	; 0x0d
    5094:	9e 85       	ldd	r25, Y+14	; 0x0e
    5096:	20 e0       	ldi	r18, 0x00	; 0
    5098:	30 e0       	ldi	r19, 0x00	; 0
    509a:	4a e7       	ldi	r20, 0x7A	; 122
    509c:	55 e4       	ldi	r21, 0x45	; 69
    509e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    50a2:	dc 01       	movw	r26, r24
    50a4:	cb 01       	movw	r24, r22
    50a6:	8f 83       	std	Y+7, r24	; 0x07
    50a8:	98 87       	std	Y+8, r25	; 0x08
    50aa:	a9 87       	std	Y+9, r26	; 0x09
    50ac:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    50ae:	6f 81       	ldd	r22, Y+7	; 0x07
    50b0:	78 85       	ldd	r23, Y+8	; 0x08
    50b2:	89 85       	ldd	r24, Y+9	; 0x09
    50b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    50b6:	20 e0       	ldi	r18, 0x00	; 0
    50b8:	30 e0       	ldi	r19, 0x00	; 0
    50ba:	40 e8       	ldi	r20, 0x80	; 128
    50bc:	5f e3       	ldi	r21, 0x3F	; 63
    50be:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    50c2:	88 23       	and	r24, r24
    50c4:	2c f4       	brge	.+10     	; 0x50d0 <LCD_Init_4bit+0x7a>
		__ticks = 1;
    50c6:	81 e0       	ldi	r24, 0x01	; 1
    50c8:	90 e0       	ldi	r25, 0x00	; 0
    50ca:	9e 83       	std	Y+6, r25	; 0x06
    50cc:	8d 83       	std	Y+5, r24	; 0x05
    50ce:	3f c0       	rjmp	.+126    	; 0x514e <LCD_Init_4bit+0xf8>
	else if (__tmp > 65535)
    50d0:	6f 81       	ldd	r22, Y+7	; 0x07
    50d2:	78 85       	ldd	r23, Y+8	; 0x08
    50d4:	89 85       	ldd	r24, Y+9	; 0x09
    50d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    50d8:	20 e0       	ldi	r18, 0x00	; 0
    50da:	3f ef       	ldi	r19, 0xFF	; 255
    50dc:	4f e7       	ldi	r20, 0x7F	; 127
    50de:	57 e4       	ldi	r21, 0x47	; 71
    50e0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    50e4:	18 16       	cp	r1, r24
    50e6:	4c f5       	brge	.+82     	; 0x513a <LCD_Init_4bit+0xe4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    50e8:	6b 85       	ldd	r22, Y+11	; 0x0b
    50ea:	7c 85       	ldd	r23, Y+12	; 0x0c
    50ec:	8d 85       	ldd	r24, Y+13	; 0x0d
    50ee:	9e 85       	ldd	r25, Y+14	; 0x0e
    50f0:	20 e0       	ldi	r18, 0x00	; 0
    50f2:	30 e0       	ldi	r19, 0x00	; 0
    50f4:	40 e2       	ldi	r20, 0x20	; 32
    50f6:	51 e4       	ldi	r21, 0x41	; 65
    50f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    50fc:	dc 01       	movw	r26, r24
    50fe:	cb 01       	movw	r24, r22
    5100:	bc 01       	movw	r22, r24
    5102:	cd 01       	movw	r24, r26
    5104:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5108:	dc 01       	movw	r26, r24
    510a:	cb 01       	movw	r24, r22
    510c:	9e 83       	std	Y+6, r25	; 0x06
    510e:	8d 83       	std	Y+5, r24	; 0x05
    5110:	0f c0       	rjmp	.+30     	; 0x5130 <LCD_Init_4bit+0xda>
    5112:	80 e9       	ldi	r24, 0x90	; 144
    5114:	91 e0       	ldi	r25, 0x01	; 1
    5116:	9c 83       	std	Y+4, r25	; 0x04
    5118:	8b 83       	std	Y+3, r24	; 0x03
    511a:	8b 81       	ldd	r24, Y+3	; 0x03
    511c:	9c 81       	ldd	r25, Y+4	; 0x04
    511e:	01 97       	sbiw	r24, 0x01	; 1
    5120:	f1 f7       	brne	.-4      	; 0x511e <LCD_Init_4bit+0xc8>
    5122:	9c 83       	std	Y+4, r25	; 0x04
    5124:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5126:	8d 81       	ldd	r24, Y+5	; 0x05
    5128:	9e 81       	ldd	r25, Y+6	; 0x06
    512a:	01 97       	sbiw	r24, 0x01	; 1
    512c:	9e 83       	std	Y+6, r25	; 0x06
    512e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5130:	8d 81       	ldd	r24, Y+5	; 0x05
    5132:	9e 81       	ldd	r25, Y+6	; 0x06
    5134:	00 97       	sbiw	r24, 0x00	; 0
    5136:	69 f7       	brne	.-38     	; 0x5112 <LCD_Init_4bit+0xbc>
    5138:	14 c0       	rjmp	.+40     	; 0x5162 <LCD_Init_4bit+0x10c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    513a:	6f 81       	ldd	r22, Y+7	; 0x07
    513c:	78 85       	ldd	r23, Y+8	; 0x08
    513e:	89 85       	ldd	r24, Y+9	; 0x09
    5140:	9a 85       	ldd	r25, Y+10	; 0x0a
    5142:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5146:	dc 01       	movw	r26, r24
    5148:	cb 01       	movw	r24, r22
    514a:	9e 83       	std	Y+6, r25	; 0x06
    514c:	8d 83       	std	Y+5, r24	; 0x05
    514e:	8d 81       	ldd	r24, Y+5	; 0x05
    5150:	9e 81       	ldd	r25, Y+6	; 0x06
    5152:	9a 83       	std	Y+2, r25	; 0x02
    5154:	89 83       	std	Y+1, r24	; 0x01
    5156:	89 81       	ldd	r24, Y+1	; 0x01
    5158:	9a 81       	ldd	r25, Y+2	; 0x02
    515a:	01 97       	sbiw	r24, 0x01	; 1
    515c:	f1 f7       	brne	.-4      	; 0x515a <LCD_Init_4bit+0x104>
    515e:	9a 83       	std	Y+2, r25	; 0x02
    5160:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(15);		/* LCD Power ON delay always >15ms */
	
	LCD_Command_4bit(0x33);
    5162:	83 e3       	ldi	r24, 0x33	; 51
    5164:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
	LCD_Command_4bit(0x32);	/* Send for 4 bit initialization of LCD  */
    5168:	82 e3       	ldi	r24, 0x32	; 50
    516a:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
	LCD_Command_4bit(0x28);	/* 2 line, 5*7 matrix in 4-bit mode */
    516e:	88 e2       	ldi	r24, 0x28	; 40
    5170:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
	LCD_Command_4bit(0x0c);	/* Display on cursor off */
    5174:	8c e0       	ldi	r24, 0x0C	; 12
    5176:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
	LCD_Command_4bit(0x06);	/* Increment cursor (shift cursor to right) */
    517a:	86 e0       	ldi	r24, 0x06	; 6
    517c:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
	LCD_Command_4bit(0x01);	/* Clear display screen */
    5180:	81 e0       	ldi	r24, 0x01	; 1
    5182:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
}
    5186:	2e 96       	adiw	r28, 0x0e	; 14
    5188:	0f b6       	in	r0, 0x3f	; 63
    518a:	f8 94       	cli
    518c:	de bf       	out	0x3e, r29	; 62
    518e:	0f be       	out	0x3f, r0	; 63
    5190:	cd bf       	out	0x3d, r28	; 61
    5192:	cf 91       	pop	r28
    5194:	df 91       	pop	r29
    5196:	08 95       	ret

00005198 <LCD_Command_4bit>:


void LCD_Command_4bit( uint_8 CMD )
{
    5198:	df 93       	push	r29
    519a:	cf 93       	push	r28
    519c:	cd b7       	in	r28, 0x3d	; 61
    519e:	de b7       	in	r29, 0x3e	; 62
    51a0:	e9 97       	sbiw	r28, 0x39	; 57
    51a2:	0f b6       	in	r0, 0x3f	; 63
    51a4:	f8 94       	cli
    51a6:	de bf       	out	0x3e, r29	; 62
    51a8:	0f be       	out	0x3f, r0	; 63
    51aa:	cd bf       	out	0x3d, r28	; 61
    51ac:	89 af       	std	Y+57, r24	; 0x39
	 LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (CMD & 0xF0);   /* Sending upper nibble */
    51ae:	ab e3       	ldi	r26, 0x3B	; 59
    51b0:	b0 e0       	ldi	r27, 0x00	; 0
    51b2:	eb e3       	ldi	r30, 0x3B	; 59
    51b4:	f0 e0       	ldi	r31, 0x00	; 0
    51b6:	80 81       	ld	r24, Z
    51b8:	98 2f       	mov	r25, r24
    51ba:	9f 70       	andi	r25, 0x0F	; 15
    51bc:	89 ad       	ldd	r24, Y+57	; 0x39
    51be:	80 7f       	andi	r24, 0xF0	; 240
    51c0:	89 2b       	or	r24, r25
    51c2:	8c 93       	st	X, r24
	 DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RS , LOW);
    51c4:	81 e0       	ldi	r24, 0x01	; 1
    51c6:	61 e0       	ldi	r22, 0x01	; 1
    51c8:	40 e0       	ldi	r20, 0x00	; 0
    51ca:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	 DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RW , LOW);
    51ce:	81 e0       	ldi	r24, 0x01	; 1
    51d0:	62 e0       	ldi	r22, 0x02	; 2
    51d2:	40 e0       	ldi	r20, 0x00	; 0
    51d4:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	 DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , HIGH);
    51d8:	81 e0       	ldi	r24, 0x01	; 1
    51da:	63 e0       	ldi	r22, 0x03	; 3
    51dc:	41 e0       	ldi	r20, 0x01	; 1
    51de:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    51e2:	80 e0       	ldi	r24, 0x00	; 0
    51e4:	90 e0       	ldi	r25, 0x00	; 0
    51e6:	a0 ea       	ldi	r26, 0xA0	; 160
    51e8:	b0 e4       	ldi	r27, 0x40	; 64
    51ea:	8d ab       	std	Y+53, r24	; 0x35
    51ec:	9e ab       	std	Y+54, r25	; 0x36
    51ee:	af ab       	std	Y+55, r26	; 0x37
    51f0:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    51f2:	6d a9       	ldd	r22, Y+53	; 0x35
    51f4:	7e a9       	ldd	r23, Y+54	; 0x36
    51f6:	8f a9       	ldd	r24, Y+55	; 0x37
    51f8:	98 ad       	ldd	r25, Y+56	; 0x38
    51fa:	20 e0       	ldi	r18, 0x00	; 0
    51fc:	30 e0       	ldi	r19, 0x00	; 0
    51fe:	4a e7       	ldi	r20, 0x7A	; 122
    5200:	55 e4       	ldi	r21, 0x45	; 69
    5202:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5206:	dc 01       	movw	r26, r24
    5208:	cb 01       	movw	r24, r22
    520a:	89 ab       	std	Y+49, r24	; 0x31
    520c:	9a ab       	std	Y+50, r25	; 0x32
    520e:	ab ab       	std	Y+51, r26	; 0x33
    5210:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5212:	69 a9       	ldd	r22, Y+49	; 0x31
    5214:	7a a9       	ldd	r23, Y+50	; 0x32
    5216:	8b a9       	ldd	r24, Y+51	; 0x33
    5218:	9c a9       	ldd	r25, Y+52	; 0x34
    521a:	20 e0       	ldi	r18, 0x00	; 0
    521c:	30 e0       	ldi	r19, 0x00	; 0
    521e:	40 e8       	ldi	r20, 0x80	; 128
    5220:	5f e3       	ldi	r21, 0x3F	; 63
    5222:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5226:	88 23       	and	r24, r24
    5228:	2c f4       	brge	.+10     	; 0x5234 <LCD_Command_4bit+0x9c>
		__ticks = 1;
    522a:	81 e0       	ldi	r24, 0x01	; 1
    522c:	90 e0       	ldi	r25, 0x00	; 0
    522e:	98 ab       	std	Y+48, r25	; 0x30
    5230:	8f a7       	std	Y+47, r24	; 0x2f
    5232:	3f c0       	rjmp	.+126    	; 0x52b2 <LCD_Command_4bit+0x11a>
	else if (__tmp > 65535)
    5234:	69 a9       	ldd	r22, Y+49	; 0x31
    5236:	7a a9       	ldd	r23, Y+50	; 0x32
    5238:	8b a9       	ldd	r24, Y+51	; 0x33
    523a:	9c a9       	ldd	r25, Y+52	; 0x34
    523c:	20 e0       	ldi	r18, 0x00	; 0
    523e:	3f ef       	ldi	r19, 0xFF	; 255
    5240:	4f e7       	ldi	r20, 0x7F	; 127
    5242:	57 e4       	ldi	r21, 0x47	; 71
    5244:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5248:	18 16       	cp	r1, r24
    524a:	4c f5       	brge	.+82     	; 0x529e <LCD_Command_4bit+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    524c:	6d a9       	ldd	r22, Y+53	; 0x35
    524e:	7e a9       	ldd	r23, Y+54	; 0x36
    5250:	8f a9       	ldd	r24, Y+55	; 0x37
    5252:	98 ad       	ldd	r25, Y+56	; 0x38
    5254:	20 e0       	ldi	r18, 0x00	; 0
    5256:	30 e0       	ldi	r19, 0x00	; 0
    5258:	40 e2       	ldi	r20, 0x20	; 32
    525a:	51 e4       	ldi	r21, 0x41	; 65
    525c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5260:	dc 01       	movw	r26, r24
    5262:	cb 01       	movw	r24, r22
    5264:	bc 01       	movw	r22, r24
    5266:	cd 01       	movw	r24, r26
    5268:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    526c:	dc 01       	movw	r26, r24
    526e:	cb 01       	movw	r24, r22
    5270:	98 ab       	std	Y+48, r25	; 0x30
    5272:	8f a7       	std	Y+47, r24	; 0x2f
    5274:	0f c0       	rjmp	.+30     	; 0x5294 <LCD_Command_4bit+0xfc>
    5276:	80 e9       	ldi	r24, 0x90	; 144
    5278:	91 e0       	ldi	r25, 0x01	; 1
    527a:	9e a7       	std	Y+46, r25	; 0x2e
    527c:	8d a7       	std	Y+45, r24	; 0x2d
    527e:	8d a5       	ldd	r24, Y+45	; 0x2d
    5280:	9e a5       	ldd	r25, Y+46	; 0x2e
    5282:	01 97       	sbiw	r24, 0x01	; 1
    5284:	f1 f7       	brne	.-4      	; 0x5282 <LCD_Command_4bit+0xea>
    5286:	9e a7       	std	Y+46, r25	; 0x2e
    5288:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    528a:	8f a5       	ldd	r24, Y+47	; 0x2f
    528c:	98 a9       	ldd	r25, Y+48	; 0x30
    528e:	01 97       	sbiw	r24, 0x01	; 1
    5290:	98 ab       	std	Y+48, r25	; 0x30
    5292:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5294:	8f a5       	ldd	r24, Y+47	; 0x2f
    5296:	98 a9       	ldd	r25, Y+48	; 0x30
    5298:	00 97       	sbiw	r24, 0x00	; 0
    529a:	69 f7       	brne	.-38     	; 0x5276 <LCD_Command_4bit+0xde>
    529c:	14 c0       	rjmp	.+40     	; 0x52c6 <LCD_Command_4bit+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    529e:	69 a9       	ldd	r22, Y+49	; 0x31
    52a0:	7a a9       	ldd	r23, Y+50	; 0x32
    52a2:	8b a9       	ldd	r24, Y+51	; 0x33
    52a4:	9c a9       	ldd	r25, Y+52	; 0x34
    52a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    52aa:	dc 01       	movw	r26, r24
    52ac:	cb 01       	movw	r24, r22
    52ae:	98 ab       	std	Y+48, r25	; 0x30
    52b0:	8f a7       	std	Y+47, r24	; 0x2f
    52b2:	8f a5       	ldd	r24, Y+47	; 0x2f
    52b4:	98 a9       	ldd	r25, Y+48	; 0x30
    52b6:	9c a7       	std	Y+44, r25	; 0x2c
    52b8:	8b a7       	std	Y+43, r24	; 0x2b
    52ba:	8b a5       	ldd	r24, Y+43	; 0x2b
    52bc:	9c a5       	ldd	r25, Y+44	; 0x2c
    52be:	01 97       	sbiw	r24, 0x01	; 1
    52c0:	f1 f7       	brne	.-4      	; 0x52be <LCD_Command_4bit+0x126>
    52c2:	9c a7       	std	Y+44, r25	; 0x2c
    52c4:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(5);
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , LOW);
    52c6:	81 e0       	ldi	r24, 0x01	; 1
    52c8:	63 e0       	ldi	r22, 0x03	; 3
    52ca:	40 e0       	ldi	r20, 0x00	; 0
    52cc:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    52d0:	80 e0       	ldi	r24, 0x00	; 0
    52d2:	90 e0       	ldi	r25, 0x00	; 0
    52d4:	a0 ea       	ldi	r26, 0xA0	; 160
    52d6:	b0 e4       	ldi	r27, 0x40	; 64
    52d8:	8f a3       	std	Y+39, r24	; 0x27
    52da:	98 a7       	std	Y+40, r25	; 0x28
    52dc:	a9 a7       	std	Y+41, r26	; 0x29
    52de:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    52e0:	6f a1       	ldd	r22, Y+39	; 0x27
    52e2:	78 a5       	ldd	r23, Y+40	; 0x28
    52e4:	89 a5       	ldd	r24, Y+41	; 0x29
    52e6:	9a a5       	ldd	r25, Y+42	; 0x2a
    52e8:	20 e0       	ldi	r18, 0x00	; 0
    52ea:	30 e0       	ldi	r19, 0x00	; 0
    52ec:	4a e7       	ldi	r20, 0x7A	; 122
    52ee:	55 e4       	ldi	r21, 0x45	; 69
    52f0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    52f4:	dc 01       	movw	r26, r24
    52f6:	cb 01       	movw	r24, r22
    52f8:	8b a3       	std	Y+35, r24	; 0x23
    52fa:	9c a3       	std	Y+36, r25	; 0x24
    52fc:	ad a3       	std	Y+37, r26	; 0x25
    52fe:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    5300:	6b a1       	ldd	r22, Y+35	; 0x23
    5302:	7c a1       	ldd	r23, Y+36	; 0x24
    5304:	8d a1       	ldd	r24, Y+37	; 0x25
    5306:	9e a1       	ldd	r25, Y+38	; 0x26
    5308:	20 e0       	ldi	r18, 0x00	; 0
    530a:	30 e0       	ldi	r19, 0x00	; 0
    530c:	40 e8       	ldi	r20, 0x80	; 128
    530e:	5f e3       	ldi	r21, 0x3F	; 63
    5310:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5314:	88 23       	and	r24, r24
    5316:	2c f4       	brge	.+10     	; 0x5322 <LCD_Command_4bit+0x18a>
		__ticks = 1;
    5318:	81 e0       	ldi	r24, 0x01	; 1
    531a:	90 e0       	ldi	r25, 0x00	; 0
    531c:	9a a3       	std	Y+34, r25	; 0x22
    531e:	89 a3       	std	Y+33, r24	; 0x21
    5320:	3f c0       	rjmp	.+126    	; 0x53a0 <LCD_Command_4bit+0x208>
	else if (__tmp > 65535)
    5322:	6b a1       	ldd	r22, Y+35	; 0x23
    5324:	7c a1       	ldd	r23, Y+36	; 0x24
    5326:	8d a1       	ldd	r24, Y+37	; 0x25
    5328:	9e a1       	ldd	r25, Y+38	; 0x26
    532a:	20 e0       	ldi	r18, 0x00	; 0
    532c:	3f ef       	ldi	r19, 0xFF	; 255
    532e:	4f e7       	ldi	r20, 0x7F	; 127
    5330:	57 e4       	ldi	r21, 0x47	; 71
    5332:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5336:	18 16       	cp	r1, r24
    5338:	4c f5       	brge	.+82     	; 0x538c <LCD_Command_4bit+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    533a:	6f a1       	ldd	r22, Y+39	; 0x27
    533c:	78 a5       	ldd	r23, Y+40	; 0x28
    533e:	89 a5       	ldd	r24, Y+41	; 0x29
    5340:	9a a5       	ldd	r25, Y+42	; 0x2a
    5342:	20 e0       	ldi	r18, 0x00	; 0
    5344:	30 e0       	ldi	r19, 0x00	; 0
    5346:	40 e2       	ldi	r20, 0x20	; 32
    5348:	51 e4       	ldi	r21, 0x41	; 65
    534a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    534e:	dc 01       	movw	r26, r24
    5350:	cb 01       	movw	r24, r22
    5352:	bc 01       	movw	r22, r24
    5354:	cd 01       	movw	r24, r26
    5356:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    535a:	dc 01       	movw	r26, r24
    535c:	cb 01       	movw	r24, r22
    535e:	9a a3       	std	Y+34, r25	; 0x22
    5360:	89 a3       	std	Y+33, r24	; 0x21
    5362:	0f c0       	rjmp	.+30     	; 0x5382 <LCD_Command_4bit+0x1ea>
    5364:	80 e9       	ldi	r24, 0x90	; 144
    5366:	91 e0       	ldi	r25, 0x01	; 1
    5368:	98 a3       	std	Y+32, r25	; 0x20
    536a:	8f 8f       	std	Y+31, r24	; 0x1f
    536c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    536e:	98 a1       	ldd	r25, Y+32	; 0x20
    5370:	01 97       	sbiw	r24, 0x01	; 1
    5372:	f1 f7       	brne	.-4      	; 0x5370 <LCD_Command_4bit+0x1d8>
    5374:	98 a3       	std	Y+32, r25	; 0x20
    5376:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5378:	89 a1       	ldd	r24, Y+33	; 0x21
    537a:	9a a1       	ldd	r25, Y+34	; 0x22
    537c:	01 97       	sbiw	r24, 0x01	; 1
    537e:	9a a3       	std	Y+34, r25	; 0x22
    5380:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5382:	89 a1       	ldd	r24, Y+33	; 0x21
    5384:	9a a1       	ldd	r25, Y+34	; 0x22
    5386:	00 97       	sbiw	r24, 0x00	; 0
    5388:	69 f7       	brne	.-38     	; 0x5364 <LCD_Command_4bit+0x1cc>
    538a:	14 c0       	rjmp	.+40     	; 0x53b4 <LCD_Command_4bit+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    538c:	6b a1       	ldd	r22, Y+35	; 0x23
    538e:	7c a1       	ldd	r23, Y+36	; 0x24
    5390:	8d a1       	ldd	r24, Y+37	; 0x25
    5392:	9e a1       	ldd	r25, Y+38	; 0x26
    5394:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5398:	dc 01       	movw	r26, r24
    539a:	cb 01       	movw	r24, r22
    539c:	9a a3       	std	Y+34, r25	; 0x22
    539e:	89 a3       	std	Y+33, r24	; 0x21
    53a0:	89 a1       	ldd	r24, Y+33	; 0x21
    53a2:	9a a1       	ldd	r25, Y+34	; 0x22
    53a4:	9e 8f       	std	Y+30, r25	; 0x1e
    53a6:	8d 8f       	std	Y+29, r24	; 0x1d
    53a8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    53aa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    53ac:	01 97       	sbiw	r24, 0x01	; 1
    53ae:	f1 f7       	brne	.-4      	; 0x53ac <LCD_Command_4bit+0x214>
    53b0:	9e 8f       	std	Y+30, r25	; 0x1e
    53b2:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(5);
	
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (CMD << 4);            /* Sending lower nibble */
    53b4:	ab e3       	ldi	r26, 0x3B	; 59
    53b6:	b0 e0       	ldi	r27, 0x00	; 0
    53b8:	eb e3       	ldi	r30, 0x3B	; 59
    53ba:	f0 e0       	ldi	r31, 0x00	; 0
    53bc:	80 81       	ld	r24, Z
    53be:	28 2f       	mov	r18, r24
    53c0:	2f 70       	andi	r18, 0x0F	; 15
    53c2:	89 ad       	ldd	r24, Y+57	; 0x39
    53c4:	88 2f       	mov	r24, r24
    53c6:	90 e0       	ldi	r25, 0x00	; 0
    53c8:	82 95       	swap	r24
    53ca:	92 95       	swap	r25
    53cc:	90 7f       	andi	r25, 0xF0	; 240
    53ce:	98 27       	eor	r25, r24
    53d0:	80 7f       	andi	r24, 0xF0	; 240
    53d2:	98 27       	eor	r25, r24
    53d4:	82 2b       	or	r24, r18
    53d6:	8c 93       	st	X, r24
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RS , LOW);
    53d8:	81 e0       	ldi	r24, 0x01	; 1
    53da:	61 e0       	ldi	r22, 0x01	; 1
    53dc:	40 e0       	ldi	r20, 0x00	; 0
    53de:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RW , LOW);
    53e2:	81 e0       	ldi	r24, 0x01	; 1
    53e4:	62 e0       	ldi	r22, 0x02	; 2
    53e6:	40 e0       	ldi	r20, 0x00	; 0
    53e8:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , HIGH);
    53ec:	81 e0       	ldi	r24, 0x01	; 1
    53ee:	63 e0       	ldi	r22, 0x03	; 3
    53f0:	41 e0       	ldi	r20, 0x01	; 1
    53f2:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    53f6:	80 e0       	ldi	r24, 0x00	; 0
    53f8:	90 e0       	ldi	r25, 0x00	; 0
    53fa:	a0 ea       	ldi	r26, 0xA0	; 160
    53fc:	b0 e4       	ldi	r27, 0x40	; 64
    53fe:	89 8f       	std	Y+25, r24	; 0x19
    5400:	9a 8f       	std	Y+26, r25	; 0x1a
    5402:	ab 8f       	std	Y+27, r26	; 0x1b
    5404:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5406:	69 8d       	ldd	r22, Y+25	; 0x19
    5408:	7a 8d       	ldd	r23, Y+26	; 0x1a
    540a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    540c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    540e:	20 e0       	ldi	r18, 0x00	; 0
    5410:	30 e0       	ldi	r19, 0x00	; 0
    5412:	4a e7       	ldi	r20, 0x7A	; 122
    5414:	55 e4       	ldi	r21, 0x45	; 69
    5416:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    541a:	dc 01       	movw	r26, r24
    541c:	cb 01       	movw	r24, r22
    541e:	8d 8b       	std	Y+21, r24	; 0x15
    5420:	9e 8b       	std	Y+22, r25	; 0x16
    5422:	af 8b       	std	Y+23, r26	; 0x17
    5424:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5426:	6d 89       	ldd	r22, Y+21	; 0x15
    5428:	7e 89       	ldd	r23, Y+22	; 0x16
    542a:	8f 89       	ldd	r24, Y+23	; 0x17
    542c:	98 8d       	ldd	r25, Y+24	; 0x18
    542e:	20 e0       	ldi	r18, 0x00	; 0
    5430:	30 e0       	ldi	r19, 0x00	; 0
    5432:	40 e8       	ldi	r20, 0x80	; 128
    5434:	5f e3       	ldi	r21, 0x3F	; 63
    5436:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    543a:	88 23       	and	r24, r24
    543c:	2c f4       	brge	.+10     	; 0x5448 <LCD_Command_4bit+0x2b0>
		__ticks = 1;
    543e:	81 e0       	ldi	r24, 0x01	; 1
    5440:	90 e0       	ldi	r25, 0x00	; 0
    5442:	9c 8b       	std	Y+20, r25	; 0x14
    5444:	8b 8b       	std	Y+19, r24	; 0x13
    5446:	3f c0       	rjmp	.+126    	; 0x54c6 <LCD_Command_4bit+0x32e>
	else if (__tmp > 65535)
    5448:	6d 89       	ldd	r22, Y+21	; 0x15
    544a:	7e 89       	ldd	r23, Y+22	; 0x16
    544c:	8f 89       	ldd	r24, Y+23	; 0x17
    544e:	98 8d       	ldd	r25, Y+24	; 0x18
    5450:	20 e0       	ldi	r18, 0x00	; 0
    5452:	3f ef       	ldi	r19, 0xFF	; 255
    5454:	4f e7       	ldi	r20, 0x7F	; 127
    5456:	57 e4       	ldi	r21, 0x47	; 71
    5458:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    545c:	18 16       	cp	r1, r24
    545e:	4c f5       	brge	.+82     	; 0x54b2 <LCD_Command_4bit+0x31a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5460:	69 8d       	ldd	r22, Y+25	; 0x19
    5462:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5464:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5466:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5468:	20 e0       	ldi	r18, 0x00	; 0
    546a:	30 e0       	ldi	r19, 0x00	; 0
    546c:	40 e2       	ldi	r20, 0x20	; 32
    546e:	51 e4       	ldi	r21, 0x41	; 65
    5470:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5474:	dc 01       	movw	r26, r24
    5476:	cb 01       	movw	r24, r22
    5478:	bc 01       	movw	r22, r24
    547a:	cd 01       	movw	r24, r26
    547c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5480:	dc 01       	movw	r26, r24
    5482:	cb 01       	movw	r24, r22
    5484:	9c 8b       	std	Y+20, r25	; 0x14
    5486:	8b 8b       	std	Y+19, r24	; 0x13
    5488:	0f c0       	rjmp	.+30     	; 0x54a8 <LCD_Command_4bit+0x310>
    548a:	80 e9       	ldi	r24, 0x90	; 144
    548c:	91 e0       	ldi	r25, 0x01	; 1
    548e:	9a 8b       	std	Y+18, r25	; 0x12
    5490:	89 8b       	std	Y+17, r24	; 0x11
    5492:	89 89       	ldd	r24, Y+17	; 0x11
    5494:	9a 89       	ldd	r25, Y+18	; 0x12
    5496:	01 97       	sbiw	r24, 0x01	; 1
    5498:	f1 f7       	brne	.-4      	; 0x5496 <LCD_Command_4bit+0x2fe>
    549a:	9a 8b       	std	Y+18, r25	; 0x12
    549c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    549e:	8b 89       	ldd	r24, Y+19	; 0x13
    54a0:	9c 89       	ldd	r25, Y+20	; 0x14
    54a2:	01 97       	sbiw	r24, 0x01	; 1
    54a4:	9c 8b       	std	Y+20, r25	; 0x14
    54a6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54a8:	8b 89       	ldd	r24, Y+19	; 0x13
    54aa:	9c 89       	ldd	r25, Y+20	; 0x14
    54ac:	00 97       	sbiw	r24, 0x00	; 0
    54ae:	69 f7       	brne	.-38     	; 0x548a <LCD_Command_4bit+0x2f2>
    54b0:	14 c0       	rjmp	.+40     	; 0x54da <LCD_Command_4bit+0x342>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54b2:	6d 89       	ldd	r22, Y+21	; 0x15
    54b4:	7e 89       	ldd	r23, Y+22	; 0x16
    54b6:	8f 89       	ldd	r24, Y+23	; 0x17
    54b8:	98 8d       	ldd	r25, Y+24	; 0x18
    54ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54be:	dc 01       	movw	r26, r24
    54c0:	cb 01       	movw	r24, r22
    54c2:	9c 8b       	std	Y+20, r25	; 0x14
    54c4:	8b 8b       	std	Y+19, r24	; 0x13
    54c6:	8b 89       	ldd	r24, Y+19	; 0x13
    54c8:	9c 89       	ldd	r25, Y+20	; 0x14
    54ca:	98 8b       	std	Y+16, r25	; 0x10
    54cc:	8f 87       	std	Y+15, r24	; 0x0f
    54ce:	8f 85       	ldd	r24, Y+15	; 0x0f
    54d0:	98 89       	ldd	r25, Y+16	; 0x10
    54d2:	01 97       	sbiw	r24, 0x01	; 1
    54d4:	f1 f7       	brne	.-4      	; 0x54d2 <LCD_Command_4bit+0x33a>
    54d6:	98 8b       	std	Y+16, r25	; 0x10
    54d8:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , LOW);
    54da:	81 e0       	ldi	r24, 0x01	; 1
    54dc:	63 e0       	ldi	r22, 0x03	; 3
    54de:	40 e0       	ldi	r20, 0x00	; 0
    54e0:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    54e4:	80 e0       	ldi	r24, 0x00	; 0
    54e6:	90 e0       	ldi	r25, 0x00	; 0
    54e8:	a0 ea       	ldi	r26, 0xA0	; 160
    54ea:	b0 e4       	ldi	r27, 0x40	; 64
    54ec:	8b 87       	std	Y+11, r24	; 0x0b
    54ee:	9c 87       	std	Y+12, r25	; 0x0c
    54f0:	ad 87       	std	Y+13, r26	; 0x0d
    54f2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    54f4:	6b 85       	ldd	r22, Y+11	; 0x0b
    54f6:	7c 85       	ldd	r23, Y+12	; 0x0c
    54f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    54fa:	9e 85       	ldd	r25, Y+14	; 0x0e
    54fc:	20 e0       	ldi	r18, 0x00	; 0
    54fe:	30 e0       	ldi	r19, 0x00	; 0
    5500:	4a e7       	ldi	r20, 0x7A	; 122
    5502:	55 e4       	ldi	r21, 0x45	; 69
    5504:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5508:	dc 01       	movw	r26, r24
    550a:	cb 01       	movw	r24, r22
    550c:	8f 83       	std	Y+7, r24	; 0x07
    550e:	98 87       	std	Y+8, r25	; 0x08
    5510:	a9 87       	std	Y+9, r26	; 0x09
    5512:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5514:	6f 81       	ldd	r22, Y+7	; 0x07
    5516:	78 85       	ldd	r23, Y+8	; 0x08
    5518:	89 85       	ldd	r24, Y+9	; 0x09
    551a:	9a 85       	ldd	r25, Y+10	; 0x0a
    551c:	20 e0       	ldi	r18, 0x00	; 0
    551e:	30 e0       	ldi	r19, 0x00	; 0
    5520:	40 e8       	ldi	r20, 0x80	; 128
    5522:	5f e3       	ldi	r21, 0x3F	; 63
    5524:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5528:	88 23       	and	r24, r24
    552a:	2c f4       	brge	.+10     	; 0x5536 <LCD_Command_4bit+0x39e>
		__ticks = 1;
    552c:	81 e0       	ldi	r24, 0x01	; 1
    552e:	90 e0       	ldi	r25, 0x00	; 0
    5530:	9e 83       	std	Y+6, r25	; 0x06
    5532:	8d 83       	std	Y+5, r24	; 0x05
    5534:	3f c0       	rjmp	.+126    	; 0x55b4 <LCD_Command_4bit+0x41c>
	else if (__tmp > 65535)
    5536:	6f 81       	ldd	r22, Y+7	; 0x07
    5538:	78 85       	ldd	r23, Y+8	; 0x08
    553a:	89 85       	ldd	r24, Y+9	; 0x09
    553c:	9a 85       	ldd	r25, Y+10	; 0x0a
    553e:	20 e0       	ldi	r18, 0x00	; 0
    5540:	3f ef       	ldi	r19, 0xFF	; 255
    5542:	4f e7       	ldi	r20, 0x7F	; 127
    5544:	57 e4       	ldi	r21, 0x47	; 71
    5546:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    554a:	18 16       	cp	r1, r24
    554c:	4c f5       	brge	.+82     	; 0x55a0 <LCD_Command_4bit+0x408>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    554e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5550:	7c 85       	ldd	r23, Y+12	; 0x0c
    5552:	8d 85       	ldd	r24, Y+13	; 0x0d
    5554:	9e 85       	ldd	r25, Y+14	; 0x0e
    5556:	20 e0       	ldi	r18, 0x00	; 0
    5558:	30 e0       	ldi	r19, 0x00	; 0
    555a:	40 e2       	ldi	r20, 0x20	; 32
    555c:	51 e4       	ldi	r21, 0x41	; 65
    555e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5562:	dc 01       	movw	r26, r24
    5564:	cb 01       	movw	r24, r22
    5566:	bc 01       	movw	r22, r24
    5568:	cd 01       	movw	r24, r26
    556a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    556e:	dc 01       	movw	r26, r24
    5570:	cb 01       	movw	r24, r22
    5572:	9e 83       	std	Y+6, r25	; 0x06
    5574:	8d 83       	std	Y+5, r24	; 0x05
    5576:	0f c0       	rjmp	.+30     	; 0x5596 <LCD_Command_4bit+0x3fe>
    5578:	80 e9       	ldi	r24, 0x90	; 144
    557a:	91 e0       	ldi	r25, 0x01	; 1
    557c:	9c 83       	std	Y+4, r25	; 0x04
    557e:	8b 83       	std	Y+3, r24	; 0x03
    5580:	8b 81       	ldd	r24, Y+3	; 0x03
    5582:	9c 81       	ldd	r25, Y+4	; 0x04
    5584:	01 97       	sbiw	r24, 0x01	; 1
    5586:	f1 f7       	brne	.-4      	; 0x5584 <LCD_Command_4bit+0x3ec>
    5588:	9c 83       	std	Y+4, r25	; 0x04
    558a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    558c:	8d 81       	ldd	r24, Y+5	; 0x05
    558e:	9e 81       	ldd	r25, Y+6	; 0x06
    5590:	01 97       	sbiw	r24, 0x01	; 1
    5592:	9e 83       	std	Y+6, r25	; 0x06
    5594:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5596:	8d 81       	ldd	r24, Y+5	; 0x05
    5598:	9e 81       	ldd	r25, Y+6	; 0x06
    559a:	00 97       	sbiw	r24, 0x00	; 0
    559c:	69 f7       	brne	.-38     	; 0x5578 <LCD_Command_4bit+0x3e0>
    559e:	14 c0       	rjmp	.+40     	; 0x55c8 <LCD_Command_4bit+0x430>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    55a0:	6f 81       	ldd	r22, Y+7	; 0x07
    55a2:	78 85       	ldd	r23, Y+8	; 0x08
    55a4:	89 85       	ldd	r24, Y+9	; 0x09
    55a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    55a8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55ac:	dc 01       	movw	r26, r24
    55ae:	cb 01       	movw	r24, r22
    55b0:	9e 83       	std	Y+6, r25	; 0x06
    55b2:	8d 83       	std	Y+5, r24	; 0x05
    55b4:	8d 81       	ldd	r24, Y+5	; 0x05
    55b6:	9e 81       	ldd	r25, Y+6	; 0x06
    55b8:	9a 83       	std	Y+2, r25	; 0x02
    55ba:	89 83       	std	Y+1, r24	; 0x01
    55bc:	89 81       	ldd	r24, Y+1	; 0x01
    55be:	9a 81       	ldd	r25, Y+2	; 0x02
    55c0:	01 97       	sbiw	r24, 0x01	; 1
    55c2:	f1 f7       	brne	.-4      	; 0x55c0 <LCD_Command_4bit+0x428>
    55c4:	9a 83       	std	Y+2, r25	; 0x02
    55c6:	89 83       	std	Y+1, r24	; 0x01
     _delay_ms(5);
	 }
    55c8:	e9 96       	adiw	r28, 0x39	; 57
    55ca:	0f b6       	in	r0, 0x3f	; 63
    55cc:	f8 94       	cli
    55ce:	de bf       	out	0x3e, r29	; 62
    55d0:	0f be       	out	0x3f, r0	; 63
    55d2:	cd bf       	out	0x3d, r28	; 61
    55d4:	cf 91       	pop	r28
    55d6:	df 91       	pop	r29
    55d8:	08 95       	ret

000055da <LCD_WriteChar_4bit>:

void LCD_WriteChar_4bit( uint_8 DATA )
{
    55da:	df 93       	push	r29
    55dc:	cf 93       	push	r28
    55de:	cd b7       	in	r28, 0x3d	; 61
    55e0:	de b7       	in	r29, 0x3e	; 62
    55e2:	e9 97       	sbiw	r28, 0x39	; 57
    55e4:	0f b6       	in	r0, 0x3f	; 63
    55e6:	f8 94       	cli
    55e8:	de bf       	out	0x3e, r29	; 62
    55ea:	0f be       	out	0x3f, r0	; 63
    55ec:	cd bf       	out	0x3d, r28	; 61
    55ee:	89 af       	std	Y+57, r24	; 0x39
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (DATA & 0xF0);   /* Sending upper nibble */
    55f0:	ab e3       	ldi	r26, 0x3B	; 59
    55f2:	b0 e0       	ldi	r27, 0x00	; 0
    55f4:	eb e3       	ldi	r30, 0x3B	; 59
    55f6:	f0 e0       	ldi	r31, 0x00	; 0
    55f8:	80 81       	ld	r24, Z
    55fa:	98 2f       	mov	r25, r24
    55fc:	9f 70       	andi	r25, 0x0F	; 15
    55fe:	89 ad       	ldd	r24, Y+57	; 0x39
    5600:	80 7f       	andi	r24, 0xF0	; 240
    5602:	89 2b       	or	r24, r25
    5604:	8c 93       	st	X, r24
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RS , HIGH);
    5606:	81 e0       	ldi	r24, 0x01	; 1
    5608:	61 e0       	ldi	r22, 0x01	; 1
    560a:	41 e0       	ldi	r20, 0x01	; 1
    560c:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RW , LOW);
    5610:	81 e0       	ldi	r24, 0x01	; 1
    5612:	62 e0       	ldi	r22, 0x02	; 2
    5614:	40 e0       	ldi	r20, 0x00	; 0
    5616:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , HIGH);
    561a:	81 e0       	ldi	r24, 0x01	; 1
    561c:	63 e0       	ldi	r22, 0x03	; 3
    561e:	41 e0       	ldi	r20, 0x01	; 1
    5620:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    5624:	80 e0       	ldi	r24, 0x00	; 0
    5626:	90 e0       	ldi	r25, 0x00	; 0
    5628:	a0 ea       	ldi	r26, 0xA0	; 160
    562a:	b0 e4       	ldi	r27, 0x40	; 64
    562c:	8d ab       	std	Y+53, r24	; 0x35
    562e:	9e ab       	std	Y+54, r25	; 0x36
    5630:	af ab       	std	Y+55, r26	; 0x37
    5632:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5634:	6d a9       	ldd	r22, Y+53	; 0x35
    5636:	7e a9       	ldd	r23, Y+54	; 0x36
    5638:	8f a9       	ldd	r24, Y+55	; 0x37
    563a:	98 ad       	ldd	r25, Y+56	; 0x38
    563c:	20 e0       	ldi	r18, 0x00	; 0
    563e:	30 e0       	ldi	r19, 0x00	; 0
    5640:	4a e7       	ldi	r20, 0x7A	; 122
    5642:	55 e4       	ldi	r21, 0x45	; 69
    5644:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5648:	dc 01       	movw	r26, r24
    564a:	cb 01       	movw	r24, r22
    564c:	89 ab       	std	Y+49, r24	; 0x31
    564e:	9a ab       	std	Y+50, r25	; 0x32
    5650:	ab ab       	std	Y+51, r26	; 0x33
    5652:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    5654:	69 a9       	ldd	r22, Y+49	; 0x31
    5656:	7a a9       	ldd	r23, Y+50	; 0x32
    5658:	8b a9       	ldd	r24, Y+51	; 0x33
    565a:	9c a9       	ldd	r25, Y+52	; 0x34
    565c:	20 e0       	ldi	r18, 0x00	; 0
    565e:	30 e0       	ldi	r19, 0x00	; 0
    5660:	40 e8       	ldi	r20, 0x80	; 128
    5662:	5f e3       	ldi	r21, 0x3F	; 63
    5664:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5668:	88 23       	and	r24, r24
    566a:	2c f4       	brge	.+10     	; 0x5676 <LCD_WriteChar_4bit+0x9c>
		__ticks = 1;
    566c:	81 e0       	ldi	r24, 0x01	; 1
    566e:	90 e0       	ldi	r25, 0x00	; 0
    5670:	98 ab       	std	Y+48, r25	; 0x30
    5672:	8f a7       	std	Y+47, r24	; 0x2f
    5674:	3f c0       	rjmp	.+126    	; 0x56f4 <LCD_WriteChar_4bit+0x11a>
	else if (__tmp > 65535)
    5676:	69 a9       	ldd	r22, Y+49	; 0x31
    5678:	7a a9       	ldd	r23, Y+50	; 0x32
    567a:	8b a9       	ldd	r24, Y+51	; 0x33
    567c:	9c a9       	ldd	r25, Y+52	; 0x34
    567e:	20 e0       	ldi	r18, 0x00	; 0
    5680:	3f ef       	ldi	r19, 0xFF	; 255
    5682:	4f e7       	ldi	r20, 0x7F	; 127
    5684:	57 e4       	ldi	r21, 0x47	; 71
    5686:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    568a:	18 16       	cp	r1, r24
    568c:	4c f5       	brge	.+82     	; 0x56e0 <LCD_WriteChar_4bit+0x106>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    568e:	6d a9       	ldd	r22, Y+53	; 0x35
    5690:	7e a9       	ldd	r23, Y+54	; 0x36
    5692:	8f a9       	ldd	r24, Y+55	; 0x37
    5694:	98 ad       	ldd	r25, Y+56	; 0x38
    5696:	20 e0       	ldi	r18, 0x00	; 0
    5698:	30 e0       	ldi	r19, 0x00	; 0
    569a:	40 e2       	ldi	r20, 0x20	; 32
    569c:	51 e4       	ldi	r21, 0x41	; 65
    569e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    56a2:	dc 01       	movw	r26, r24
    56a4:	cb 01       	movw	r24, r22
    56a6:	bc 01       	movw	r22, r24
    56a8:	cd 01       	movw	r24, r26
    56aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    56ae:	dc 01       	movw	r26, r24
    56b0:	cb 01       	movw	r24, r22
    56b2:	98 ab       	std	Y+48, r25	; 0x30
    56b4:	8f a7       	std	Y+47, r24	; 0x2f
    56b6:	0f c0       	rjmp	.+30     	; 0x56d6 <LCD_WriteChar_4bit+0xfc>
    56b8:	80 e9       	ldi	r24, 0x90	; 144
    56ba:	91 e0       	ldi	r25, 0x01	; 1
    56bc:	9e a7       	std	Y+46, r25	; 0x2e
    56be:	8d a7       	std	Y+45, r24	; 0x2d
    56c0:	8d a5       	ldd	r24, Y+45	; 0x2d
    56c2:	9e a5       	ldd	r25, Y+46	; 0x2e
    56c4:	01 97       	sbiw	r24, 0x01	; 1
    56c6:	f1 f7       	brne	.-4      	; 0x56c4 <LCD_WriteChar_4bit+0xea>
    56c8:	9e a7       	std	Y+46, r25	; 0x2e
    56ca:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    56cc:	8f a5       	ldd	r24, Y+47	; 0x2f
    56ce:	98 a9       	ldd	r25, Y+48	; 0x30
    56d0:	01 97       	sbiw	r24, 0x01	; 1
    56d2:	98 ab       	std	Y+48, r25	; 0x30
    56d4:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    56d6:	8f a5       	ldd	r24, Y+47	; 0x2f
    56d8:	98 a9       	ldd	r25, Y+48	; 0x30
    56da:	00 97       	sbiw	r24, 0x00	; 0
    56dc:	69 f7       	brne	.-38     	; 0x56b8 <LCD_WriteChar_4bit+0xde>
    56de:	14 c0       	rjmp	.+40     	; 0x5708 <LCD_WriteChar_4bit+0x12e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    56e0:	69 a9       	ldd	r22, Y+49	; 0x31
    56e2:	7a a9       	ldd	r23, Y+50	; 0x32
    56e4:	8b a9       	ldd	r24, Y+51	; 0x33
    56e6:	9c a9       	ldd	r25, Y+52	; 0x34
    56e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    56ec:	dc 01       	movw	r26, r24
    56ee:	cb 01       	movw	r24, r22
    56f0:	98 ab       	std	Y+48, r25	; 0x30
    56f2:	8f a7       	std	Y+47, r24	; 0x2f
    56f4:	8f a5       	ldd	r24, Y+47	; 0x2f
    56f6:	98 a9       	ldd	r25, Y+48	; 0x30
    56f8:	9c a7       	std	Y+44, r25	; 0x2c
    56fa:	8b a7       	std	Y+43, r24	; 0x2b
    56fc:	8b a5       	ldd	r24, Y+43	; 0x2b
    56fe:	9c a5       	ldd	r25, Y+44	; 0x2c
    5700:	01 97       	sbiw	r24, 0x01	; 1
    5702:	f1 f7       	brne	.-4      	; 0x5700 <LCD_WriteChar_4bit+0x126>
    5704:	9c a7       	std	Y+44, r25	; 0x2c
    5706:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(5);
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , LOW);
    5708:	81 e0       	ldi	r24, 0x01	; 1
    570a:	63 e0       	ldi	r22, 0x03	; 3
    570c:	40 e0       	ldi	r20, 0x00	; 0
    570e:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    5712:	80 e0       	ldi	r24, 0x00	; 0
    5714:	90 e0       	ldi	r25, 0x00	; 0
    5716:	a0 ea       	ldi	r26, 0xA0	; 160
    5718:	b0 e4       	ldi	r27, 0x40	; 64
    571a:	8f a3       	std	Y+39, r24	; 0x27
    571c:	98 a7       	std	Y+40, r25	; 0x28
    571e:	a9 a7       	std	Y+41, r26	; 0x29
    5720:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5722:	6f a1       	ldd	r22, Y+39	; 0x27
    5724:	78 a5       	ldd	r23, Y+40	; 0x28
    5726:	89 a5       	ldd	r24, Y+41	; 0x29
    5728:	9a a5       	ldd	r25, Y+42	; 0x2a
    572a:	20 e0       	ldi	r18, 0x00	; 0
    572c:	30 e0       	ldi	r19, 0x00	; 0
    572e:	4a e7       	ldi	r20, 0x7A	; 122
    5730:	55 e4       	ldi	r21, 0x45	; 69
    5732:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5736:	dc 01       	movw	r26, r24
    5738:	cb 01       	movw	r24, r22
    573a:	8b a3       	std	Y+35, r24	; 0x23
    573c:	9c a3       	std	Y+36, r25	; 0x24
    573e:	ad a3       	std	Y+37, r26	; 0x25
    5740:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    5742:	6b a1       	ldd	r22, Y+35	; 0x23
    5744:	7c a1       	ldd	r23, Y+36	; 0x24
    5746:	8d a1       	ldd	r24, Y+37	; 0x25
    5748:	9e a1       	ldd	r25, Y+38	; 0x26
    574a:	20 e0       	ldi	r18, 0x00	; 0
    574c:	30 e0       	ldi	r19, 0x00	; 0
    574e:	40 e8       	ldi	r20, 0x80	; 128
    5750:	5f e3       	ldi	r21, 0x3F	; 63
    5752:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5756:	88 23       	and	r24, r24
    5758:	2c f4       	brge	.+10     	; 0x5764 <LCD_WriteChar_4bit+0x18a>
		__ticks = 1;
    575a:	81 e0       	ldi	r24, 0x01	; 1
    575c:	90 e0       	ldi	r25, 0x00	; 0
    575e:	9a a3       	std	Y+34, r25	; 0x22
    5760:	89 a3       	std	Y+33, r24	; 0x21
    5762:	3f c0       	rjmp	.+126    	; 0x57e2 <LCD_WriteChar_4bit+0x208>
	else if (__tmp > 65535)
    5764:	6b a1       	ldd	r22, Y+35	; 0x23
    5766:	7c a1       	ldd	r23, Y+36	; 0x24
    5768:	8d a1       	ldd	r24, Y+37	; 0x25
    576a:	9e a1       	ldd	r25, Y+38	; 0x26
    576c:	20 e0       	ldi	r18, 0x00	; 0
    576e:	3f ef       	ldi	r19, 0xFF	; 255
    5770:	4f e7       	ldi	r20, 0x7F	; 127
    5772:	57 e4       	ldi	r21, 0x47	; 71
    5774:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5778:	18 16       	cp	r1, r24
    577a:	4c f5       	brge	.+82     	; 0x57ce <LCD_WriteChar_4bit+0x1f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    577c:	6f a1       	ldd	r22, Y+39	; 0x27
    577e:	78 a5       	ldd	r23, Y+40	; 0x28
    5780:	89 a5       	ldd	r24, Y+41	; 0x29
    5782:	9a a5       	ldd	r25, Y+42	; 0x2a
    5784:	20 e0       	ldi	r18, 0x00	; 0
    5786:	30 e0       	ldi	r19, 0x00	; 0
    5788:	40 e2       	ldi	r20, 0x20	; 32
    578a:	51 e4       	ldi	r21, 0x41	; 65
    578c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5790:	dc 01       	movw	r26, r24
    5792:	cb 01       	movw	r24, r22
    5794:	bc 01       	movw	r22, r24
    5796:	cd 01       	movw	r24, r26
    5798:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    579c:	dc 01       	movw	r26, r24
    579e:	cb 01       	movw	r24, r22
    57a0:	9a a3       	std	Y+34, r25	; 0x22
    57a2:	89 a3       	std	Y+33, r24	; 0x21
    57a4:	0f c0       	rjmp	.+30     	; 0x57c4 <LCD_WriteChar_4bit+0x1ea>
    57a6:	80 e9       	ldi	r24, 0x90	; 144
    57a8:	91 e0       	ldi	r25, 0x01	; 1
    57aa:	98 a3       	std	Y+32, r25	; 0x20
    57ac:	8f 8f       	std	Y+31, r24	; 0x1f
    57ae:	8f 8d       	ldd	r24, Y+31	; 0x1f
    57b0:	98 a1       	ldd	r25, Y+32	; 0x20
    57b2:	01 97       	sbiw	r24, 0x01	; 1
    57b4:	f1 f7       	brne	.-4      	; 0x57b2 <LCD_WriteChar_4bit+0x1d8>
    57b6:	98 a3       	std	Y+32, r25	; 0x20
    57b8:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57ba:	89 a1       	ldd	r24, Y+33	; 0x21
    57bc:	9a a1       	ldd	r25, Y+34	; 0x22
    57be:	01 97       	sbiw	r24, 0x01	; 1
    57c0:	9a a3       	std	Y+34, r25	; 0x22
    57c2:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57c4:	89 a1       	ldd	r24, Y+33	; 0x21
    57c6:	9a a1       	ldd	r25, Y+34	; 0x22
    57c8:	00 97       	sbiw	r24, 0x00	; 0
    57ca:	69 f7       	brne	.-38     	; 0x57a6 <LCD_WriteChar_4bit+0x1cc>
    57cc:	14 c0       	rjmp	.+40     	; 0x57f6 <LCD_WriteChar_4bit+0x21c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57ce:	6b a1       	ldd	r22, Y+35	; 0x23
    57d0:	7c a1       	ldd	r23, Y+36	; 0x24
    57d2:	8d a1       	ldd	r24, Y+37	; 0x25
    57d4:	9e a1       	ldd	r25, Y+38	; 0x26
    57d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    57da:	dc 01       	movw	r26, r24
    57dc:	cb 01       	movw	r24, r22
    57de:	9a a3       	std	Y+34, r25	; 0x22
    57e0:	89 a3       	std	Y+33, r24	; 0x21
    57e2:	89 a1       	ldd	r24, Y+33	; 0x21
    57e4:	9a a1       	ldd	r25, Y+34	; 0x22
    57e6:	9e 8f       	std	Y+30, r25	; 0x1e
    57e8:	8d 8f       	std	Y+29, r24	; 0x1d
    57ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    57ec:	9e 8d       	ldd	r25, Y+30	; 0x1e
    57ee:	01 97       	sbiw	r24, 0x01	; 1
    57f0:	f1 f7       	brne	.-4      	; 0x57ee <LCD_WriteChar_4bit+0x214>
    57f2:	9e 8f       	std	Y+30, r25	; 0x1e
    57f4:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(5);
	
	LCD_DATA_PORT = (LCD_DATA_PORT & 0x0F) | (DATA << 4);            /* Sending lower nibble */
    57f6:	ab e3       	ldi	r26, 0x3B	; 59
    57f8:	b0 e0       	ldi	r27, 0x00	; 0
    57fa:	eb e3       	ldi	r30, 0x3B	; 59
    57fc:	f0 e0       	ldi	r31, 0x00	; 0
    57fe:	80 81       	ld	r24, Z
    5800:	28 2f       	mov	r18, r24
    5802:	2f 70       	andi	r18, 0x0F	; 15
    5804:	89 ad       	ldd	r24, Y+57	; 0x39
    5806:	88 2f       	mov	r24, r24
    5808:	90 e0       	ldi	r25, 0x00	; 0
    580a:	82 95       	swap	r24
    580c:	92 95       	swap	r25
    580e:	90 7f       	andi	r25, 0xF0	; 240
    5810:	98 27       	eor	r25, r24
    5812:	80 7f       	andi	r24, 0xF0	; 240
    5814:	98 27       	eor	r25, r24
    5816:	82 2b       	or	r24, r18
    5818:	8c 93       	st	X, r24
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RS , HIGH);
    581a:	81 e0       	ldi	r24, 0x01	; 1
    581c:	61 e0       	ldi	r22, 0x01	; 1
    581e:	41 e0       	ldi	r20, 0x01	; 1
    5820:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_RW , LOW);
    5824:	81 e0       	ldi	r24, 0x01	; 1
    5826:	62 e0       	ldi	r22, 0x02	; 2
    5828:	40 e0       	ldi	r20, 0x00	; 0
    582a:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , HIGH);
    582e:	81 e0       	ldi	r24, 0x01	; 1
    5830:	63 e0       	ldi	r22, 0x03	; 3
    5832:	41 e0       	ldi	r20, 0x01	; 1
    5834:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    5838:	80 e0       	ldi	r24, 0x00	; 0
    583a:	90 e0       	ldi	r25, 0x00	; 0
    583c:	a0 ea       	ldi	r26, 0xA0	; 160
    583e:	b0 e4       	ldi	r27, 0x40	; 64
    5840:	89 8f       	std	Y+25, r24	; 0x19
    5842:	9a 8f       	std	Y+26, r25	; 0x1a
    5844:	ab 8f       	std	Y+27, r26	; 0x1b
    5846:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5848:	69 8d       	ldd	r22, Y+25	; 0x19
    584a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    584c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    584e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5850:	20 e0       	ldi	r18, 0x00	; 0
    5852:	30 e0       	ldi	r19, 0x00	; 0
    5854:	4a e7       	ldi	r20, 0x7A	; 122
    5856:	55 e4       	ldi	r21, 0x45	; 69
    5858:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    585c:	dc 01       	movw	r26, r24
    585e:	cb 01       	movw	r24, r22
    5860:	8d 8b       	std	Y+21, r24	; 0x15
    5862:	9e 8b       	std	Y+22, r25	; 0x16
    5864:	af 8b       	std	Y+23, r26	; 0x17
    5866:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5868:	6d 89       	ldd	r22, Y+21	; 0x15
    586a:	7e 89       	ldd	r23, Y+22	; 0x16
    586c:	8f 89       	ldd	r24, Y+23	; 0x17
    586e:	98 8d       	ldd	r25, Y+24	; 0x18
    5870:	20 e0       	ldi	r18, 0x00	; 0
    5872:	30 e0       	ldi	r19, 0x00	; 0
    5874:	40 e8       	ldi	r20, 0x80	; 128
    5876:	5f e3       	ldi	r21, 0x3F	; 63
    5878:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    587c:	88 23       	and	r24, r24
    587e:	2c f4       	brge	.+10     	; 0x588a <LCD_WriteChar_4bit+0x2b0>
		__ticks = 1;
    5880:	81 e0       	ldi	r24, 0x01	; 1
    5882:	90 e0       	ldi	r25, 0x00	; 0
    5884:	9c 8b       	std	Y+20, r25	; 0x14
    5886:	8b 8b       	std	Y+19, r24	; 0x13
    5888:	3f c0       	rjmp	.+126    	; 0x5908 <LCD_WriteChar_4bit+0x32e>
	else if (__tmp > 65535)
    588a:	6d 89       	ldd	r22, Y+21	; 0x15
    588c:	7e 89       	ldd	r23, Y+22	; 0x16
    588e:	8f 89       	ldd	r24, Y+23	; 0x17
    5890:	98 8d       	ldd	r25, Y+24	; 0x18
    5892:	20 e0       	ldi	r18, 0x00	; 0
    5894:	3f ef       	ldi	r19, 0xFF	; 255
    5896:	4f e7       	ldi	r20, 0x7F	; 127
    5898:	57 e4       	ldi	r21, 0x47	; 71
    589a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    589e:	18 16       	cp	r1, r24
    58a0:	4c f5       	brge	.+82     	; 0x58f4 <LCD_WriteChar_4bit+0x31a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    58a2:	69 8d       	ldd	r22, Y+25	; 0x19
    58a4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    58a6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    58a8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    58aa:	20 e0       	ldi	r18, 0x00	; 0
    58ac:	30 e0       	ldi	r19, 0x00	; 0
    58ae:	40 e2       	ldi	r20, 0x20	; 32
    58b0:	51 e4       	ldi	r21, 0x41	; 65
    58b2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    58b6:	dc 01       	movw	r26, r24
    58b8:	cb 01       	movw	r24, r22
    58ba:	bc 01       	movw	r22, r24
    58bc:	cd 01       	movw	r24, r26
    58be:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    58c2:	dc 01       	movw	r26, r24
    58c4:	cb 01       	movw	r24, r22
    58c6:	9c 8b       	std	Y+20, r25	; 0x14
    58c8:	8b 8b       	std	Y+19, r24	; 0x13
    58ca:	0f c0       	rjmp	.+30     	; 0x58ea <LCD_WriteChar_4bit+0x310>
    58cc:	80 e9       	ldi	r24, 0x90	; 144
    58ce:	91 e0       	ldi	r25, 0x01	; 1
    58d0:	9a 8b       	std	Y+18, r25	; 0x12
    58d2:	89 8b       	std	Y+17, r24	; 0x11
    58d4:	89 89       	ldd	r24, Y+17	; 0x11
    58d6:	9a 89       	ldd	r25, Y+18	; 0x12
    58d8:	01 97       	sbiw	r24, 0x01	; 1
    58da:	f1 f7       	brne	.-4      	; 0x58d8 <LCD_WriteChar_4bit+0x2fe>
    58dc:	9a 8b       	std	Y+18, r25	; 0x12
    58de:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    58e0:	8b 89       	ldd	r24, Y+19	; 0x13
    58e2:	9c 89       	ldd	r25, Y+20	; 0x14
    58e4:	01 97       	sbiw	r24, 0x01	; 1
    58e6:	9c 8b       	std	Y+20, r25	; 0x14
    58e8:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    58ea:	8b 89       	ldd	r24, Y+19	; 0x13
    58ec:	9c 89       	ldd	r25, Y+20	; 0x14
    58ee:	00 97       	sbiw	r24, 0x00	; 0
    58f0:	69 f7       	brne	.-38     	; 0x58cc <LCD_WriteChar_4bit+0x2f2>
    58f2:	14 c0       	rjmp	.+40     	; 0x591c <LCD_WriteChar_4bit+0x342>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    58f4:	6d 89       	ldd	r22, Y+21	; 0x15
    58f6:	7e 89       	ldd	r23, Y+22	; 0x16
    58f8:	8f 89       	ldd	r24, Y+23	; 0x17
    58fa:	98 8d       	ldd	r25, Y+24	; 0x18
    58fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5900:	dc 01       	movw	r26, r24
    5902:	cb 01       	movw	r24, r22
    5904:	9c 8b       	std	Y+20, r25	; 0x14
    5906:	8b 8b       	std	Y+19, r24	; 0x13
    5908:	8b 89       	ldd	r24, Y+19	; 0x13
    590a:	9c 89       	ldd	r25, Y+20	; 0x14
    590c:	98 8b       	std	Y+16, r25	; 0x10
    590e:	8f 87       	std	Y+15, r24	; 0x0f
    5910:	8f 85       	ldd	r24, Y+15	; 0x0f
    5912:	98 89       	ldd	r25, Y+16	; 0x10
    5914:	01 97       	sbiw	r24, 0x01	; 1
    5916:	f1 f7       	brne	.-4      	; 0x5914 <LCD_WriteChar_4bit+0x33a>
    5918:	98 8b       	std	Y+16, r25	; 0x10
    591a:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(5);
	DIO_SetPinValue(LCD_CONTROL_PORT , LCD_EN , LOW);
    591c:	81 e0       	ldi	r24, 0x01	; 1
    591e:	63 e0       	ldi	r22, 0x03	; 3
    5920:	40 e0       	ldi	r20, 0x00	; 0
    5922:	0e 94 6e 21 	call	0x42dc	; 0x42dc <DIO_SetPinValue>
    5926:	80 e0       	ldi	r24, 0x00	; 0
    5928:	90 e0       	ldi	r25, 0x00	; 0
    592a:	a0 ea       	ldi	r26, 0xA0	; 160
    592c:	b0 e4       	ldi	r27, 0x40	; 64
    592e:	8b 87       	std	Y+11, r24	; 0x0b
    5930:	9c 87       	std	Y+12, r25	; 0x0c
    5932:	ad 87       	std	Y+13, r26	; 0x0d
    5934:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5936:	6b 85       	ldd	r22, Y+11	; 0x0b
    5938:	7c 85       	ldd	r23, Y+12	; 0x0c
    593a:	8d 85       	ldd	r24, Y+13	; 0x0d
    593c:	9e 85       	ldd	r25, Y+14	; 0x0e
    593e:	20 e0       	ldi	r18, 0x00	; 0
    5940:	30 e0       	ldi	r19, 0x00	; 0
    5942:	4a e7       	ldi	r20, 0x7A	; 122
    5944:	55 e4       	ldi	r21, 0x45	; 69
    5946:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    594a:	dc 01       	movw	r26, r24
    594c:	cb 01       	movw	r24, r22
    594e:	8f 83       	std	Y+7, r24	; 0x07
    5950:	98 87       	std	Y+8, r25	; 0x08
    5952:	a9 87       	std	Y+9, r26	; 0x09
    5954:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5956:	6f 81       	ldd	r22, Y+7	; 0x07
    5958:	78 85       	ldd	r23, Y+8	; 0x08
    595a:	89 85       	ldd	r24, Y+9	; 0x09
    595c:	9a 85       	ldd	r25, Y+10	; 0x0a
    595e:	20 e0       	ldi	r18, 0x00	; 0
    5960:	30 e0       	ldi	r19, 0x00	; 0
    5962:	40 e8       	ldi	r20, 0x80	; 128
    5964:	5f e3       	ldi	r21, 0x3F	; 63
    5966:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    596a:	88 23       	and	r24, r24
    596c:	2c f4       	brge	.+10     	; 0x5978 <LCD_WriteChar_4bit+0x39e>
		__ticks = 1;
    596e:	81 e0       	ldi	r24, 0x01	; 1
    5970:	90 e0       	ldi	r25, 0x00	; 0
    5972:	9e 83       	std	Y+6, r25	; 0x06
    5974:	8d 83       	std	Y+5, r24	; 0x05
    5976:	3f c0       	rjmp	.+126    	; 0x59f6 <LCD_WriteChar_4bit+0x41c>
	else if (__tmp > 65535)
    5978:	6f 81       	ldd	r22, Y+7	; 0x07
    597a:	78 85       	ldd	r23, Y+8	; 0x08
    597c:	89 85       	ldd	r24, Y+9	; 0x09
    597e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5980:	20 e0       	ldi	r18, 0x00	; 0
    5982:	3f ef       	ldi	r19, 0xFF	; 255
    5984:	4f e7       	ldi	r20, 0x7F	; 127
    5986:	57 e4       	ldi	r21, 0x47	; 71
    5988:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    598c:	18 16       	cp	r1, r24
    598e:	4c f5       	brge	.+82     	; 0x59e2 <LCD_WriteChar_4bit+0x408>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5990:	6b 85       	ldd	r22, Y+11	; 0x0b
    5992:	7c 85       	ldd	r23, Y+12	; 0x0c
    5994:	8d 85       	ldd	r24, Y+13	; 0x0d
    5996:	9e 85       	ldd	r25, Y+14	; 0x0e
    5998:	20 e0       	ldi	r18, 0x00	; 0
    599a:	30 e0       	ldi	r19, 0x00	; 0
    599c:	40 e2       	ldi	r20, 0x20	; 32
    599e:	51 e4       	ldi	r21, 0x41	; 65
    59a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    59a4:	dc 01       	movw	r26, r24
    59a6:	cb 01       	movw	r24, r22
    59a8:	bc 01       	movw	r22, r24
    59aa:	cd 01       	movw	r24, r26
    59ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    59b0:	dc 01       	movw	r26, r24
    59b2:	cb 01       	movw	r24, r22
    59b4:	9e 83       	std	Y+6, r25	; 0x06
    59b6:	8d 83       	std	Y+5, r24	; 0x05
    59b8:	0f c0       	rjmp	.+30     	; 0x59d8 <LCD_WriteChar_4bit+0x3fe>
    59ba:	80 e9       	ldi	r24, 0x90	; 144
    59bc:	91 e0       	ldi	r25, 0x01	; 1
    59be:	9c 83       	std	Y+4, r25	; 0x04
    59c0:	8b 83       	std	Y+3, r24	; 0x03
    59c2:	8b 81       	ldd	r24, Y+3	; 0x03
    59c4:	9c 81       	ldd	r25, Y+4	; 0x04
    59c6:	01 97       	sbiw	r24, 0x01	; 1
    59c8:	f1 f7       	brne	.-4      	; 0x59c6 <LCD_WriteChar_4bit+0x3ec>
    59ca:	9c 83       	std	Y+4, r25	; 0x04
    59cc:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    59ce:	8d 81       	ldd	r24, Y+5	; 0x05
    59d0:	9e 81       	ldd	r25, Y+6	; 0x06
    59d2:	01 97       	sbiw	r24, 0x01	; 1
    59d4:	9e 83       	std	Y+6, r25	; 0x06
    59d6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    59d8:	8d 81       	ldd	r24, Y+5	; 0x05
    59da:	9e 81       	ldd	r25, Y+6	; 0x06
    59dc:	00 97       	sbiw	r24, 0x00	; 0
    59de:	69 f7       	brne	.-38     	; 0x59ba <LCD_WriteChar_4bit+0x3e0>
    59e0:	14 c0       	rjmp	.+40     	; 0x5a0a <LCD_WriteChar_4bit+0x430>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    59e2:	6f 81       	ldd	r22, Y+7	; 0x07
    59e4:	78 85       	ldd	r23, Y+8	; 0x08
    59e6:	89 85       	ldd	r24, Y+9	; 0x09
    59e8:	9a 85       	ldd	r25, Y+10	; 0x0a
    59ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    59ee:	dc 01       	movw	r26, r24
    59f0:	cb 01       	movw	r24, r22
    59f2:	9e 83       	std	Y+6, r25	; 0x06
    59f4:	8d 83       	std	Y+5, r24	; 0x05
    59f6:	8d 81       	ldd	r24, Y+5	; 0x05
    59f8:	9e 81       	ldd	r25, Y+6	; 0x06
    59fa:	9a 83       	std	Y+2, r25	; 0x02
    59fc:	89 83       	std	Y+1, r24	; 0x01
    59fe:	89 81       	ldd	r24, Y+1	; 0x01
    5a00:	9a 81       	ldd	r25, Y+2	; 0x02
    5a02:	01 97       	sbiw	r24, 0x01	; 1
    5a04:	f1 f7       	brne	.-4      	; 0x5a02 <LCD_WriteChar_4bit+0x428>
    5a06:	9a 83       	std	Y+2, r25	; 0x02
    5a08:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(5);
}
    5a0a:	e9 96       	adiw	r28, 0x39	; 57
    5a0c:	0f b6       	in	r0, 0x3f	; 63
    5a0e:	f8 94       	cli
    5a10:	de bf       	out	0x3e, r29	; 62
    5a12:	0f be       	out	0x3f, r0	; 63
    5a14:	cd bf       	out	0x3d, r28	; 61
    5a16:	cf 91       	pop	r28
    5a18:	df 91       	pop	r29
    5a1a:	08 95       	ret

00005a1c <LCD_WRITE_STRING_4bit>:

void LCD_WRITE_STRING_4bit(char  STRING[] )
{
    5a1c:	df 93       	push	r29
    5a1e:	cf 93       	push	r28
    5a20:	00 d0       	rcall	.+0      	; 0x5a22 <LCD_WRITE_STRING_4bit+0x6>
    5a22:	0f 92       	push	r0
    5a24:	cd b7       	in	r28, 0x3d	; 61
    5a26:	de b7       	in	r29, 0x3e	; 62
    5a28:	9b 83       	std	Y+3, r25	; 0x03
    5a2a:	8a 83       	std	Y+2, r24	; 0x02
	uint_8 i = 0;
    5a2c:	19 82       	std	Y+1, r1	; 0x01
    5a2e:	0e c0       	rjmp	.+28     	; 0x5a4c <LCD_WRITE_STRING_4bit+0x30>
	while( STRING[i] != '\0' )
	{
		LCD_WriteChar_4bit( STRING[i]);
    5a30:	89 81       	ldd	r24, Y+1	; 0x01
    5a32:	28 2f       	mov	r18, r24
    5a34:	30 e0       	ldi	r19, 0x00	; 0
    5a36:	8a 81       	ldd	r24, Y+2	; 0x02
    5a38:	9b 81       	ldd	r25, Y+3	; 0x03
    5a3a:	fc 01       	movw	r30, r24
    5a3c:	e2 0f       	add	r30, r18
    5a3e:	f3 1f       	adc	r31, r19
    5a40:	80 81       	ld	r24, Z
    5a42:	0e 94 ed 2a 	call	0x55da	; 0x55da <LCD_WriteChar_4bit>
		i++;
    5a46:	89 81       	ldd	r24, Y+1	; 0x01
    5a48:	8f 5f       	subi	r24, 0xFF	; 255
    5a4a:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_WRITE_STRING_4bit(char  STRING[] )
{
	uint_8 i = 0;
	while( STRING[i] != '\0' )
    5a4c:	89 81       	ldd	r24, Y+1	; 0x01
    5a4e:	28 2f       	mov	r18, r24
    5a50:	30 e0       	ldi	r19, 0x00	; 0
    5a52:	8a 81       	ldd	r24, Y+2	; 0x02
    5a54:	9b 81       	ldd	r25, Y+3	; 0x03
    5a56:	fc 01       	movw	r30, r24
    5a58:	e2 0f       	add	r30, r18
    5a5a:	f3 1f       	adc	r31, r19
    5a5c:	80 81       	ld	r24, Z
    5a5e:	88 23       	and	r24, r24
    5a60:	39 f7       	brne	.-50     	; 0x5a30 <LCD_WRITE_STRING_4bit+0x14>
		LCD_WriteChar_4bit( STRING[i]);
		i++;
		
	}
	
}
    5a62:	0f 90       	pop	r0
    5a64:	0f 90       	pop	r0
    5a66:	0f 90       	pop	r0
    5a68:	cf 91       	pop	r28
    5a6a:	df 91       	pop	r29
    5a6c:	08 95       	ret

00005a6e <LCD_GoToRowCol>:

void LCD_GoToRowCol(uint_8 row, uint_8 col)
{
    5a6e:	df 93       	push	r29
    5a70:	cf 93       	push	r28
    5a72:	00 d0       	rcall	.+0      	; 0x5a74 <LCD_GoToRowCol+0x6>
    5a74:	00 d0       	rcall	.+0      	; 0x5a76 <LCD_GoToRowCol+0x8>
    5a76:	0f 92       	push	r0
    5a78:	cd b7       	in	r28, 0x3d	; 61
    5a7a:	de b7       	in	r29, 0x3e	; 62
    5a7c:	8a 83       	std	Y+2, r24	; 0x02
    5a7e:	6b 83       	std	Y+3, r22	; 0x03
	uint_8 address;
	switch (row)
    5a80:	8a 81       	ldd	r24, Y+2	; 0x02
    5a82:	28 2f       	mov	r18, r24
    5a84:	30 e0       	ldi	r19, 0x00	; 0
    5a86:	3d 83       	std	Y+5, r19	; 0x05
    5a88:	2c 83       	std	Y+4, r18	; 0x04
    5a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    5a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    5a8e:	00 97       	sbiw	r24, 0x00	; 0
    5a90:	31 f0       	breq	.+12     	; 0x5a9e <LCD_GoToRowCol+0x30>
    5a92:	2c 81       	ldd	r18, Y+4	; 0x04
    5a94:	3d 81       	ldd	r19, Y+5	; 0x05
    5a96:	21 30       	cpi	r18, 0x01	; 1
    5a98:	31 05       	cpc	r19, r1
    5a9a:	21 f0       	breq	.+8      	; 0x5aa4 <LCD_GoToRowCol+0x36>
    5a9c:	06 c0       	rjmp	.+12     	; 0x5aaa <LCD_GoToRowCol+0x3c>
	{
		case 0:
		address = col;
    5a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    5aa0:	89 83       	std	Y+1, r24	; 0x01
    5aa2:	03 c0       	rjmp	.+6      	; 0x5aaa <LCD_GoToRowCol+0x3c>
		break;
		case 1:
		address = col + 0x40;
    5aa4:	8b 81       	ldd	r24, Y+3	; 0x03
    5aa6:	80 5c       	subi	r24, 0xC0	; 192
    5aa8:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	LCD_Command_4bit(address | SET_CURSOR_LOCATION);
    5aaa:	89 81       	ldd	r24, Y+1	; 0x01
    5aac:	80 68       	ori	r24, 0x80	; 128
    5aae:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
}
    5ab2:	0f 90       	pop	r0
    5ab4:	0f 90       	pop	r0
    5ab6:	0f 90       	pop	r0
    5ab8:	0f 90       	pop	r0
    5aba:	0f 90       	pop	r0
    5abc:	cf 91       	pop	r28
    5abe:	df 91       	pop	r29
    5ac0:	08 95       	ret

00005ac2 <LCD_SendStringRowCol>:

void LCD_SendStringRowCol(uint_8 row, uint_8 col, uint_8 *str)
{
    5ac2:	df 93       	push	r29
    5ac4:	cf 93       	push	r28
    5ac6:	00 d0       	rcall	.+0      	; 0x5ac8 <LCD_SendStringRowCol+0x6>
    5ac8:	00 d0       	rcall	.+0      	; 0x5aca <LCD_SendStringRowCol+0x8>
    5aca:	cd b7       	in	r28, 0x3d	; 61
    5acc:	de b7       	in	r29, 0x3e	; 62
    5ace:	89 83       	std	Y+1, r24	; 0x01
    5ad0:	6a 83       	std	Y+2, r22	; 0x02
    5ad2:	5c 83       	std	Y+4, r21	; 0x04
    5ad4:	4b 83       	std	Y+3, r20	; 0x03
	LCD_GoToRowCol(row,col);
    5ad6:	89 81       	ldd	r24, Y+1	; 0x01
    5ad8:	6a 81       	ldd	r22, Y+2	; 0x02
    5ada:	0e 94 37 2d 	call	0x5a6e	; 0x5a6e <LCD_GoToRowCol>
	LCD_WRITE_STRING_4bit(str);
    5ade:	8b 81       	ldd	r24, Y+3	; 0x03
    5ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    5ae2:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
}
    5ae6:	0f 90       	pop	r0
    5ae8:	0f 90       	pop	r0
    5aea:	0f 90       	pop	r0
    5aec:	0f 90       	pop	r0
    5aee:	cf 91       	pop	r28
    5af0:	df 91       	pop	r29
    5af2:	08 95       	ret

00005af4 <LCD_ClearScreen_4bit>:

void LCD_ClearScreen_4bit()
{
    5af4:	df 93       	push	r29
    5af6:	cf 93       	push	r28
    5af8:	cd b7       	in	r28, 0x3d	; 61
    5afa:	de b7       	in	r29, 0x3e	; 62
	LCD_Command_4bit(0x01);
    5afc:	81 e0       	ldi	r24, 0x01	; 1
    5afe:	0e 94 cc 28 	call	0x5198	; 0x5198 <LCD_Command_4bit>
}
    5b02:	cf 91       	pop	r28
    5b04:	df 91       	pop	r29
    5b06:	08 95       	ret

00005b08 <LCD_ClearScreen>:
void LCD_ClearScreen()
{
    5b08:	df 93       	push	r29
    5b0a:	cf 93       	push	r28
    5b0c:	cd b7       	in	r28, 0x3d	; 61
    5b0e:	de b7       	in	r29, 0x3e	; 62
	LCD_Command(0x01);
    5b10:	81 e0       	ldi	r24, 0x01	; 1
    5b12:	0e 94 f0 26 	call	0x4de0	; 0x4de0 <LCD_Command>
}
    5b16:	cf 91       	pop	r28
    5b18:	df 91       	pop	r29
    5b1a:	08 95       	ret

00005b1c <Task_1>:
static const uint_8 *pcTextForTask1 = "\x1B[32m Task 1 is running\r\n";
static const uint_8 *pcTextForTask2 = "\x1B[33m Task 2 is running\t\n";
uint_8 Command= 0;

void Task_1(void *pvParameters)
{
    5b1c:	df 93       	push	r29
    5b1e:	cf 93       	push	r28
    5b20:	00 d0       	rcall	.+0      	; 0x5b22 <Task_1+0x6>
    5b22:	00 d0       	rcall	.+0      	; 0x5b24 <Task_1+0x8>
    5b24:	cd b7       	in	r28, 0x3d	; 61
    5b26:	de b7       	in	r29, 0x3e	; 62
    5b28:	9c 83       	std	Y+4, r25	; 0x04
    5b2a:	8b 83       	std	Y+3, r24	; 0x03
	uint_8 *taskstr = (uint_8*)pvParameters;
    5b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    5b30:	9a 83       	std	Y+2, r25	; 0x02
    5b32:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		Command = Spi_SlaveRead();  //read from uart and save it to variable
    5b34:	0e 94 e3 1e 	call	0x3dc6	; 0x3dc6 <Spi_SlaveRead>
    5b38:	80 93 ad 04 	sts	0x04AD, r24
		vTaskDelay(100);
    5b3c:	84 e6       	ldi	r24, 0x64	; 100
    5b3e:	90 e0       	ldi	r25, 0x00	; 0
    5b40:	0e 94 9f 13 	call	0x273e	; 0x273e <vTaskDelay>
    5b44:	f7 cf       	rjmp	.-18     	; 0x5b34 <Task_1+0x18>

00005b46 <Task_2>:
	}
}

void Task_2(void *pvParameters)
{
    5b46:	0f 93       	push	r16
    5b48:	1f 93       	push	r17
    5b4a:	df 93       	push	r29
    5b4c:	cf 93       	push	r28
    5b4e:	cd b7       	in	r28, 0x3d	; 61
    5b50:	de b7       	in	r29, 0x3e	; 62
    5b52:	c1 5b       	subi	r28, 0xB1	; 177
    5b54:	d0 40       	sbci	r29, 0x00	; 0
    5b56:	0f b6       	in	r0, 0x3f	; 63
    5b58:	f8 94       	cli
    5b5a:	de bf       	out	0x3e, r29	; 62
    5b5c:	0f be       	out	0x3f, r0	; 63
    5b5e:	cd bf       	out	0x3d, r28	; 61
    5b60:	fe 01       	movw	r30, r28
    5b62:	e0 57       	subi	r30, 0x70	; 112
    5b64:	ff 4f       	sbci	r31, 0xFF	; 255
    5b66:	91 83       	std	Z+1, r25	; 0x01
    5b68:	80 83       	st	Z, r24
	uint_8 *taskstr = (uint_8*)pvParameters;
    5b6a:	de 01       	movw	r26, r28
    5b6c:	ab 5a       	subi	r26, 0xAB	; 171
    5b6e:	bf 4f       	sbci	r27, 0xFF	; 255
    5b70:	fe 01       	movw	r30, r28
    5b72:	e0 57       	subi	r30, 0x70	; 112
    5b74:	ff 4f       	sbci	r31, 0xFF	; 255
    5b76:	80 81       	ld	r24, Z
    5b78:	91 81       	ldd	r25, Z+1	; 0x01
    5b7a:	11 96       	adiw	r26, 0x01	; 1
    5b7c:	9c 93       	st	X, r25
    5b7e:	8e 93       	st	-X, r24
	uint_8 ON1[]="LED 1 ON";
    5b80:	ce 01       	movw	r24, r28
    5b82:	89 5a       	subi	r24, 0xA9	; 169
    5b84:	9f 4f       	sbci	r25, 0xFF	; 255
    5b86:	cc 56       	subi	r28, 0x6C	; 108
    5b88:	df 4f       	sbci	r29, 0xFF	; 255
    5b8a:	99 83       	std	Y+1, r25	; 0x01
    5b8c:	88 83       	st	Y, r24
    5b8e:	c4 59       	subi	r28, 0x94	; 148
    5b90:	d0 40       	sbci	r29, 0x00	; 0
    5b92:	29 e9       	ldi	r18, 0x99	; 153
    5b94:	30 e0       	ldi	r19, 0x00	; 0
    5b96:	ca 56       	subi	r28, 0x6A	; 106
    5b98:	df 4f       	sbci	r29, 0xFF	; 255
    5b9a:	39 83       	std	Y+1, r19	; 0x01
    5b9c:	28 83       	st	Y, r18
    5b9e:	c6 59       	subi	r28, 0x96	; 150
    5ba0:	d0 40       	sbci	r29, 0x00	; 0
    5ba2:	39 e0       	ldi	r19, 0x09	; 9
    5ba4:	c8 56       	subi	r28, 0x68	; 104
    5ba6:	df 4f       	sbci	r29, 0xFF	; 255
    5ba8:	38 83       	st	Y, r19
    5baa:	c8 59       	subi	r28, 0x98	; 152
    5bac:	d0 40       	sbci	r29, 0x00	; 0
    5bae:	ca 56       	subi	r28, 0x6A	; 106
    5bb0:	df 4f       	sbci	r29, 0xFF	; 255
    5bb2:	e8 81       	ld	r30, Y
    5bb4:	f9 81       	ldd	r31, Y+1	; 0x01
    5bb6:	c6 59       	subi	r28, 0x96	; 150
    5bb8:	d0 40       	sbci	r29, 0x00	; 0
    5bba:	00 80       	ld	r0, Z
    5bbc:	ca 56       	subi	r28, 0x6A	; 106
    5bbe:	df 4f       	sbci	r29, 0xFF	; 255
    5bc0:	28 81       	ld	r18, Y
    5bc2:	39 81       	ldd	r19, Y+1	; 0x01
    5bc4:	c6 59       	subi	r28, 0x96	; 150
    5bc6:	d0 40       	sbci	r29, 0x00	; 0
    5bc8:	2f 5f       	subi	r18, 0xFF	; 255
    5bca:	3f 4f       	sbci	r19, 0xFF	; 255
    5bcc:	ca 56       	subi	r28, 0x6A	; 106
    5bce:	df 4f       	sbci	r29, 0xFF	; 255
    5bd0:	39 83       	std	Y+1, r19	; 0x01
    5bd2:	28 83       	st	Y, r18
    5bd4:	c6 59       	subi	r28, 0x96	; 150
    5bd6:	d0 40       	sbci	r29, 0x00	; 0
    5bd8:	cc 56       	subi	r28, 0x6C	; 108
    5bda:	df 4f       	sbci	r29, 0xFF	; 255
    5bdc:	e8 81       	ld	r30, Y
    5bde:	f9 81       	ldd	r31, Y+1	; 0x01
    5be0:	c4 59       	subi	r28, 0x94	; 148
    5be2:	d0 40       	sbci	r29, 0x00	; 0
    5be4:	00 82       	st	Z, r0
    5be6:	cc 56       	subi	r28, 0x6C	; 108
    5be8:	df 4f       	sbci	r29, 0xFF	; 255
    5bea:	28 81       	ld	r18, Y
    5bec:	39 81       	ldd	r19, Y+1	; 0x01
    5bee:	c4 59       	subi	r28, 0x94	; 148
    5bf0:	d0 40       	sbci	r29, 0x00	; 0
    5bf2:	2f 5f       	subi	r18, 0xFF	; 255
    5bf4:	3f 4f       	sbci	r19, 0xFF	; 255
    5bf6:	cc 56       	subi	r28, 0x6C	; 108
    5bf8:	df 4f       	sbci	r29, 0xFF	; 255
    5bfa:	39 83       	std	Y+1, r19	; 0x01
    5bfc:	28 83       	st	Y, r18
    5bfe:	c4 59       	subi	r28, 0x94	; 148
    5c00:	d0 40       	sbci	r29, 0x00	; 0
    5c02:	c8 56       	subi	r28, 0x68	; 104
    5c04:	df 4f       	sbci	r29, 0xFF	; 255
    5c06:	38 81       	ld	r19, Y
    5c08:	c8 59       	subi	r28, 0x98	; 152
    5c0a:	d0 40       	sbci	r29, 0x00	; 0
    5c0c:	31 50       	subi	r19, 0x01	; 1
    5c0e:	c8 56       	subi	r28, 0x68	; 104
    5c10:	df 4f       	sbci	r29, 0xFF	; 255
    5c12:	38 83       	st	Y, r19
    5c14:	c8 59       	subi	r28, 0x98	; 152
    5c16:	d0 40       	sbci	r29, 0x00	; 0
    5c18:	c8 56       	subi	r28, 0x68	; 104
    5c1a:	df 4f       	sbci	r29, 0xFF	; 255
    5c1c:	88 81       	ld	r24, Y
    5c1e:	c8 59       	subi	r28, 0x98	; 152
    5c20:	d0 40       	sbci	r29, 0x00	; 0
    5c22:	88 23       	and	r24, r24
    5c24:	21 f6       	brne	.-120    	; 0x5bae <Task_2+0x68>
	uint_8 ON2[]="LED 2 ON";
    5c26:	ce 01       	movw	r24, r28
    5c28:	80 5a       	subi	r24, 0xA0	; 160
    5c2a:	9f 4f       	sbci	r25, 0xFF	; 255
    5c2c:	c7 56       	subi	r28, 0x67	; 103
    5c2e:	df 4f       	sbci	r29, 0xFF	; 255
    5c30:	99 83       	std	Y+1, r25	; 0x01
    5c32:	88 83       	st	Y, r24
    5c34:	c9 59       	subi	r28, 0x99	; 153
    5c36:	d0 40       	sbci	r29, 0x00	; 0
    5c38:	e2 ea       	ldi	r30, 0xA2	; 162
    5c3a:	f0 e0       	ldi	r31, 0x00	; 0
    5c3c:	c5 56       	subi	r28, 0x65	; 101
    5c3e:	df 4f       	sbci	r29, 0xFF	; 255
    5c40:	f9 83       	std	Y+1, r31	; 0x01
    5c42:	e8 83       	st	Y, r30
    5c44:	cb 59       	subi	r28, 0x9B	; 155
    5c46:	d0 40       	sbci	r29, 0x00	; 0
    5c48:	f9 e0       	ldi	r31, 0x09	; 9
    5c4a:	c3 56       	subi	r28, 0x63	; 99
    5c4c:	df 4f       	sbci	r29, 0xFF	; 255
    5c4e:	f8 83       	st	Y, r31
    5c50:	cd 59       	subi	r28, 0x9D	; 157
    5c52:	d0 40       	sbci	r29, 0x00	; 0
    5c54:	c5 56       	subi	r28, 0x65	; 101
    5c56:	df 4f       	sbci	r29, 0xFF	; 255
    5c58:	e8 81       	ld	r30, Y
    5c5a:	f9 81       	ldd	r31, Y+1	; 0x01
    5c5c:	cb 59       	subi	r28, 0x9B	; 155
    5c5e:	d0 40       	sbci	r29, 0x00	; 0
    5c60:	00 80       	ld	r0, Z
    5c62:	c5 56       	subi	r28, 0x65	; 101
    5c64:	df 4f       	sbci	r29, 0xFF	; 255
    5c66:	28 81       	ld	r18, Y
    5c68:	39 81       	ldd	r19, Y+1	; 0x01
    5c6a:	cb 59       	subi	r28, 0x9B	; 155
    5c6c:	d0 40       	sbci	r29, 0x00	; 0
    5c6e:	2f 5f       	subi	r18, 0xFF	; 255
    5c70:	3f 4f       	sbci	r19, 0xFF	; 255
    5c72:	c5 56       	subi	r28, 0x65	; 101
    5c74:	df 4f       	sbci	r29, 0xFF	; 255
    5c76:	39 83       	std	Y+1, r19	; 0x01
    5c78:	28 83       	st	Y, r18
    5c7a:	cb 59       	subi	r28, 0x9B	; 155
    5c7c:	d0 40       	sbci	r29, 0x00	; 0
    5c7e:	c7 56       	subi	r28, 0x67	; 103
    5c80:	df 4f       	sbci	r29, 0xFF	; 255
    5c82:	e8 81       	ld	r30, Y
    5c84:	f9 81       	ldd	r31, Y+1	; 0x01
    5c86:	c9 59       	subi	r28, 0x99	; 153
    5c88:	d0 40       	sbci	r29, 0x00	; 0
    5c8a:	00 82       	st	Z, r0
    5c8c:	c7 56       	subi	r28, 0x67	; 103
    5c8e:	df 4f       	sbci	r29, 0xFF	; 255
    5c90:	28 81       	ld	r18, Y
    5c92:	39 81       	ldd	r19, Y+1	; 0x01
    5c94:	c9 59       	subi	r28, 0x99	; 153
    5c96:	d0 40       	sbci	r29, 0x00	; 0
    5c98:	2f 5f       	subi	r18, 0xFF	; 255
    5c9a:	3f 4f       	sbci	r19, 0xFF	; 255
    5c9c:	c7 56       	subi	r28, 0x67	; 103
    5c9e:	df 4f       	sbci	r29, 0xFF	; 255
    5ca0:	39 83       	std	Y+1, r19	; 0x01
    5ca2:	28 83       	st	Y, r18
    5ca4:	c9 59       	subi	r28, 0x99	; 153
    5ca6:	d0 40       	sbci	r29, 0x00	; 0
    5ca8:	c3 56       	subi	r28, 0x63	; 99
    5caa:	df 4f       	sbci	r29, 0xFF	; 255
    5cac:	38 81       	ld	r19, Y
    5cae:	cd 59       	subi	r28, 0x9D	; 157
    5cb0:	d0 40       	sbci	r29, 0x00	; 0
    5cb2:	31 50       	subi	r19, 0x01	; 1
    5cb4:	c3 56       	subi	r28, 0x63	; 99
    5cb6:	df 4f       	sbci	r29, 0xFF	; 255
    5cb8:	38 83       	st	Y, r19
    5cba:	cd 59       	subi	r28, 0x9D	; 157
    5cbc:	d0 40       	sbci	r29, 0x00	; 0
    5cbe:	c3 56       	subi	r28, 0x63	; 99
    5cc0:	df 4f       	sbci	r29, 0xFF	; 255
    5cc2:	88 81       	ld	r24, Y
    5cc4:	cd 59       	subi	r28, 0x9D	; 157
    5cc6:	d0 40       	sbci	r29, 0x00	; 0
    5cc8:	88 23       	and	r24, r24
    5cca:	21 f6       	brne	.-120    	; 0x5c54 <Task_2+0x10e>
	uint_8 ON3[]="LED 3 ON";
    5ccc:	ce 01       	movw	r24, r28
    5cce:	87 59       	subi	r24, 0x97	; 151
    5cd0:	9f 4f       	sbci	r25, 0xFF	; 255
    5cd2:	c2 56       	subi	r28, 0x62	; 98
    5cd4:	df 4f       	sbci	r29, 0xFF	; 255
    5cd6:	99 83       	std	Y+1, r25	; 0x01
    5cd8:	88 83       	st	Y, r24
    5cda:	ce 59       	subi	r28, 0x9E	; 158
    5cdc:	d0 40       	sbci	r29, 0x00	; 0
    5cde:	eb ea       	ldi	r30, 0xAB	; 171
    5ce0:	f0 e0       	ldi	r31, 0x00	; 0
    5ce2:	c0 56       	subi	r28, 0x60	; 96
    5ce4:	df 4f       	sbci	r29, 0xFF	; 255
    5ce6:	f9 83       	std	Y+1, r31	; 0x01
    5ce8:	e8 83       	st	Y, r30
    5cea:	c0 5a       	subi	r28, 0xA0	; 160
    5cec:	d0 40       	sbci	r29, 0x00	; 0
    5cee:	f9 e0       	ldi	r31, 0x09	; 9
    5cf0:	ce 55       	subi	r28, 0x5E	; 94
    5cf2:	df 4f       	sbci	r29, 0xFF	; 255
    5cf4:	f8 83       	st	Y, r31
    5cf6:	c2 5a       	subi	r28, 0xA2	; 162
    5cf8:	d0 40       	sbci	r29, 0x00	; 0
    5cfa:	c0 56       	subi	r28, 0x60	; 96
    5cfc:	df 4f       	sbci	r29, 0xFF	; 255
    5cfe:	e8 81       	ld	r30, Y
    5d00:	f9 81       	ldd	r31, Y+1	; 0x01
    5d02:	c0 5a       	subi	r28, 0xA0	; 160
    5d04:	d0 40       	sbci	r29, 0x00	; 0
    5d06:	00 80       	ld	r0, Z
    5d08:	c0 56       	subi	r28, 0x60	; 96
    5d0a:	df 4f       	sbci	r29, 0xFF	; 255
    5d0c:	28 81       	ld	r18, Y
    5d0e:	39 81       	ldd	r19, Y+1	; 0x01
    5d10:	c0 5a       	subi	r28, 0xA0	; 160
    5d12:	d0 40       	sbci	r29, 0x00	; 0
    5d14:	2f 5f       	subi	r18, 0xFF	; 255
    5d16:	3f 4f       	sbci	r19, 0xFF	; 255
    5d18:	c0 56       	subi	r28, 0x60	; 96
    5d1a:	df 4f       	sbci	r29, 0xFF	; 255
    5d1c:	39 83       	std	Y+1, r19	; 0x01
    5d1e:	28 83       	st	Y, r18
    5d20:	c0 5a       	subi	r28, 0xA0	; 160
    5d22:	d0 40       	sbci	r29, 0x00	; 0
    5d24:	c2 56       	subi	r28, 0x62	; 98
    5d26:	df 4f       	sbci	r29, 0xFF	; 255
    5d28:	e8 81       	ld	r30, Y
    5d2a:	f9 81       	ldd	r31, Y+1	; 0x01
    5d2c:	ce 59       	subi	r28, 0x9E	; 158
    5d2e:	d0 40       	sbci	r29, 0x00	; 0
    5d30:	00 82       	st	Z, r0
    5d32:	c2 56       	subi	r28, 0x62	; 98
    5d34:	df 4f       	sbci	r29, 0xFF	; 255
    5d36:	28 81       	ld	r18, Y
    5d38:	39 81       	ldd	r19, Y+1	; 0x01
    5d3a:	ce 59       	subi	r28, 0x9E	; 158
    5d3c:	d0 40       	sbci	r29, 0x00	; 0
    5d3e:	2f 5f       	subi	r18, 0xFF	; 255
    5d40:	3f 4f       	sbci	r19, 0xFF	; 255
    5d42:	c2 56       	subi	r28, 0x62	; 98
    5d44:	df 4f       	sbci	r29, 0xFF	; 255
    5d46:	39 83       	std	Y+1, r19	; 0x01
    5d48:	28 83       	st	Y, r18
    5d4a:	ce 59       	subi	r28, 0x9E	; 158
    5d4c:	d0 40       	sbci	r29, 0x00	; 0
    5d4e:	ce 55       	subi	r28, 0x5E	; 94
    5d50:	df 4f       	sbci	r29, 0xFF	; 255
    5d52:	38 81       	ld	r19, Y
    5d54:	c2 5a       	subi	r28, 0xA2	; 162
    5d56:	d0 40       	sbci	r29, 0x00	; 0
    5d58:	31 50       	subi	r19, 0x01	; 1
    5d5a:	ce 55       	subi	r28, 0x5E	; 94
    5d5c:	df 4f       	sbci	r29, 0xFF	; 255
    5d5e:	38 83       	st	Y, r19
    5d60:	c2 5a       	subi	r28, 0xA2	; 162
    5d62:	d0 40       	sbci	r29, 0x00	; 0
    5d64:	ce 55       	subi	r28, 0x5E	; 94
    5d66:	df 4f       	sbci	r29, 0xFF	; 255
    5d68:	88 81       	ld	r24, Y
    5d6a:	c2 5a       	subi	r28, 0xA2	; 162
    5d6c:	d0 40       	sbci	r29, 0x00	; 0
    5d6e:	88 23       	and	r24, r24
    5d70:	21 f6       	brne	.-120    	; 0x5cfa <Task_2+0x1b4>
	uint_8 OFF1[]="LED 1 OFF";
    5d72:	ce 01       	movw	r24, r28
    5d74:	8e 58       	subi	r24, 0x8E	; 142
    5d76:	9f 4f       	sbci	r25, 0xFF	; 255
    5d78:	cd 55       	subi	r28, 0x5D	; 93
    5d7a:	df 4f       	sbci	r29, 0xFF	; 255
    5d7c:	99 83       	std	Y+1, r25	; 0x01
    5d7e:	88 83       	st	Y, r24
    5d80:	c3 5a       	subi	r28, 0xA3	; 163
    5d82:	d0 40       	sbci	r29, 0x00	; 0
    5d84:	e4 eb       	ldi	r30, 0xB4	; 180
    5d86:	f0 e0       	ldi	r31, 0x00	; 0
    5d88:	cb 55       	subi	r28, 0x5B	; 91
    5d8a:	df 4f       	sbci	r29, 0xFF	; 255
    5d8c:	f9 83       	std	Y+1, r31	; 0x01
    5d8e:	e8 83       	st	Y, r30
    5d90:	c5 5a       	subi	r28, 0xA5	; 165
    5d92:	d0 40       	sbci	r29, 0x00	; 0
    5d94:	fa e0       	ldi	r31, 0x0A	; 10
    5d96:	c9 55       	subi	r28, 0x59	; 89
    5d98:	df 4f       	sbci	r29, 0xFF	; 255
    5d9a:	f8 83       	st	Y, r31
    5d9c:	c7 5a       	subi	r28, 0xA7	; 167
    5d9e:	d0 40       	sbci	r29, 0x00	; 0
    5da0:	cb 55       	subi	r28, 0x5B	; 91
    5da2:	df 4f       	sbci	r29, 0xFF	; 255
    5da4:	e8 81       	ld	r30, Y
    5da6:	f9 81       	ldd	r31, Y+1	; 0x01
    5da8:	c5 5a       	subi	r28, 0xA5	; 165
    5daa:	d0 40       	sbci	r29, 0x00	; 0
    5dac:	00 80       	ld	r0, Z
    5dae:	cb 55       	subi	r28, 0x5B	; 91
    5db0:	df 4f       	sbci	r29, 0xFF	; 255
    5db2:	28 81       	ld	r18, Y
    5db4:	39 81       	ldd	r19, Y+1	; 0x01
    5db6:	c5 5a       	subi	r28, 0xA5	; 165
    5db8:	d0 40       	sbci	r29, 0x00	; 0
    5dba:	2f 5f       	subi	r18, 0xFF	; 255
    5dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    5dbe:	cb 55       	subi	r28, 0x5B	; 91
    5dc0:	df 4f       	sbci	r29, 0xFF	; 255
    5dc2:	39 83       	std	Y+1, r19	; 0x01
    5dc4:	28 83       	st	Y, r18
    5dc6:	c5 5a       	subi	r28, 0xA5	; 165
    5dc8:	d0 40       	sbci	r29, 0x00	; 0
    5dca:	cd 55       	subi	r28, 0x5D	; 93
    5dcc:	df 4f       	sbci	r29, 0xFF	; 255
    5dce:	e8 81       	ld	r30, Y
    5dd0:	f9 81       	ldd	r31, Y+1	; 0x01
    5dd2:	c3 5a       	subi	r28, 0xA3	; 163
    5dd4:	d0 40       	sbci	r29, 0x00	; 0
    5dd6:	00 82       	st	Z, r0
    5dd8:	cd 55       	subi	r28, 0x5D	; 93
    5dda:	df 4f       	sbci	r29, 0xFF	; 255
    5ddc:	28 81       	ld	r18, Y
    5dde:	39 81       	ldd	r19, Y+1	; 0x01
    5de0:	c3 5a       	subi	r28, 0xA3	; 163
    5de2:	d0 40       	sbci	r29, 0x00	; 0
    5de4:	2f 5f       	subi	r18, 0xFF	; 255
    5de6:	3f 4f       	sbci	r19, 0xFF	; 255
    5de8:	cd 55       	subi	r28, 0x5D	; 93
    5dea:	df 4f       	sbci	r29, 0xFF	; 255
    5dec:	39 83       	std	Y+1, r19	; 0x01
    5dee:	28 83       	st	Y, r18
    5df0:	c3 5a       	subi	r28, 0xA3	; 163
    5df2:	d0 40       	sbci	r29, 0x00	; 0
    5df4:	c9 55       	subi	r28, 0x59	; 89
    5df6:	df 4f       	sbci	r29, 0xFF	; 255
    5df8:	38 81       	ld	r19, Y
    5dfa:	c7 5a       	subi	r28, 0xA7	; 167
    5dfc:	d0 40       	sbci	r29, 0x00	; 0
    5dfe:	31 50       	subi	r19, 0x01	; 1
    5e00:	c9 55       	subi	r28, 0x59	; 89
    5e02:	df 4f       	sbci	r29, 0xFF	; 255
    5e04:	38 83       	st	Y, r19
    5e06:	c7 5a       	subi	r28, 0xA7	; 167
    5e08:	d0 40       	sbci	r29, 0x00	; 0
    5e0a:	c9 55       	subi	r28, 0x59	; 89
    5e0c:	df 4f       	sbci	r29, 0xFF	; 255
    5e0e:	88 81       	ld	r24, Y
    5e10:	c7 5a       	subi	r28, 0xA7	; 167
    5e12:	d0 40       	sbci	r29, 0x00	; 0
    5e14:	88 23       	and	r24, r24
    5e16:	21 f6       	brne	.-120    	; 0x5da0 <Task_2+0x25a>
	uint_8 OFF2[]="LED 2 OFF";
    5e18:	ce 01       	movw	r24, r28
    5e1a:	84 58       	subi	r24, 0x84	; 132
    5e1c:	9f 4f       	sbci	r25, 0xFF	; 255
    5e1e:	c8 55       	subi	r28, 0x58	; 88
    5e20:	df 4f       	sbci	r29, 0xFF	; 255
    5e22:	99 83       	std	Y+1, r25	; 0x01
    5e24:	88 83       	st	Y, r24
    5e26:	c8 5a       	subi	r28, 0xA8	; 168
    5e28:	d0 40       	sbci	r29, 0x00	; 0
    5e2a:	ee eb       	ldi	r30, 0xBE	; 190
    5e2c:	f0 e0       	ldi	r31, 0x00	; 0
    5e2e:	c6 55       	subi	r28, 0x56	; 86
    5e30:	df 4f       	sbci	r29, 0xFF	; 255
    5e32:	f9 83       	std	Y+1, r31	; 0x01
    5e34:	e8 83       	st	Y, r30
    5e36:	ca 5a       	subi	r28, 0xAA	; 170
    5e38:	d0 40       	sbci	r29, 0x00	; 0
    5e3a:	fa e0       	ldi	r31, 0x0A	; 10
    5e3c:	c4 55       	subi	r28, 0x54	; 84
    5e3e:	df 4f       	sbci	r29, 0xFF	; 255
    5e40:	f8 83       	st	Y, r31
    5e42:	cc 5a       	subi	r28, 0xAC	; 172
    5e44:	d0 40       	sbci	r29, 0x00	; 0
    5e46:	c6 55       	subi	r28, 0x56	; 86
    5e48:	df 4f       	sbci	r29, 0xFF	; 255
    5e4a:	e8 81       	ld	r30, Y
    5e4c:	f9 81       	ldd	r31, Y+1	; 0x01
    5e4e:	ca 5a       	subi	r28, 0xAA	; 170
    5e50:	d0 40       	sbci	r29, 0x00	; 0
    5e52:	00 80       	ld	r0, Z
    5e54:	c6 55       	subi	r28, 0x56	; 86
    5e56:	df 4f       	sbci	r29, 0xFF	; 255
    5e58:	28 81       	ld	r18, Y
    5e5a:	39 81       	ldd	r19, Y+1	; 0x01
    5e5c:	ca 5a       	subi	r28, 0xAA	; 170
    5e5e:	d0 40       	sbci	r29, 0x00	; 0
    5e60:	2f 5f       	subi	r18, 0xFF	; 255
    5e62:	3f 4f       	sbci	r19, 0xFF	; 255
    5e64:	c6 55       	subi	r28, 0x56	; 86
    5e66:	df 4f       	sbci	r29, 0xFF	; 255
    5e68:	39 83       	std	Y+1, r19	; 0x01
    5e6a:	28 83       	st	Y, r18
    5e6c:	ca 5a       	subi	r28, 0xAA	; 170
    5e6e:	d0 40       	sbci	r29, 0x00	; 0
    5e70:	c8 55       	subi	r28, 0x58	; 88
    5e72:	df 4f       	sbci	r29, 0xFF	; 255
    5e74:	e8 81       	ld	r30, Y
    5e76:	f9 81       	ldd	r31, Y+1	; 0x01
    5e78:	c8 5a       	subi	r28, 0xA8	; 168
    5e7a:	d0 40       	sbci	r29, 0x00	; 0
    5e7c:	00 82       	st	Z, r0
    5e7e:	c8 55       	subi	r28, 0x58	; 88
    5e80:	df 4f       	sbci	r29, 0xFF	; 255
    5e82:	28 81       	ld	r18, Y
    5e84:	39 81       	ldd	r19, Y+1	; 0x01
    5e86:	c8 5a       	subi	r28, 0xA8	; 168
    5e88:	d0 40       	sbci	r29, 0x00	; 0
    5e8a:	2f 5f       	subi	r18, 0xFF	; 255
    5e8c:	3f 4f       	sbci	r19, 0xFF	; 255
    5e8e:	c8 55       	subi	r28, 0x58	; 88
    5e90:	df 4f       	sbci	r29, 0xFF	; 255
    5e92:	39 83       	std	Y+1, r19	; 0x01
    5e94:	28 83       	st	Y, r18
    5e96:	c8 5a       	subi	r28, 0xA8	; 168
    5e98:	d0 40       	sbci	r29, 0x00	; 0
    5e9a:	c4 55       	subi	r28, 0x54	; 84
    5e9c:	df 4f       	sbci	r29, 0xFF	; 255
    5e9e:	38 81       	ld	r19, Y
    5ea0:	cc 5a       	subi	r28, 0xAC	; 172
    5ea2:	d0 40       	sbci	r29, 0x00	; 0
    5ea4:	31 50       	subi	r19, 0x01	; 1
    5ea6:	c4 55       	subi	r28, 0x54	; 84
    5ea8:	df 4f       	sbci	r29, 0xFF	; 255
    5eaa:	38 83       	st	Y, r19
    5eac:	cc 5a       	subi	r28, 0xAC	; 172
    5eae:	d0 40       	sbci	r29, 0x00	; 0
    5eb0:	c4 55       	subi	r28, 0x54	; 84
    5eb2:	df 4f       	sbci	r29, 0xFF	; 255
    5eb4:	88 81       	ld	r24, Y
    5eb6:	cc 5a       	subi	r28, 0xAC	; 172
    5eb8:	d0 40       	sbci	r29, 0x00	; 0
    5eba:	88 23       	and	r24, r24
    5ebc:	21 f6       	brne	.-120    	; 0x5e46 <Task_2+0x300>
	uint_8 OFF3[]="LED 3 OFF";
    5ebe:	ce 01       	movw	r24, r28
    5ec0:	8a 57       	subi	r24, 0x7A	; 122
    5ec2:	9f 4f       	sbci	r25, 0xFF	; 255
    5ec4:	c3 55       	subi	r28, 0x53	; 83
    5ec6:	df 4f       	sbci	r29, 0xFF	; 255
    5ec8:	99 83       	std	Y+1, r25	; 0x01
    5eca:	88 83       	st	Y, r24
    5ecc:	cd 5a       	subi	r28, 0xAD	; 173
    5ece:	d0 40       	sbci	r29, 0x00	; 0
    5ed0:	e8 ec       	ldi	r30, 0xC8	; 200
    5ed2:	f0 e0       	ldi	r31, 0x00	; 0
    5ed4:	c1 55       	subi	r28, 0x51	; 81
    5ed6:	df 4f       	sbci	r29, 0xFF	; 255
    5ed8:	f9 83       	std	Y+1, r31	; 0x01
    5eda:	e8 83       	st	Y, r30
    5edc:	cf 5a       	subi	r28, 0xAF	; 175
    5ede:	d0 40       	sbci	r29, 0x00	; 0
    5ee0:	fa e0       	ldi	r31, 0x0A	; 10
    5ee2:	cf 54       	subi	r28, 0x4F	; 79
    5ee4:	df 4f       	sbci	r29, 0xFF	; 255
    5ee6:	f8 83       	st	Y, r31
    5ee8:	c1 5b       	subi	r28, 0xB1	; 177
    5eea:	d0 40       	sbci	r29, 0x00	; 0
    5eec:	c1 55       	subi	r28, 0x51	; 81
    5eee:	df 4f       	sbci	r29, 0xFF	; 255
    5ef0:	e8 81       	ld	r30, Y
    5ef2:	f9 81       	ldd	r31, Y+1	; 0x01
    5ef4:	cf 5a       	subi	r28, 0xAF	; 175
    5ef6:	d0 40       	sbci	r29, 0x00	; 0
    5ef8:	00 80       	ld	r0, Z
    5efa:	c1 55       	subi	r28, 0x51	; 81
    5efc:	df 4f       	sbci	r29, 0xFF	; 255
    5efe:	28 81       	ld	r18, Y
    5f00:	39 81       	ldd	r19, Y+1	; 0x01
    5f02:	cf 5a       	subi	r28, 0xAF	; 175
    5f04:	d0 40       	sbci	r29, 0x00	; 0
    5f06:	2f 5f       	subi	r18, 0xFF	; 255
    5f08:	3f 4f       	sbci	r19, 0xFF	; 255
    5f0a:	c1 55       	subi	r28, 0x51	; 81
    5f0c:	df 4f       	sbci	r29, 0xFF	; 255
    5f0e:	39 83       	std	Y+1, r19	; 0x01
    5f10:	28 83       	st	Y, r18
    5f12:	cf 5a       	subi	r28, 0xAF	; 175
    5f14:	d0 40       	sbci	r29, 0x00	; 0
    5f16:	c3 55       	subi	r28, 0x53	; 83
    5f18:	df 4f       	sbci	r29, 0xFF	; 255
    5f1a:	e8 81       	ld	r30, Y
    5f1c:	f9 81       	ldd	r31, Y+1	; 0x01
    5f1e:	cd 5a       	subi	r28, 0xAD	; 173
    5f20:	d0 40       	sbci	r29, 0x00	; 0
    5f22:	00 82       	st	Z, r0
    5f24:	c3 55       	subi	r28, 0x53	; 83
    5f26:	df 4f       	sbci	r29, 0xFF	; 255
    5f28:	28 81       	ld	r18, Y
    5f2a:	39 81       	ldd	r19, Y+1	; 0x01
    5f2c:	cd 5a       	subi	r28, 0xAD	; 173
    5f2e:	d0 40       	sbci	r29, 0x00	; 0
    5f30:	2f 5f       	subi	r18, 0xFF	; 255
    5f32:	3f 4f       	sbci	r19, 0xFF	; 255
    5f34:	c3 55       	subi	r28, 0x53	; 83
    5f36:	df 4f       	sbci	r29, 0xFF	; 255
    5f38:	39 83       	std	Y+1, r19	; 0x01
    5f3a:	28 83       	st	Y, r18
    5f3c:	cd 5a       	subi	r28, 0xAD	; 173
    5f3e:	d0 40       	sbci	r29, 0x00	; 0
    5f40:	cf 54       	subi	r28, 0x4F	; 79
    5f42:	df 4f       	sbci	r29, 0xFF	; 255
    5f44:	38 81       	ld	r19, Y
    5f46:	c1 5b       	subi	r28, 0xB1	; 177
    5f48:	d0 40       	sbci	r29, 0x00	; 0
    5f4a:	31 50       	subi	r19, 0x01	; 1
    5f4c:	cf 54       	subi	r28, 0x4F	; 79
    5f4e:	df 4f       	sbci	r29, 0xFF	; 255
    5f50:	38 83       	st	Y, r19
    5f52:	c1 5b       	subi	r28, 0xB1	; 177
    5f54:	d0 40       	sbci	r29, 0x00	; 0
    5f56:	cf 54       	subi	r28, 0x4F	; 79
    5f58:	df 4f       	sbci	r29, 0xFF	; 255
    5f5a:	88 81       	ld	r24, Y
    5f5c:	c1 5b       	subi	r28, 0xB1	; 177
    5f5e:	d0 40       	sbci	r29, 0x00	; 0
    5f60:	88 23       	and	r24, r24
    5f62:	21 f6       	brne	.-120    	; 0x5eec <Task_2+0x3a6>
	while(1)
	{
		switch (Command)
    5f64:	80 91 ad 04 	lds	r24, 0x04AD
    5f68:	e8 2f       	mov	r30, r24
    5f6a:	f0 e0       	ldi	r31, 0x00	; 0
    5f6c:	ce 56       	subi	r28, 0x6E	; 110
    5f6e:	df 4f       	sbci	r29, 0xFF	; 255
    5f70:	f9 83       	std	Y+1, r31	; 0x01
    5f72:	e8 83       	st	Y, r30
    5f74:	c2 59       	subi	r28, 0x92	; 146
    5f76:	d0 40       	sbci	r29, 0x00	; 0
    5f78:	ce 56       	subi	r28, 0x6E	; 110
    5f7a:	df 4f       	sbci	r29, 0xFF	; 255
    5f7c:	28 81       	ld	r18, Y
    5f7e:	39 81       	ldd	r19, Y+1	; 0x01
    5f80:	c2 59       	subi	r28, 0x92	; 146
    5f82:	d0 40       	sbci	r29, 0x00	; 0
    5f84:	23 33       	cpi	r18, 0x33	; 51
    5f86:	31 05       	cpc	r19, r1
    5f88:	09 f4       	brne	.+2      	; 0x5f8c <Task_2+0x446>
    5f8a:	95 c1       	rjmp	.+810    	; 0x62b6 <Task_2+0x770>
    5f8c:	ce 56       	subi	r28, 0x6E	; 110
    5f8e:	df 4f       	sbci	r29, 0xFF	; 255
    5f90:	88 81       	ld	r24, Y
    5f92:	99 81       	ldd	r25, Y+1	; 0x01
    5f94:	c2 59       	subi	r28, 0x92	; 146
    5f96:	d0 40       	sbci	r29, 0x00	; 0
    5f98:	84 33       	cpi	r24, 0x34	; 52
    5f9a:	91 05       	cpc	r25, r1
    5f9c:	a4 f4       	brge	.+40     	; 0x5fc6 <Task_2+0x480>
    5f9e:	ce 56       	subi	r28, 0x6E	; 110
    5fa0:	df 4f       	sbci	r29, 0xFF	; 255
    5fa2:	e8 81       	ld	r30, Y
    5fa4:	f9 81       	ldd	r31, Y+1	; 0x01
    5fa6:	c2 59       	subi	r28, 0x92	; 146
    5fa8:	d0 40       	sbci	r29, 0x00	; 0
    5faa:	e1 33       	cpi	r30, 0x31	; 49
    5fac:	f1 05       	cpc	r31, r1
    5fae:	51 f1       	breq	.+84     	; 0x6004 <Task_2+0x4be>
    5fb0:	ce 56       	subi	r28, 0x6E	; 110
    5fb2:	df 4f       	sbci	r29, 0xFF	; 255
    5fb4:	28 81       	ld	r18, Y
    5fb6:	39 81       	ldd	r19, Y+1	; 0x01
    5fb8:	c2 59       	subi	r28, 0x92	; 146
    5fba:	d0 40       	sbci	r29, 0x00	; 0
    5fbc:	22 33       	cpi	r18, 0x32	; 50
    5fbe:	31 05       	cpc	r19, r1
    5fc0:	09 f4       	brne	.+2      	; 0x5fc4 <Task_2+0x47e>
    5fc2:	e4 c0       	rjmp	.+456    	; 0x618c <Task_2+0x646>
    5fc4:	cf cf       	rjmp	.-98     	; 0x5f64 <Task_2+0x41e>
    5fc6:	ce 56       	subi	r28, 0x6E	; 110
    5fc8:	df 4f       	sbci	r29, 0xFF	; 255
    5fca:	88 81       	ld	r24, Y
    5fcc:	99 81       	ldd	r25, Y+1	; 0x01
    5fce:	c2 59       	subi	r28, 0x92	; 146
    5fd0:	d0 40       	sbci	r29, 0x00	; 0
    5fd2:	85 33       	cpi	r24, 0x35	; 53
    5fd4:	91 05       	cpc	r25, r1
    5fd6:	09 f4       	brne	.+2      	; 0x5fda <Task_2+0x494>
    5fd8:	72 c2       	rjmp	.+1252   	; 0x64be <Task_2+0x978>
    5fda:	ce 56       	subi	r28, 0x6E	; 110
    5fdc:	df 4f       	sbci	r29, 0xFF	; 255
    5fde:	e8 81       	ld	r30, Y
    5fe0:	f9 81       	ldd	r31, Y+1	; 0x01
    5fe2:	c2 59       	subi	r28, 0x92	; 146
    5fe4:	d0 40       	sbci	r29, 0x00	; 0
    5fe6:	e5 33       	cpi	r30, 0x35	; 53
    5fe8:	f1 05       	cpc	r31, r1
    5fea:	0c f4       	brge	.+2      	; 0x5fee <Task_2+0x4a8>
    5fec:	e6 c1       	rjmp	.+972    	; 0x63ba <Task_2+0x874>
    5fee:	ce 56       	subi	r28, 0x6E	; 110
    5ff0:	df 4f       	sbci	r29, 0xFF	; 255
    5ff2:	28 81       	ld	r18, Y
    5ff4:	39 81       	ldd	r19, Y+1	; 0x01
    5ff6:	c2 59       	subi	r28, 0x92	; 146
    5ff8:	d0 40       	sbci	r29, 0x00	; 0
    5ffa:	26 33       	cpi	r18, 0x36	; 54
    5ffc:	31 05       	cpc	r19, r1
    5ffe:	09 f4       	brne	.+2      	; 0x6002 <Task_2+0x4bc>
    6000:	e0 c2       	rjmp	.+1472   	; 0x65c2 <Task_2+0xa7c>
    6002:	b0 cf       	rjmp	.-160    	; 0x5f64 <Task_2+0x41e>
				{
					case '1': Led_ON(LED0);   UART_SendStr(ON1); LCD_ClearScreen_4bit(); LCD_WRITE_STRING_4bit(ON1) ; _delay_ms(100);  break;   /* Turn ON LED */
    6004:	80 e0       	ldi	r24, 0x00	; 0
    6006:	0e 94 b0 24 	call	0x4960	; 0x4960 <Led_ON>
    600a:	ce 01       	movw	r24, r28
    600c:	89 5a       	subi	r24, 0xA9	; 169
    600e:	9f 4f       	sbci	r25, 0xFF	; 255
    6010:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
    6014:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <LCD_ClearScreen_4bit>
    6018:	ce 01       	movw	r24, r28
    601a:	89 5a       	subi	r24, 0xA9	; 169
    601c:	9f 4f       	sbci	r25, 0xFF	; 255
    601e:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
    6022:	fe 01       	movw	r30, r28
    6024:	ef 5a       	subi	r30, 0xAF	; 175
    6026:	ff 4f       	sbci	r31, 0xFF	; 255
    6028:	80 e0       	ldi	r24, 0x00	; 0
    602a:	90 e0       	ldi	r25, 0x00	; 0
    602c:	a8 ec       	ldi	r26, 0xC8	; 200
    602e:	b2 e4       	ldi	r27, 0x42	; 66
    6030:	80 83       	st	Z, r24
    6032:	91 83       	std	Z+1, r25	; 0x01
    6034:	a2 83       	std	Z+2, r26	; 0x02
    6036:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    6038:	8e 01       	movw	r16, r28
    603a:	03 5b       	subi	r16, 0xB3	; 179
    603c:	1f 4f       	sbci	r17, 0xFF	; 255
    603e:	fe 01       	movw	r30, r28
    6040:	ef 5a       	subi	r30, 0xAF	; 175
    6042:	ff 4f       	sbci	r31, 0xFF	; 255
    6044:	60 81       	ld	r22, Z
    6046:	71 81       	ldd	r23, Z+1	; 0x01
    6048:	82 81       	ldd	r24, Z+2	; 0x02
    604a:	93 81       	ldd	r25, Z+3	; 0x03
    604c:	20 e0       	ldi	r18, 0x00	; 0
    604e:	30 e0       	ldi	r19, 0x00	; 0
    6050:	4a e7       	ldi	r20, 0x7A	; 122
    6052:	55 e4       	ldi	r21, 0x45	; 69
    6054:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6058:	dc 01       	movw	r26, r24
    605a:	cb 01       	movw	r24, r22
    605c:	f8 01       	movw	r30, r16
    605e:	80 83       	st	Z, r24
    6060:	91 83       	std	Z+1, r25	; 0x01
    6062:	a2 83       	std	Z+2, r26	; 0x02
    6064:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    6066:	fe 01       	movw	r30, r28
    6068:	e3 5b       	subi	r30, 0xB3	; 179
    606a:	ff 4f       	sbci	r31, 0xFF	; 255
    606c:	60 81       	ld	r22, Z
    606e:	71 81       	ldd	r23, Z+1	; 0x01
    6070:	82 81       	ldd	r24, Z+2	; 0x02
    6072:	93 81       	ldd	r25, Z+3	; 0x03
    6074:	20 e0       	ldi	r18, 0x00	; 0
    6076:	30 e0       	ldi	r19, 0x00	; 0
    6078:	40 e8       	ldi	r20, 0x80	; 128
    607a:	5f e3       	ldi	r21, 0x3F	; 63
    607c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    6080:	88 23       	and	r24, r24
    6082:	44 f4       	brge	.+16     	; 0x6094 <Task_2+0x54e>
		__ticks = 1;
    6084:	fe 01       	movw	r30, r28
    6086:	e5 5b       	subi	r30, 0xB5	; 181
    6088:	ff 4f       	sbci	r31, 0xFF	; 255
    608a:	81 e0       	ldi	r24, 0x01	; 1
    608c:	90 e0       	ldi	r25, 0x00	; 0
    608e:	91 83       	std	Z+1, r25	; 0x01
    6090:	80 83       	st	Z, r24
    6092:	64 c0       	rjmp	.+200    	; 0x615c <Task_2+0x616>
	else if (__tmp > 65535)
    6094:	fe 01       	movw	r30, r28
    6096:	e3 5b       	subi	r30, 0xB3	; 179
    6098:	ff 4f       	sbci	r31, 0xFF	; 255
    609a:	60 81       	ld	r22, Z
    609c:	71 81       	ldd	r23, Z+1	; 0x01
    609e:	82 81       	ldd	r24, Z+2	; 0x02
    60a0:	93 81       	ldd	r25, Z+3	; 0x03
    60a2:	20 e0       	ldi	r18, 0x00	; 0
    60a4:	3f ef       	ldi	r19, 0xFF	; 255
    60a6:	4f e7       	ldi	r20, 0x7F	; 127
    60a8:	57 e4       	ldi	r21, 0x47	; 71
    60aa:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    60ae:	18 16       	cp	r1, r24
    60b0:	0c f0       	brlt	.+2      	; 0x60b4 <Task_2+0x56e>
    60b2:	43 c0       	rjmp	.+134    	; 0x613a <Task_2+0x5f4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    60b4:	fe 01       	movw	r30, r28
    60b6:	ef 5a       	subi	r30, 0xAF	; 175
    60b8:	ff 4f       	sbci	r31, 0xFF	; 255
    60ba:	60 81       	ld	r22, Z
    60bc:	71 81       	ldd	r23, Z+1	; 0x01
    60be:	82 81       	ldd	r24, Z+2	; 0x02
    60c0:	93 81       	ldd	r25, Z+3	; 0x03
    60c2:	20 e0       	ldi	r18, 0x00	; 0
    60c4:	30 e0       	ldi	r19, 0x00	; 0
    60c6:	40 e2       	ldi	r20, 0x20	; 32
    60c8:	51 e4       	ldi	r21, 0x41	; 65
    60ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    60ce:	dc 01       	movw	r26, r24
    60d0:	cb 01       	movw	r24, r22
    60d2:	8e 01       	movw	r16, r28
    60d4:	05 5b       	subi	r16, 0xB5	; 181
    60d6:	1f 4f       	sbci	r17, 0xFF	; 255
    60d8:	bc 01       	movw	r22, r24
    60da:	cd 01       	movw	r24, r26
    60dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    60e0:	dc 01       	movw	r26, r24
    60e2:	cb 01       	movw	r24, r22
    60e4:	f8 01       	movw	r30, r16
    60e6:	91 83       	std	Z+1, r25	; 0x01
    60e8:	80 83       	st	Z, r24
    60ea:	1f c0       	rjmp	.+62     	; 0x612a <Task_2+0x5e4>
    60ec:	fe 01       	movw	r30, r28
    60ee:	e7 5b       	subi	r30, 0xB7	; 183
    60f0:	ff 4f       	sbci	r31, 0xFF	; 255
    60f2:	80 e9       	ldi	r24, 0x90	; 144
    60f4:	91 e0       	ldi	r25, 0x01	; 1
    60f6:	91 83       	std	Z+1, r25	; 0x01
    60f8:	80 83       	st	Z, r24
    60fa:	fe 01       	movw	r30, r28
    60fc:	e7 5b       	subi	r30, 0xB7	; 183
    60fe:	ff 4f       	sbci	r31, 0xFF	; 255
    6100:	80 81       	ld	r24, Z
    6102:	91 81       	ldd	r25, Z+1	; 0x01
    6104:	01 97       	sbiw	r24, 0x01	; 1
    6106:	f1 f7       	brne	.-4      	; 0x6104 <Task_2+0x5be>
    6108:	fe 01       	movw	r30, r28
    610a:	e7 5b       	subi	r30, 0xB7	; 183
    610c:	ff 4f       	sbci	r31, 0xFF	; 255
    610e:	91 83       	std	Z+1, r25	; 0x01
    6110:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6112:	de 01       	movw	r26, r28
    6114:	a5 5b       	subi	r26, 0xB5	; 181
    6116:	bf 4f       	sbci	r27, 0xFF	; 255
    6118:	fe 01       	movw	r30, r28
    611a:	e5 5b       	subi	r30, 0xB5	; 181
    611c:	ff 4f       	sbci	r31, 0xFF	; 255
    611e:	80 81       	ld	r24, Z
    6120:	91 81       	ldd	r25, Z+1	; 0x01
    6122:	01 97       	sbiw	r24, 0x01	; 1
    6124:	11 96       	adiw	r26, 0x01	; 1
    6126:	9c 93       	st	X, r25
    6128:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    612a:	fe 01       	movw	r30, r28
    612c:	e5 5b       	subi	r30, 0xB5	; 181
    612e:	ff 4f       	sbci	r31, 0xFF	; 255
    6130:	80 81       	ld	r24, Z
    6132:	91 81       	ldd	r25, Z+1	; 0x01
    6134:	00 97       	sbiw	r24, 0x00	; 0
    6136:	d1 f6       	brne	.-76     	; 0x60ec <Task_2+0x5a6>
    6138:	15 cf       	rjmp	.-470    	; 0x5f64 <Task_2+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    613a:	8e 01       	movw	r16, r28
    613c:	05 5b       	subi	r16, 0xB5	; 181
    613e:	1f 4f       	sbci	r17, 0xFF	; 255
    6140:	fe 01       	movw	r30, r28
    6142:	e3 5b       	subi	r30, 0xB3	; 179
    6144:	ff 4f       	sbci	r31, 0xFF	; 255
    6146:	60 81       	ld	r22, Z
    6148:	71 81       	ldd	r23, Z+1	; 0x01
    614a:	82 81       	ldd	r24, Z+2	; 0x02
    614c:	93 81       	ldd	r25, Z+3	; 0x03
    614e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6152:	dc 01       	movw	r26, r24
    6154:	cb 01       	movw	r24, r22
    6156:	f8 01       	movw	r30, r16
    6158:	91 83       	std	Z+1, r25	; 0x01
    615a:	80 83       	st	Z, r24
    615c:	de 01       	movw	r26, r28
    615e:	a9 5b       	subi	r26, 0xB9	; 185
    6160:	bf 4f       	sbci	r27, 0xFF	; 255
    6162:	fe 01       	movw	r30, r28
    6164:	e5 5b       	subi	r30, 0xB5	; 181
    6166:	ff 4f       	sbci	r31, 0xFF	; 255
    6168:	80 81       	ld	r24, Z
    616a:	91 81       	ldd	r25, Z+1	; 0x01
    616c:	11 96       	adiw	r26, 0x01	; 1
    616e:	9c 93       	st	X, r25
    6170:	8e 93       	st	-X, r24
    6172:	fe 01       	movw	r30, r28
    6174:	e9 5b       	subi	r30, 0xB9	; 185
    6176:	ff 4f       	sbci	r31, 0xFF	; 255
    6178:	80 81       	ld	r24, Z
    617a:	91 81       	ldd	r25, Z+1	; 0x01
    617c:	01 97       	sbiw	r24, 0x01	; 1
    617e:	f1 f7       	brne	.-4      	; 0x617c <Task_2+0x636>
    6180:	fe 01       	movw	r30, r28
    6182:	e9 5b       	subi	r30, 0xB9	; 185
    6184:	ff 4f       	sbci	r31, 0xFF	; 255
    6186:	91 83       	std	Z+1, r25	; 0x01
    6188:	80 83       	st	Z, r24
    618a:	ec ce       	rjmp	.-552    	; 0x5f64 <Task_2+0x41e>

											//UART_SendStr(ON);   AND WRITE ON THE LCD  /* send status of LED i.e. LED ON */

					case '2': Led_OFF(LED0);  UART_SendStr(OFF1); LCD_ClearScreen_4bit(); LCD_WRITE_STRING_4bit(OFF1) ; _delay_ms(100);  break;
    618c:	80 e0       	ldi	r24, 0x00	; 0
    618e:	0e 94 e1 24 	call	0x49c2	; 0x49c2 <Led_OFF>
    6192:	ce 01       	movw	r24, r28
    6194:	8e 58       	subi	r24, 0x8E	; 142
    6196:	9f 4f       	sbci	r25, 0xFF	; 255
    6198:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
    619c:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <LCD_ClearScreen_4bit>
    61a0:	ce 01       	movw	r24, r28
    61a2:	8e 58       	subi	r24, 0x8E	; 142
    61a4:	9f 4f       	sbci	r25, 0xFF	; 255
    61a6:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
    61aa:	fe 01       	movw	r30, r28
    61ac:	ed 5b       	subi	r30, 0xBD	; 189
    61ae:	ff 4f       	sbci	r31, 0xFF	; 255
    61b0:	80 e0       	ldi	r24, 0x00	; 0
    61b2:	90 e0       	ldi	r25, 0x00	; 0
    61b4:	a8 ec       	ldi	r26, 0xC8	; 200
    61b6:	b2 e4       	ldi	r27, 0x42	; 66
    61b8:	80 83       	st	Z, r24
    61ba:	91 83       	std	Z+1, r25	; 0x01
    61bc:	a2 83       	std	Z+2, r26	; 0x02
    61be:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    61c0:	8e 01       	movw	r16, r28
    61c2:	01 5c       	subi	r16, 0xC1	; 193
    61c4:	1f 4f       	sbci	r17, 0xFF	; 255
    61c6:	fe 01       	movw	r30, r28
    61c8:	ed 5b       	subi	r30, 0xBD	; 189
    61ca:	ff 4f       	sbci	r31, 0xFF	; 255
    61cc:	60 81       	ld	r22, Z
    61ce:	71 81       	ldd	r23, Z+1	; 0x01
    61d0:	82 81       	ldd	r24, Z+2	; 0x02
    61d2:	93 81       	ldd	r25, Z+3	; 0x03
    61d4:	20 e0       	ldi	r18, 0x00	; 0
    61d6:	30 e0       	ldi	r19, 0x00	; 0
    61d8:	4a e7       	ldi	r20, 0x7A	; 122
    61da:	55 e4       	ldi	r21, 0x45	; 69
    61dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    61e0:	dc 01       	movw	r26, r24
    61e2:	cb 01       	movw	r24, r22
    61e4:	f8 01       	movw	r30, r16
    61e6:	80 83       	st	Z, r24
    61e8:	91 83       	std	Z+1, r25	; 0x01
    61ea:	a2 83       	std	Z+2, r26	; 0x02
    61ec:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    61ee:	fe 01       	movw	r30, r28
    61f0:	ff 96       	adiw	r30, 0x3f	; 63
    61f2:	60 81       	ld	r22, Z
    61f4:	71 81       	ldd	r23, Z+1	; 0x01
    61f6:	82 81       	ldd	r24, Z+2	; 0x02
    61f8:	93 81       	ldd	r25, Z+3	; 0x03
    61fa:	20 e0       	ldi	r18, 0x00	; 0
    61fc:	30 e0       	ldi	r19, 0x00	; 0
    61fe:	40 e8       	ldi	r20, 0x80	; 128
    6200:	5f e3       	ldi	r21, 0x3F	; 63
    6202:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    6206:	88 23       	and	r24, r24
    6208:	2c f4       	brge	.+10     	; 0x6214 <Task_2+0x6ce>
		__ticks = 1;
    620a:	81 e0       	ldi	r24, 0x01	; 1
    620c:	90 e0       	ldi	r25, 0x00	; 0
    620e:	9e af       	std	Y+62, r25	; 0x3e
    6210:	8d af       	std	Y+61, r24	; 0x3d
    6212:	46 c0       	rjmp	.+140    	; 0x62a0 <Task_2+0x75a>
	else if (__tmp > 65535)
    6214:	fe 01       	movw	r30, r28
    6216:	ff 96       	adiw	r30, 0x3f	; 63
    6218:	60 81       	ld	r22, Z
    621a:	71 81       	ldd	r23, Z+1	; 0x01
    621c:	82 81       	ldd	r24, Z+2	; 0x02
    621e:	93 81       	ldd	r25, Z+3	; 0x03
    6220:	20 e0       	ldi	r18, 0x00	; 0
    6222:	3f ef       	ldi	r19, 0xFF	; 255
    6224:	4f e7       	ldi	r20, 0x7F	; 127
    6226:	57 e4       	ldi	r21, 0x47	; 71
    6228:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    622c:	18 16       	cp	r1, r24
    622e:	64 f5       	brge	.+88     	; 0x6288 <Task_2+0x742>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6230:	fe 01       	movw	r30, r28
    6232:	ed 5b       	subi	r30, 0xBD	; 189
    6234:	ff 4f       	sbci	r31, 0xFF	; 255
    6236:	60 81       	ld	r22, Z
    6238:	71 81       	ldd	r23, Z+1	; 0x01
    623a:	82 81       	ldd	r24, Z+2	; 0x02
    623c:	93 81       	ldd	r25, Z+3	; 0x03
    623e:	20 e0       	ldi	r18, 0x00	; 0
    6240:	30 e0       	ldi	r19, 0x00	; 0
    6242:	40 e2       	ldi	r20, 0x20	; 32
    6244:	51 e4       	ldi	r21, 0x41	; 65
    6246:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    624a:	dc 01       	movw	r26, r24
    624c:	cb 01       	movw	r24, r22
    624e:	bc 01       	movw	r22, r24
    6250:	cd 01       	movw	r24, r26
    6252:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6256:	dc 01       	movw	r26, r24
    6258:	cb 01       	movw	r24, r22
    625a:	9e af       	std	Y+62, r25	; 0x3e
    625c:	8d af       	std	Y+61, r24	; 0x3d
    625e:	0f c0       	rjmp	.+30     	; 0x627e <Task_2+0x738>
    6260:	80 e9       	ldi	r24, 0x90	; 144
    6262:	91 e0       	ldi	r25, 0x01	; 1
    6264:	9c af       	std	Y+60, r25	; 0x3c
    6266:	8b af       	std	Y+59, r24	; 0x3b
    6268:	8b ad       	ldd	r24, Y+59	; 0x3b
    626a:	9c ad       	ldd	r25, Y+60	; 0x3c
    626c:	01 97       	sbiw	r24, 0x01	; 1
    626e:	f1 f7       	brne	.-4      	; 0x626c <Task_2+0x726>
    6270:	9c af       	std	Y+60, r25	; 0x3c
    6272:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6274:	8d ad       	ldd	r24, Y+61	; 0x3d
    6276:	9e ad       	ldd	r25, Y+62	; 0x3e
    6278:	01 97       	sbiw	r24, 0x01	; 1
    627a:	9e af       	std	Y+62, r25	; 0x3e
    627c:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    627e:	8d ad       	ldd	r24, Y+61	; 0x3d
    6280:	9e ad       	ldd	r25, Y+62	; 0x3e
    6282:	00 97       	sbiw	r24, 0x00	; 0
    6284:	69 f7       	brne	.-38     	; 0x6260 <Task_2+0x71a>
    6286:	6e ce       	rjmp	.-804    	; 0x5f64 <Task_2+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6288:	fe 01       	movw	r30, r28
    628a:	ff 96       	adiw	r30, 0x3f	; 63
    628c:	60 81       	ld	r22, Z
    628e:	71 81       	ldd	r23, Z+1	; 0x01
    6290:	82 81       	ldd	r24, Z+2	; 0x02
    6292:	93 81       	ldd	r25, Z+3	; 0x03
    6294:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6298:	dc 01       	movw	r26, r24
    629a:	cb 01       	movw	r24, r22
    629c:	9e af       	std	Y+62, r25	; 0x3e
    629e:	8d af       	std	Y+61, r24	; 0x3d
    62a0:	8d ad       	ldd	r24, Y+61	; 0x3d
    62a2:	9e ad       	ldd	r25, Y+62	; 0x3e
    62a4:	9a af       	std	Y+58, r25	; 0x3a
    62a6:	89 af       	std	Y+57, r24	; 0x39
    62a8:	89 ad       	ldd	r24, Y+57	; 0x39
    62aa:	9a ad       	ldd	r25, Y+58	; 0x3a
    62ac:	01 97       	sbiw	r24, 0x01	; 1
    62ae:	f1 f7       	brne	.-4      	; 0x62ac <Task_2+0x766>
    62b0:	9a af       	std	Y+58, r25	; 0x3a
    62b2:	89 af       	std	Y+57, r24	; 0x39
    62b4:	57 ce       	rjmp	.-850    	; 0x5f64 <Task_2+0x41e>


					case '3': Led_ON(LED1);   UART_SendStr(ON2);  LCD_ClearScreen_4bit(); LCD_WRITE_STRING_4bit(ON2) ;  _delay_ms(100);  break;   /* Turn ON LED */
    62b6:	81 e0       	ldi	r24, 0x01	; 1
    62b8:	0e 94 b0 24 	call	0x4960	; 0x4960 <Led_ON>
    62bc:	ce 01       	movw	r24, r28
    62be:	80 5a       	subi	r24, 0xA0	; 160
    62c0:	9f 4f       	sbci	r25, 0xFF	; 255
    62c2:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
    62c6:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <LCD_ClearScreen_4bit>
    62ca:	ce 01       	movw	r24, r28
    62cc:	80 5a       	subi	r24, 0xA0	; 160
    62ce:	9f 4f       	sbci	r25, 0xFF	; 255
    62d0:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
    62d4:	80 e0       	ldi	r24, 0x00	; 0
    62d6:	90 e0       	ldi	r25, 0x00	; 0
    62d8:	a8 ec       	ldi	r26, 0xC8	; 200
    62da:	b2 e4       	ldi	r27, 0x42	; 66
    62dc:	8d ab       	std	Y+53, r24	; 0x35
    62de:	9e ab       	std	Y+54, r25	; 0x36
    62e0:	af ab       	std	Y+55, r26	; 0x37
    62e2:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    62e4:	6d a9       	ldd	r22, Y+53	; 0x35
    62e6:	7e a9       	ldd	r23, Y+54	; 0x36
    62e8:	8f a9       	ldd	r24, Y+55	; 0x37
    62ea:	98 ad       	ldd	r25, Y+56	; 0x38
    62ec:	20 e0       	ldi	r18, 0x00	; 0
    62ee:	30 e0       	ldi	r19, 0x00	; 0
    62f0:	4a e7       	ldi	r20, 0x7A	; 122
    62f2:	55 e4       	ldi	r21, 0x45	; 69
    62f4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    62f8:	dc 01       	movw	r26, r24
    62fa:	cb 01       	movw	r24, r22
    62fc:	89 ab       	std	Y+49, r24	; 0x31
    62fe:	9a ab       	std	Y+50, r25	; 0x32
    6300:	ab ab       	std	Y+51, r26	; 0x33
    6302:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    6304:	69 a9       	ldd	r22, Y+49	; 0x31
    6306:	7a a9       	ldd	r23, Y+50	; 0x32
    6308:	8b a9       	ldd	r24, Y+51	; 0x33
    630a:	9c a9       	ldd	r25, Y+52	; 0x34
    630c:	20 e0       	ldi	r18, 0x00	; 0
    630e:	30 e0       	ldi	r19, 0x00	; 0
    6310:	40 e8       	ldi	r20, 0x80	; 128
    6312:	5f e3       	ldi	r21, 0x3F	; 63
    6314:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    6318:	88 23       	and	r24, r24
    631a:	2c f4       	brge	.+10     	; 0x6326 <Task_2+0x7e0>
		__ticks = 1;
    631c:	81 e0       	ldi	r24, 0x01	; 1
    631e:	90 e0       	ldi	r25, 0x00	; 0
    6320:	98 ab       	std	Y+48, r25	; 0x30
    6322:	8f a7       	std	Y+47, r24	; 0x2f
    6324:	3f c0       	rjmp	.+126    	; 0x63a4 <Task_2+0x85e>
	else if (__tmp > 65535)
    6326:	69 a9       	ldd	r22, Y+49	; 0x31
    6328:	7a a9       	ldd	r23, Y+50	; 0x32
    632a:	8b a9       	ldd	r24, Y+51	; 0x33
    632c:	9c a9       	ldd	r25, Y+52	; 0x34
    632e:	20 e0       	ldi	r18, 0x00	; 0
    6330:	3f ef       	ldi	r19, 0xFF	; 255
    6332:	4f e7       	ldi	r20, 0x7F	; 127
    6334:	57 e4       	ldi	r21, 0x47	; 71
    6336:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    633a:	18 16       	cp	r1, r24
    633c:	4c f5       	brge	.+82     	; 0x6390 <Task_2+0x84a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    633e:	6d a9       	ldd	r22, Y+53	; 0x35
    6340:	7e a9       	ldd	r23, Y+54	; 0x36
    6342:	8f a9       	ldd	r24, Y+55	; 0x37
    6344:	98 ad       	ldd	r25, Y+56	; 0x38
    6346:	20 e0       	ldi	r18, 0x00	; 0
    6348:	30 e0       	ldi	r19, 0x00	; 0
    634a:	40 e2       	ldi	r20, 0x20	; 32
    634c:	51 e4       	ldi	r21, 0x41	; 65
    634e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6352:	dc 01       	movw	r26, r24
    6354:	cb 01       	movw	r24, r22
    6356:	bc 01       	movw	r22, r24
    6358:	cd 01       	movw	r24, r26
    635a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    635e:	dc 01       	movw	r26, r24
    6360:	cb 01       	movw	r24, r22
    6362:	98 ab       	std	Y+48, r25	; 0x30
    6364:	8f a7       	std	Y+47, r24	; 0x2f
    6366:	0f c0       	rjmp	.+30     	; 0x6386 <Task_2+0x840>
    6368:	80 e9       	ldi	r24, 0x90	; 144
    636a:	91 e0       	ldi	r25, 0x01	; 1
    636c:	9e a7       	std	Y+46, r25	; 0x2e
    636e:	8d a7       	std	Y+45, r24	; 0x2d
    6370:	8d a5       	ldd	r24, Y+45	; 0x2d
    6372:	9e a5       	ldd	r25, Y+46	; 0x2e
    6374:	01 97       	sbiw	r24, 0x01	; 1
    6376:	f1 f7       	brne	.-4      	; 0x6374 <Task_2+0x82e>
    6378:	9e a7       	std	Y+46, r25	; 0x2e
    637a:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    637c:	8f a5       	ldd	r24, Y+47	; 0x2f
    637e:	98 a9       	ldd	r25, Y+48	; 0x30
    6380:	01 97       	sbiw	r24, 0x01	; 1
    6382:	98 ab       	std	Y+48, r25	; 0x30
    6384:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6386:	8f a5       	ldd	r24, Y+47	; 0x2f
    6388:	98 a9       	ldd	r25, Y+48	; 0x30
    638a:	00 97       	sbiw	r24, 0x00	; 0
    638c:	69 f7       	brne	.-38     	; 0x6368 <Task_2+0x822>
    638e:	ea cd       	rjmp	.-1068   	; 0x5f64 <Task_2+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6390:	69 a9       	ldd	r22, Y+49	; 0x31
    6392:	7a a9       	ldd	r23, Y+50	; 0x32
    6394:	8b a9       	ldd	r24, Y+51	; 0x33
    6396:	9c a9       	ldd	r25, Y+52	; 0x34
    6398:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    639c:	dc 01       	movw	r26, r24
    639e:	cb 01       	movw	r24, r22
    63a0:	98 ab       	std	Y+48, r25	; 0x30
    63a2:	8f a7       	std	Y+47, r24	; 0x2f
    63a4:	8f a5       	ldd	r24, Y+47	; 0x2f
    63a6:	98 a9       	ldd	r25, Y+48	; 0x30
    63a8:	9c a7       	std	Y+44, r25	; 0x2c
    63aa:	8b a7       	std	Y+43, r24	; 0x2b
    63ac:	8b a5       	ldd	r24, Y+43	; 0x2b
    63ae:	9c a5       	ldd	r25, Y+44	; 0x2c
    63b0:	01 97       	sbiw	r24, 0x01	; 1
    63b2:	f1 f7       	brne	.-4      	; 0x63b0 <Task_2+0x86a>
    63b4:	9c a7       	std	Y+44, r25	; 0x2c
    63b6:	8b a7       	std	Y+43, r24	; 0x2b
    63b8:	d5 cd       	rjmp	.-1110   	; 0x5f64 <Task_2+0x41e>
											//UART_SendStr(ON);  AND WRITE ON THE LCD  /* send status of LED i.e. LED ON */

					case '4': Led_OFF(LED1);  UART_SendStr(OFF2);  LCD_ClearScreen_4bit(); LCD_WRITE_STRING_4bit(OFF2) ; _delay_ms(100); break;
    63ba:	81 e0       	ldi	r24, 0x01	; 1
    63bc:	0e 94 e1 24 	call	0x49c2	; 0x49c2 <Led_OFF>
    63c0:	ce 01       	movw	r24, r28
    63c2:	84 58       	subi	r24, 0x84	; 132
    63c4:	9f 4f       	sbci	r25, 0xFF	; 255
    63c6:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
    63ca:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <LCD_ClearScreen_4bit>
    63ce:	ce 01       	movw	r24, r28
    63d0:	84 58       	subi	r24, 0x84	; 132
    63d2:	9f 4f       	sbci	r25, 0xFF	; 255
    63d4:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
    63d8:	80 e0       	ldi	r24, 0x00	; 0
    63da:	90 e0       	ldi	r25, 0x00	; 0
    63dc:	a8 ec       	ldi	r26, 0xC8	; 200
    63de:	b2 e4       	ldi	r27, 0x42	; 66
    63e0:	8f a3       	std	Y+39, r24	; 0x27
    63e2:	98 a7       	std	Y+40, r25	; 0x28
    63e4:	a9 a7       	std	Y+41, r26	; 0x29
    63e6:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    63e8:	6f a1       	ldd	r22, Y+39	; 0x27
    63ea:	78 a5       	ldd	r23, Y+40	; 0x28
    63ec:	89 a5       	ldd	r24, Y+41	; 0x29
    63ee:	9a a5       	ldd	r25, Y+42	; 0x2a
    63f0:	20 e0       	ldi	r18, 0x00	; 0
    63f2:	30 e0       	ldi	r19, 0x00	; 0
    63f4:	4a e7       	ldi	r20, 0x7A	; 122
    63f6:	55 e4       	ldi	r21, 0x45	; 69
    63f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    63fc:	dc 01       	movw	r26, r24
    63fe:	cb 01       	movw	r24, r22
    6400:	8b a3       	std	Y+35, r24	; 0x23
    6402:	9c a3       	std	Y+36, r25	; 0x24
    6404:	ad a3       	std	Y+37, r26	; 0x25
    6406:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    6408:	6b a1       	ldd	r22, Y+35	; 0x23
    640a:	7c a1       	ldd	r23, Y+36	; 0x24
    640c:	8d a1       	ldd	r24, Y+37	; 0x25
    640e:	9e a1       	ldd	r25, Y+38	; 0x26
    6410:	20 e0       	ldi	r18, 0x00	; 0
    6412:	30 e0       	ldi	r19, 0x00	; 0
    6414:	40 e8       	ldi	r20, 0x80	; 128
    6416:	5f e3       	ldi	r21, 0x3F	; 63
    6418:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    641c:	88 23       	and	r24, r24
    641e:	2c f4       	brge	.+10     	; 0x642a <Task_2+0x8e4>
		__ticks = 1;
    6420:	81 e0       	ldi	r24, 0x01	; 1
    6422:	90 e0       	ldi	r25, 0x00	; 0
    6424:	9a a3       	std	Y+34, r25	; 0x22
    6426:	89 a3       	std	Y+33, r24	; 0x21
    6428:	3f c0       	rjmp	.+126    	; 0x64a8 <Task_2+0x962>
	else if (__tmp > 65535)
    642a:	6b a1       	ldd	r22, Y+35	; 0x23
    642c:	7c a1       	ldd	r23, Y+36	; 0x24
    642e:	8d a1       	ldd	r24, Y+37	; 0x25
    6430:	9e a1       	ldd	r25, Y+38	; 0x26
    6432:	20 e0       	ldi	r18, 0x00	; 0
    6434:	3f ef       	ldi	r19, 0xFF	; 255
    6436:	4f e7       	ldi	r20, 0x7F	; 127
    6438:	57 e4       	ldi	r21, 0x47	; 71
    643a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    643e:	18 16       	cp	r1, r24
    6440:	4c f5       	brge	.+82     	; 0x6494 <Task_2+0x94e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6442:	6f a1       	ldd	r22, Y+39	; 0x27
    6444:	78 a5       	ldd	r23, Y+40	; 0x28
    6446:	89 a5       	ldd	r24, Y+41	; 0x29
    6448:	9a a5       	ldd	r25, Y+42	; 0x2a
    644a:	20 e0       	ldi	r18, 0x00	; 0
    644c:	30 e0       	ldi	r19, 0x00	; 0
    644e:	40 e2       	ldi	r20, 0x20	; 32
    6450:	51 e4       	ldi	r21, 0x41	; 65
    6452:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6456:	dc 01       	movw	r26, r24
    6458:	cb 01       	movw	r24, r22
    645a:	bc 01       	movw	r22, r24
    645c:	cd 01       	movw	r24, r26
    645e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6462:	dc 01       	movw	r26, r24
    6464:	cb 01       	movw	r24, r22
    6466:	9a a3       	std	Y+34, r25	; 0x22
    6468:	89 a3       	std	Y+33, r24	; 0x21
    646a:	0f c0       	rjmp	.+30     	; 0x648a <Task_2+0x944>
    646c:	80 e9       	ldi	r24, 0x90	; 144
    646e:	91 e0       	ldi	r25, 0x01	; 1
    6470:	98 a3       	std	Y+32, r25	; 0x20
    6472:	8f 8f       	std	Y+31, r24	; 0x1f
    6474:	8f 8d       	ldd	r24, Y+31	; 0x1f
    6476:	98 a1       	ldd	r25, Y+32	; 0x20
    6478:	01 97       	sbiw	r24, 0x01	; 1
    647a:	f1 f7       	brne	.-4      	; 0x6478 <Task_2+0x932>
    647c:	98 a3       	std	Y+32, r25	; 0x20
    647e:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6480:	89 a1       	ldd	r24, Y+33	; 0x21
    6482:	9a a1       	ldd	r25, Y+34	; 0x22
    6484:	01 97       	sbiw	r24, 0x01	; 1
    6486:	9a a3       	std	Y+34, r25	; 0x22
    6488:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    648a:	89 a1       	ldd	r24, Y+33	; 0x21
    648c:	9a a1       	ldd	r25, Y+34	; 0x22
    648e:	00 97       	sbiw	r24, 0x00	; 0
    6490:	69 f7       	brne	.-38     	; 0x646c <Task_2+0x926>
    6492:	68 cd       	rjmp	.-1328   	; 0x5f64 <Task_2+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6494:	6b a1       	ldd	r22, Y+35	; 0x23
    6496:	7c a1       	ldd	r23, Y+36	; 0x24
    6498:	8d a1       	ldd	r24, Y+37	; 0x25
    649a:	9e a1       	ldd	r25, Y+38	; 0x26
    649c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    64a0:	dc 01       	movw	r26, r24
    64a2:	cb 01       	movw	r24, r22
    64a4:	9a a3       	std	Y+34, r25	; 0x22
    64a6:	89 a3       	std	Y+33, r24	; 0x21
    64a8:	89 a1       	ldd	r24, Y+33	; 0x21
    64aa:	9a a1       	ldd	r25, Y+34	; 0x22
    64ac:	9e 8f       	std	Y+30, r25	; 0x1e
    64ae:	8d 8f       	std	Y+29, r24	; 0x1d
    64b0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    64b2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    64b4:	01 97       	sbiw	r24, 0x01	; 1
    64b6:	f1 f7       	brne	.-4      	; 0x64b4 <Task_2+0x96e>
    64b8:	9e 8f       	std	Y+30, r25	; 0x1e
    64ba:	8d 8f       	std	Y+29, r24	; 0x1d
    64bc:	53 cd       	rjmp	.-1370   	; 0x5f64 <Task_2+0x41e>


					case '5': Led_ON(LED2);   UART_SendStr(ON3);  LCD_ClearScreen_4bit(); LCD_WRITE_STRING_4bit(ON3) ;   _delay_ms(100);  break;   /* Turn ON LED */
    64be:	82 e0       	ldi	r24, 0x02	; 2
    64c0:	0e 94 b0 24 	call	0x4960	; 0x4960 <Led_ON>
    64c4:	ce 01       	movw	r24, r28
    64c6:	87 59       	subi	r24, 0x97	; 151
    64c8:	9f 4f       	sbci	r25, 0xFF	; 255
    64ca:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
    64ce:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <LCD_ClearScreen_4bit>
    64d2:	ce 01       	movw	r24, r28
    64d4:	87 59       	subi	r24, 0x97	; 151
    64d6:	9f 4f       	sbci	r25, 0xFF	; 255
    64d8:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
    64dc:	80 e0       	ldi	r24, 0x00	; 0
    64de:	90 e0       	ldi	r25, 0x00	; 0
    64e0:	a8 ec       	ldi	r26, 0xC8	; 200
    64e2:	b2 e4       	ldi	r27, 0x42	; 66
    64e4:	89 8f       	std	Y+25, r24	; 0x19
    64e6:	9a 8f       	std	Y+26, r25	; 0x1a
    64e8:	ab 8f       	std	Y+27, r26	; 0x1b
    64ea:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    64ec:	69 8d       	ldd	r22, Y+25	; 0x19
    64ee:	7a 8d       	ldd	r23, Y+26	; 0x1a
    64f0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    64f2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    64f4:	20 e0       	ldi	r18, 0x00	; 0
    64f6:	30 e0       	ldi	r19, 0x00	; 0
    64f8:	4a e7       	ldi	r20, 0x7A	; 122
    64fa:	55 e4       	ldi	r21, 0x45	; 69
    64fc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6500:	dc 01       	movw	r26, r24
    6502:	cb 01       	movw	r24, r22
    6504:	8d 8b       	std	Y+21, r24	; 0x15
    6506:	9e 8b       	std	Y+22, r25	; 0x16
    6508:	af 8b       	std	Y+23, r26	; 0x17
    650a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    650c:	6d 89       	ldd	r22, Y+21	; 0x15
    650e:	7e 89       	ldd	r23, Y+22	; 0x16
    6510:	8f 89       	ldd	r24, Y+23	; 0x17
    6512:	98 8d       	ldd	r25, Y+24	; 0x18
    6514:	20 e0       	ldi	r18, 0x00	; 0
    6516:	30 e0       	ldi	r19, 0x00	; 0
    6518:	40 e8       	ldi	r20, 0x80	; 128
    651a:	5f e3       	ldi	r21, 0x3F	; 63
    651c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    6520:	88 23       	and	r24, r24
    6522:	2c f4       	brge	.+10     	; 0x652e <Task_2+0x9e8>
		__ticks = 1;
    6524:	81 e0       	ldi	r24, 0x01	; 1
    6526:	90 e0       	ldi	r25, 0x00	; 0
    6528:	9c 8b       	std	Y+20, r25	; 0x14
    652a:	8b 8b       	std	Y+19, r24	; 0x13
    652c:	3f c0       	rjmp	.+126    	; 0x65ac <Task_2+0xa66>
	else if (__tmp > 65535)
    652e:	6d 89       	ldd	r22, Y+21	; 0x15
    6530:	7e 89       	ldd	r23, Y+22	; 0x16
    6532:	8f 89       	ldd	r24, Y+23	; 0x17
    6534:	98 8d       	ldd	r25, Y+24	; 0x18
    6536:	20 e0       	ldi	r18, 0x00	; 0
    6538:	3f ef       	ldi	r19, 0xFF	; 255
    653a:	4f e7       	ldi	r20, 0x7F	; 127
    653c:	57 e4       	ldi	r21, 0x47	; 71
    653e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    6542:	18 16       	cp	r1, r24
    6544:	4c f5       	brge	.+82     	; 0x6598 <Task_2+0xa52>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    6546:	69 8d       	ldd	r22, Y+25	; 0x19
    6548:	7a 8d       	ldd	r23, Y+26	; 0x1a
    654a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    654c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    654e:	20 e0       	ldi	r18, 0x00	; 0
    6550:	30 e0       	ldi	r19, 0x00	; 0
    6552:	40 e2       	ldi	r20, 0x20	; 32
    6554:	51 e4       	ldi	r21, 0x41	; 65
    6556:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    655a:	dc 01       	movw	r26, r24
    655c:	cb 01       	movw	r24, r22
    655e:	bc 01       	movw	r22, r24
    6560:	cd 01       	movw	r24, r26
    6562:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    6566:	dc 01       	movw	r26, r24
    6568:	cb 01       	movw	r24, r22
    656a:	9c 8b       	std	Y+20, r25	; 0x14
    656c:	8b 8b       	std	Y+19, r24	; 0x13
    656e:	0f c0       	rjmp	.+30     	; 0x658e <Task_2+0xa48>
    6570:	80 e9       	ldi	r24, 0x90	; 144
    6572:	91 e0       	ldi	r25, 0x01	; 1
    6574:	9a 8b       	std	Y+18, r25	; 0x12
    6576:	89 8b       	std	Y+17, r24	; 0x11
    6578:	89 89       	ldd	r24, Y+17	; 0x11
    657a:	9a 89       	ldd	r25, Y+18	; 0x12
    657c:	01 97       	sbiw	r24, 0x01	; 1
    657e:	f1 f7       	brne	.-4      	; 0x657c <Task_2+0xa36>
    6580:	9a 8b       	std	Y+18, r25	; 0x12
    6582:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6584:	8b 89       	ldd	r24, Y+19	; 0x13
    6586:	9c 89       	ldd	r25, Y+20	; 0x14
    6588:	01 97       	sbiw	r24, 0x01	; 1
    658a:	9c 8b       	std	Y+20, r25	; 0x14
    658c:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    658e:	8b 89       	ldd	r24, Y+19	; 0x13
    6590:	9c 89       	ldd	r25, Y+20	; 0x14
    6592:	00 97       	sbiw	r24, 0x00	; 0
    6594:	69 f7       	brne	.-38     	; 0x6570 <Task_2+0xa2a>
    6596:	e6 cc       	rjmp	.-1588   	; 0x5f64 <Task_2+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6598:	6d 89       	ldd	r22, Y+21	; 0x15
    659a:	7e 89       	ldd	r23, Y+22	; 0x16
    659c:	8f 89       	ldd	r24, Y+23	; 0x17
    659e:	98 8d       	ldd	r25, Y+24	; 0x18
    65a0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    65a4:	dc 01       	movw	r26, r24
    65a6:	cb 01       	movw	r24, r22
    65a8:	9c 8b       	std	Y+20, r25	; 0x14
    65aa:	8b 8b       	std	Y+19, r24	; 0x13
    65ac:	8b 89       	ldd	r24, Y+19	; 0x13
    65ae:	9c 89       	ldd	r25, Y+20	; 0x14
    65b0:	98 8b       	std	Y+16, r25	; 0x10
    65b2:	8f 87       	std	Y+15, r24	; 0x0f
    65b4:	8f 85       	ldd	r24, Y+15	; 0x0f
    65b6:	98 89       	ldd	r25, Y+16	; 0x10
    65b8:	01 97       	sbiw	r24, 0x01	; 1
    65ba:	f1 f7       	brne	.-4      	; 0x65b8 <Task_2+0xa72>
    65bc:	98 8b       	std	Y+16, r25	; 0x10
    65be:	8f 87       	std	Y+15, r24	; 0x0f
    65c0:	d1 cc       	rjmp	.-1630   	; 0x5f64 <Task_2+0x41e>

											//UART_SendStr(ON);   AND WRITE ON THE LCD /* send status of LED i.e. LED ON */
					case '6': Led_OFF(LED2);  UART_SendStr(OFF3);  LCD_ClearScreen_4bit(); LCD_WRITE_STRING_4bit(OFF3) ;  _delay_ms(100);  break;
    65c2:	82 e0       	ldi	r24, 0x02	; 2
    65c4:	0e 94 e1 24 	call	0x49c2	; 0x49c2 <Led_OFF>
    65c8:	ce 01       	movw	r24, r28
    65ca:	8a 57       	subi	r24, 0x7A	; 122
    65cc:	9f 4f       	sbci	r25, 0xFF	; 255
    65ce:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
    65d2:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <LCD_ClearScreen_4bit>
    65d6:	ce 01       	movw	r24, r28
    65d8:	8a 57       	subi	r24, 0x7A	; 122
    65da:	9f 4f       	sbci	r25, 0xFF	; 255
    65dc:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
    65e0:	80 e0       	ldi	r24, 0x00	; 0
    65e2:	90 e0       	ldi	r25, 0x00	; 0
    65e4:	a8 ec       	ldi	r26, 0xC8	; 200
    65e6:	b2 e4       	ldi	r27, 0x42	; 66
    65e8:	8b 87       	std	Y+11, r24	; 0x0b
    65ea:	9c 87       	std	Y+12, r25	; 0x0c
    65ec:	ad 87       	std	Y+13, r26	; 0x0d
    65ee:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    65f0:	6b 85       	ldd	r22, Y+11	; 0x0b
    65f2:	7c 85       	ldd	r23, Y+12	; 0x0c
    65f4:	8d 85       	ldd	r24, Y+13	; 0x0d
    65f6:	9e 85       	ldd	r25, Y+14	; 0x0e
    65f8:	20 e0       	ldi	r18, 0x00	; 0
    65fa:	30 e0       	ldi	r19, 0x00	; 0
    65fc:	4a e7       	ldi	r20, 0x7A	; 122
    65fe:	55 e4       	ldi	r21, 0x45	; 69
    6600:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6604:	dc 01       	movw	r26, r24
    6606:	cb 01       	movw	r24, r22
    6608:	8f 83       	std	Y+7, r24	; 0x07
    660a:	98 87       	std	Y+8, r25	; 0x08
    660c:	a9 87       	std	Y+9, r26	; 0x09
    660e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    6610:	6f 81       	ldd	r22, Y+7	; 0x07
    6612:	78 85       	ldd	r23, Y+8	; 0x08
    6614:	89 85       	ldd	r24, Y+9	; 0x09
    6616:	9a 85       	ldd	r25, Y+10	; 0x0a
    6618:	20 e0       	ldi	r18, 0x00	; 0
    661a:	30 e0       	ldi	r19, 0x00	; 0
    661c:	40 e8       	ldi	r20, 0x80	; 128
    661e:	5f e3       	ldi	r21, 0x3F	; 63
    6620:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    6624:	88 23       	and	r24, r24
    6626:	2c f4       	brge	.+10     	; 0x6632 <Task_2+0xaec>
		__ticks = 1;
    6628:	81 e0       	ldi	r24, 0x01	; 1
    662a:	90 e0       	ldi	r25, 0x00	; 0
    662c:	9e 83       	std	Y+6, r25	; 0x06
    662e:	8d 83       	std	Y+5, r24	; 0x05
    6630:	3f c0       	rjmp	.+126    	; 0x66b0 <Task_2+0xb6a>
	else if (__tmp > 65535)
    6632:	6f 81       	ldd	r22, Y+7	; 0x07
    6634:	78 85       	ldd	r23, Y+8	; 0x08
    6636:	89 85       	ldd	r24, Y+9	; 0x09
    6638:	9a 85       	ldd	r25, Y+10	; 0x0a
    663a:	20 e0       	ldi	r18, 0x00	; 0
    663c:	3f ef       	ldi	r19, 0xFF	; 255
    663e:	4f e7       	ldi	r20, 0x7F	; 127
    6640:	57 e4       	ldi	r21, 0x47	; 71
    6642:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    6646:	18 16       	cp	r1, r24
    6648:	4c f5       	brge	.+82     	; 0x669c <Task_2+0xb56>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    664a:	6b 85       	ldd	r22, Y+11	; 0x0b
    664c:	7c 85       	ldd	r23, Y+12	; 0x0c
    664e:	8d 85       	ldd	r24, Y+13	; 0x0d
    6650:	9e 85       	ldd	r25, Y+14	; 0x0e
    6652:	20 e0       	ldi	r18, 0x00	; 0
    6654:	30 e0       	ldi	r19, 0x00	; 0
    6656:	40 e2       	ldi	r20, 0x20	; 32
    6658:	51 e4       	ldi	r21, 0x41	; 65
    665a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    665e:	dc 01       	movw	r26, r24
    6660:	cb 01       	movw	r24, r22
    6662:	bc 01       	movw	r22, r24
    6664:	cd 01       	movw	r24, r26
    6666:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    666a:	dc 01       	movw	r26, r24
    666c:	cb 01       	movw	r24, r22
    666e:	9e 83       	std	Y+6, r25	; 0x06
    6670:	8d 83       	std	Y+5, r24	; 0x05
    6672:	0f c0       	rjmp	.+30     	; 0x6692 <Task_2+0xb4c>
    6674:	80 e9       	ldi	r24, 0x90	; 144
    6676:	91 e0       	ldi	r25, 0x01	; 1
    6678:	9c 83       	std	Y+4, r25	; 0x04
    667a:	8b 83       	std	Y+3, r24	; 0x03
    667c:	8b 81       	ldd	r24, Y+3	; 0x03
    667e:	9c 81       	ldd	r25, Y+4	; 0x04
    6680:	01 97       	sbiw	r24, 0x01	; 1
    6682:	f1 f7       	brne	.-4      	; 0x6680 <Task_2+0xb3a>
    6684:	9c 83       	std	Y+4, r25	; 0x04
    6686:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6688:	8d 81       	ldd	r24, Y+5	; 0x05
    668a:	9e 81       	ldd	r25, Y+6	; 0x06
    668c:	01 97       	sbiw	r24, 0x01	; 1
    668e:	9e 83       	std	Y+6, r25	; 0x06
    6690:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6692:	8d 81       	ldd	r24, Y+5	; 0x05
    6694:	9e 81       	ldd	r25, Y+6	; 0x06
    6696:	00 97       	sbiw	r24, 0x00	; 0
    6698:	69 f7       	brne	.-38     	; 0x6674 <Task_2+0xb2e>
    669a:	64 cc       	rjmp	.-1848   	; 0x5f64 <Task_2+0x41e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    669c:	6f 81       	ldd	r22, Y+7	; 0x07
    669e:	78 85       	ldd	r23, Y+8	; 0x08
    66a0:	89 85       	ldd	r24, Y+9	; 0x09
    66a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    66a4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    66a8:	dc 01       	movw	r26, r24
    66aa:	cb 01       	movw	r24, r22
    66ac:	9e 83       	std	Y+6, r25	; 0x06
    66ae:	8d 83       	std	Y+5, r24	; 0x05
    66b0:	8d 81       	ldd	r24, Y+5	; 0x05
    66b2:	9e 81       	ldd	r25, Y+6	; 0x06
    66b4:	9a 83       	std	Y+2, r25	; 0x02
    66b6:	89 83       	std	Y+1, r24	; 0x01
    66b8:	89 81       	ldd	r24, Y+1	; 0x01
    66ba:	9a 81       	ldd	r25, Y+2	; 0x02
    66bc:	01 97       	sbiw	r24, 0x01	; 1
    66be:	f1 f7       	brne	.-4      	; 0x66bc <Task_2+0xb76>
    66c0:	9a 83       	std	Y+2, r25	; 0x02
    66c2:	89 83       	std	Y+1, r24	; 0x01
    66c4:	4f cc       	rjmp	.-1890   	; 0x5f64 <Task_2+0x41e>

000066c6 <main>:
		vTaskDelay(100);
	}
}
*/
int main(void)
{
    66c6:	af 92       	push	r10
    66c8:	bf 92       	push	r11
    66ca:	cf 92       	push	r12
    66cc:	df 92       	push	r13
    66ce:	ef 92       	push	r14
    66d0:	ff 92       	push	r15
    66d2:	0f 93       	push	r16
    66d4:	df 93       	push	r29
    66d6:	cf 93       	push	r28
    66d8:	cd b7       	in	r28, 0x3d	; 61
    66da:	de b7       	in	r29, 0x3e	; 62
    66dc:	e8 97       	sbiw	r28, 0x38	; 56
    66de:	0f b6       	in	r0, 0x3f	; 63
    66e0:	f8 94       	cli
    66e2:	de bf       	out	0x3e, r29	; 62
    66e4:	0f be       	out	0x3f, r0	; 63
    66e6:	cd bf       	out	0x3d, r28	; 61
	uint_8 name[]="   SMART HOME";
    66e8:	ce 01       	movw	r24, r28
    66ea:	41 96       	adiw	r24, 0x11	; 17
    66ec:	98 ab       	std	Y+48, r25	; 0x30
    66ee:	8f a7       	std	Y+47, r24	; 0x2f
    66f0:	ea ef       	ldi	r30, 0xFA	; 250
    66f2:	f0 e0       	ldi	r31, 0x00	; 0
    66f4:	fa ab       	std	Y+50, r31	; 0x32
    66f6:	e9 ab       	std	Y+49, r30	; 0x31
    66f8:	fe e0       	ldi	r31, 0x0E	; 14
    66fa:	fb ab       	std	Y+51, r31	; 0x33
    66fc:	e9 a9       	ldd	r30, Y+49	; 0x31
    66fe:	fa a9       	ldd	r31, Y+50	; 0x32
    6700:	00 80       	ld	r0, Z
    6702:	89 a9       	ldd	r24, Y+49	; 0x31
    6704:	9a a9       	ldd	r25, Y+50	; 0x32
    6706:	01 96       	adiw	r24, 0x01	; 1
    6708:	9a ab       	std	Y+50, r25	; 0x32
    670a:	89 ab       	std	Y+49, r24	; 0x31
    670c:	ef a5       	ldd	r30, Y+47	; 0x2f
    670e:	f8 a9       	ldd	r31, Y+48	; 0x30
    6710:	00 82       	st	Z, r0
    6712:	8f a5       	ldd	r24, Y+47	; 0x2f
    6714:	98 a9       	ldd	r25, Y+48	; 0x30
    6716:	01 96       	adiw	r24, 0x01	; 1
    6718:	98 ab       	std	Y+48, r25	; 0x30
    671a:	8f a7       	std	Y+47, r24	; 0x2f
    671c:	9b a9       	ldd	r25, Y+51	; 0x33
    671e:	91 50       	subi	r25, 0x01	; 1
    6720:	9b ab       	std	Y+51, r25	; 0x33
    6722:	eb a9       	ldd	r30, Y+51	; 0x33
    6724:	ee 23       	and	r30, r30
    6726:	51 f7       	brne	.-44     	; 0x66fc <main+0x36>
	uint_8 name2[]="ENG ESLAM FAYAD";
    6728:	ce 01       	movw	r24, r28
    672a:	4f 96       	adiw	r24, 0x1f	; 31
    672c:	9d ab       	std	Y+53, r25	; 0x35
    672e:	8c ab       	std	Y+52, r24	; 0x34
    6730:	e8 e0       	ldi	r30, 0x08	; 8
    6732:	f1 e0       	ldi	r31, 0x01	; 1
    6734:	ff ab       	std	Y+55, r31	; 0x37
    6736:	ee ab       	std	Y+54, r30	; 0x36
    6738:	f0 e1       	ldi	r31, 0x10	; 16
    673a:	f8 af       	std	Y+56, r31	; 0x38
    673c:	ee a9       	ldd	r30, Y+54	; 0x36
    673e:	ff a9       	ldd	r31, Y+55	; 0x37
    6740:	00 80       	ld	r0, Z
    6742:	8e a9       	ldd	r24, Y+54	; 0x36
    6744:	9f a9       	ldd	r25, Y+55	; 0x37
    6746:	01 96       	adiw	r24, 0x01	; 1
    6748:	9f ab       	std	Y+55, r25	; 0x37
    674a:	8e ab       	std	Y+54, r24	; 0x36
    674c:	ec a9       	ldd	r30, Y+52	; 0x34
    674e:	fd a9       	ldd	r31, Y+53	; 0x35
    6750:	00 82       	st	Z, r0
    6752:	8c a9       	ldd	r24, Y+52	; 0x34
    6754:	9d a9       	ldd	r25, Y+53	; 0x35
    6756:	01 96       	adiw	r24, 0x01	; 1
    6758:	9d ab       	std	Y+53, r25	; 0x35
    675a:	8c ab       	std	Y+52, r24	; 0x34
    675c:	98 ad       	ldd	r25, Y+56	; 0x38
    675e:	91 50       	subi	r25, 0x01	; 1
    6760:	98 af       	std	Y+56, r25	; 0x38
    6762:	e8 ad       	ldd	r30, Y+56	; 0x38
    6764:	ee 23       	and	r30, r30
    6766:	51 f7       	brne	.-44     	; 0x673c <main+0x76>


	UART_Init(UART_BAUDRATE_9600);
    6768:	87 e6       	ldi	r24, 0x67	; 103
    676a:	90 e0       	ldi	r25, 0x00	; 0
    676c:	0e 94 cd 1d 	call	0x3b9a	; 0x3b9a <UART_Init>
	Spi_SlaveInit();
    6770:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <Spi_SlaveInit>
	Led_Init();
    6774:	0e 94 9a 24 	call	0x4934	; 0x4934 <Led_Init>
    LCD_Init_4bit();
    6778:	0e 94 2b 28 	call	0x5056	; 0x5056 <LCD_Init_4bit>
	LCD_WRITE_STRING_4bit(name);
    677c:	ce 01       	movw	r24, r28
    677e:	41 96       	adiw	r24, 0x11	; 17
    6780:	0e 94 0e 2d 	call	0x5a1c	; 0x5a1c <LCD_WRITE_STRING_4bit>
	LCD_SendStringRowCol(1,1,name2);
    6784:	9e 01       	movw	r18, r28
    6786:	21 5e       	subi	r18, 0xE1	; 225
    6788:	3f 4f       	sbci	r19, 0xFF	; 255
    678a:	81 e0       	ldi	r24, 0x01	; 1
    678c:	61 e0       	ldi	r22, 0x01	; 1
    678e:	a9 01       	movw	r20, r18
    6790:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <LCD_SendStringRowCol>
    6794:	80 e0       	ldi	r24, 0x00	; 0
    6796:	90 e0       	ldi	r25, 0x00	; 0
    6798:	a8 ec       	ldi	r26, 0xC8	; 200
    679a:	b2 e4       	ldi	r27, 0x42	; 66
    679c:	8b 87       	std	Y+11, r24	; 0x0b
    679e:	9c 87       	std	Y+12, r25	; 0x0c
    67a0:	ad 87       	std	Y+13, r26	; 0x0d
    67a2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    67a4:	6b 85       	ldd	r22, Y+11	; 0x0b
    67a6:	7c 85       	ldd	r23, Y+12	; 0x0c
    67a8:	8d 85       	ldd	r24, Y+13	; 0x0d
    67aa:	9e 85       	ldd	r25, Y+14	; 0x0e
    67ac:	20 e0       	ldi	r18, 0x00	; 0
    67ae:	30 e0       	ldi	r19, 0x00	; 0
    67b0:	4a e7       	ldi	r20, 0x7A	; 122
    67b2:	55 e4       	ldi	r21, 0x45	; 69
    67b4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    67b8:	dc 01       	movw	r26, r24
    67ba:	cb 01       	movw	r24, r22
    67bc:	8f 83       	std	Y+7, r24	; 0x07
    67be:	98 87       	std	Y+8, r25	; 0x08
    67c0:	a9 87       	std	Y+9, r26	; 0x09
    67c2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    67c4:	6f 81       	ldd	r22, Y+7	; 0x07
    67c6:	78 85       	ldd	r23, Y+8	; 0x08
    67c8:	89 85       	ldd	r24, Y+9	; 0x09
    67ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    67cc:	20 e0       	ldi	r18, 0x00	; 0
    67ce:	30 e0       	ldi	r19, 0x00	; 0
    67d0:	40 e8       	ldi	r20, 0x80	; 128
    67d2:	5f e3       	ldi	r21, 0x3F	; 63
    67d4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    67d8:	88 23       	and	r24, r24
    67da:	2c f4       	brge	.+10     	; 0x67e6 <main+0x120>
		__ticks = 1;
    67dc:	81 e0       	ldi	r24, 0x01	; 1
    67de:	90 e0       	ldi	r25, 0x00	; 0
    67e0:	9e 83       	std	Y+6, r25	; 0x06
    67e2:	8d 83       	std	Y+5, r24	; 0x05
    67e4:	3f c0       	rjmp	.+126    	; 0x6864 <main+0x19e>
	else if (__tmp > 65535)
    67e6:	6f 81       	ldd	r22, Y+7	; 0x07
    67e8:	78 85       	ldd	r23, Y+8	; 0x08
    67ea:	89 85       	ldd	r24, Y+9	; 0x09
    67ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    67ee:	20 e0       	ldi	r18, 0x00	; 0
    67f0:	3f ef       	ldi	r19, 0xFF	; 255
    67f2:	4f e7       	ldi	r20, 0x7F	; 127
    67f4:	57 e4       	ldi	r21, 0x47	; 71
    67f6:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    67fa:	18 16       	cp	r1, r24
    67fc:	4c f5       	brge	.+82     	; 0x6850 <main+0x18a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    67fe:	6b 85       	ldd	r22, Y+11	; 0x0b
    6800:	7c 85       	ldd	r23, Y+12	; 0x0c
    6802:	8d 85       	ldd	r24, Y+13	; 0x0d
    6804:	9e 85       	ldd	r25, Y+14	; 0x0e
    6806:	20 e0       	ldi	r18, 0x00	; 0
    6808:	30 e0       	ldi	r19, 0x00	; 0
    680a:	40 e2       	ldi	r20, 0x20	; 32
    680c:	51 e4       	ldi	r21, 0x41	; 65
    680e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6812:	dc 01       	movw	r26, r24
    6814:	cb 01       	movw	r24, r22
    6816:	bc 01       	movw	r22, r24
    6818:	cd 01       	movw	r24, r26
    681a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    681e:	dc 01       	movw	r26, r24
    6820:	cb 01       	movw	r24, r22
    6822:	9e 83       	std	Y+6, r25	; 0x06
    6824:	8d 83       	std	Y+5, r24	; 0x05
    6826:	0f c0       	rjmp	.+30     	; 0x6846 <main+0x180>
    6828:	80 e9       	ldi	r24, 0x90	; 144
    682a:	91 e0       	ldi	r25, 0x01	; 1
    682c:	9c 83       	std	Y+4, r25	; 0x04
    682e:	8b 83       	std	Y+3, r24	; 0x03
    6830:	8b 81       	ldd	r24, Y+3	; 0x03
    6832:	9c 81       	ldd	r25, Y+4	; 0x04
    6834:	01 97       	sbiw	r24, 0x01	; 1
    6836:	f1 f7       	brne	.-4      	; 0x6834 <main+0x16e>
    6838:	9c 83       	std	Y+4, r25	; 0x04
    683a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    683c:	8d 81       	ldd	r24, Y+5	; 0x05
    683e:	9e 81       	ldd	r25, Y+6	; 0x06
    6840:	01 97       	sbiw	r24, 0x01	; 1
    6842:	9e 83       	std	Y+6, r25	; 0x06
    6844:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6846:	8d 81       	ldd	r24, Y+5	; 0x05
    6848:	9e 81       	ldd	r25, Y+6	; 0x06
    684a:	00 97       	sbiw	r24, 0x00	; 0
    684c:	69 f7       	brne	.-38     	; 0x6828 <main+0x162>
    684e:	14 c0       	rjmp	.+40     	; 0x6878 <main+0x1b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6850:	6f 81       	ldd	r22, Y+7	; 0x07
    6852:	78 85       	ldd	r23, Y+8	; 0x08
    6854:	89 85       	ldd	r24, Y+9	; 0x09
    6856:	9a 85       	ldd	r25, Y+10	; 0x0a
    6858:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    685c:	dc 01       	movw	r26, r24
    685e:	cb 01       	movw	r24, r22
    6860:	9e 83       	std	Y+6, r25	; 0x06
    6862:	8d 83       	std	Y+5, r24	; 0x05
    6864:	8d 81       	ldd	r24, Y+5	; 0x05
    6866:	9e 81       	ldd	r25, Y+6	; 0x06
    6868:	9a 83       	std	Y+2, r25	; 0x02
    686a:	89 83       	std	Y+1, r24	; 0x01
    686c:	89 81       	ldd	r24, Y+1	; 0x01
    686e:	9a 81       	ldd	r25, Y+2	; 0x02
    6870:	01 97       	sbiw	r24, 0x01	; 1
    6872:	f1 f7       	brne	.-4      	; 0x6870 <main+0x1aa>
    6874:	9a 83       	std	Y+2, r25	; 0x02
    6876:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(100);
	TaskHandle_t xHandle = NULL;
    6878:	18 8a       	std	Y+16, r1	; 0x10
    687a:	1f 86       	std	Y+15, r1	; 0x0f
	UART_SendStr("Hello...! RTOS is Running");
    687c:	82 ed       	ldi	r24, 0xD2	; 210
    687e:	90 e0       	ldi	r25, 0x00	; 0
    6880:	0e 94 10 1e 	call	0x3c20	; 0x3c20 <UART_SendStr>
	xTaskCreate(Task_1,"Task 1",100,(uint_8*)pcTextForTask1, 1, NULL);
    6884:	e0 91 20 01 	lds	r30, 0x0120
    6888:	f0 91 21 01 	lds	r31, 0x0121
    688c:	8e e8       	ldi	r24, 0x8E	; 142
    688e:	9d e2       	ldi	r25, 0x2D	; 45
    6890:	2c ee       	ldi	r18, 0xEC	; 236
    6892:	30 e0       	ldi	r19, 0x00	; 0
    6894:	b9 01       	movw	r22, r18
    6896:	44 e6       	ldi	r20, 0x64	; 100
    6898:	50 e0       	ldi	r21, 0x00	; 0
    689a:	9f 01       	movw	r18, r30
    689c:	01 e0       	ldi	r16, 0x01	; 1
    689e:	ee 24       	eor	r14, r14
    68a0:	ff 24       	eor	r15, r15
    68a2:	cc 24       	eor	r12, r12
    68a4:	dd 24       	eor	r13, r13
    68a6:	aa 24       	eor	r10, r10
    68a8:	bb 24       	eor	r11, r11
    68aa:	0e 94 e5 11 	call	0x23ca	; 0x23ca <xTaskGenericCreate>
	xTaskCreate(Task_2, "Task 2",100, (uint_8*)pcTextForTask2, 2, NULL);
    68ae:	e0 91 22 01 	lds	r30, 0x0122
    68b2:	f0 91 23 01 	lds	r31, 0x0123
    68b6:	83 ea       	ldi	r24, 0xA3	; 163
    68b8:	9d e2       	ldi	r25, 0x2D	; 45
    68ba:	23 ef       	ldi	r18, 0xF3	; 243
    68bc:	30 e0       	ldi	r19, 0x00	; 0
    68be:	b9 01       	movw	r22, r18
    68c0:	44 e6       	ldi	r20, 0x64	; 100
    68c2:	50 e0       	ldi	r21, 0x00	; 0
    68c4:	9f 01       	movw	r18, r30
    68c6:	02 e0       	ldi	r16, 0x02	; 2
    68c8:	ee 24       	eor	r14, r14
    68ca:	ff 24       	eor	r15, r15
    68cc:	cc 24       	eor	r12, r12
    68ce:	dd 24       	eor	r13, r13
    68d0:	aa 24       	eor	r10, r10
    68d2:	bb 24       	eor	r11, r11
    68d4:	0e 94 e5 11 	call	0x23ca	; 0x23ca <xTaskGenericCreate>
	//xTaskCreate(Task_3, "Task 3",100, (uint_8*)pcTextForTask2, 3, NULL);
	 vTaskStartScheduler();
    68d8:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <vTaskStartScheduler>
    68dc:	ff cf       	rjmp	.-2      	; 0x68dc <main+0x216>

000068de <__prologue_saves__>:
    68de:	2f 92       	push	r2
    68e0:	3f 92       	push	r3
    68e2:	4f 92       	push	r4
    68e4:	5f 92       	push	r5
    68e6:	6f 92       	push	r6
    68e8:	7f 92       	push	r7
    68ea:	8f 92       	push	r8
    68ec:	9f 92       	push	r9
    68ee:	af 92       	push	r10
    68f0:	bf 92       	push	r11
    68f2:	cf 92       	push	r12
    68f4:	df 92       	push	r13
    68f6:	ef 92       	push	r14
    68f8:	ff 92       	push	r15
    68fa:	0f 93       	push	r16
    68fc:	1f 93       	push	r17
    68fe:	cf 93       	push	r28
    6900:	df 93       	push	r29
    6902:	cd b7       	in	r28, 0x3d	; 61
    6904:	de b7       	in	r29, 0x3e	; 62
    6906:	ca 1b       	sub	r28, r26
    6908:	db 0b       	sbc	r29, r27
    690a:	0f b6       	in	r0, 0x3f	; 63
    690c:	f8 94       	cli
    690e:	de bf       	out	0x3e, r29	; 62
    6910:	0f be       	out	0x3f, r0	; 63
    6912:	cd bf       	out	0x3d, r28	; 61
    6914:	09 94       	ijmp

00006916 <__epilogue_restores__>:
    6916:	2a 88       	ldd	r2, Y+18	; 0x12
    6918:	39 88       	ldd	r3, Y+17	; 0x11
    691a:	48 88       	ldd	r4, Y+16	; 0x10
    691c:	5f 84       	ldd	r5, Y+15	; 0x0f
    691e:	6e 84       	ldd	r6, Y+14	; 0x0e
    6920:	7d 84       	ldd	r7, Y+13	; 0x0d
    6922:	8c 84       	ldd	r8, Y+12	; 0x0c
    6924:	9b 84       	ldd	r9, Y+11	; 0x0b
    6926:	aa 84       	ldd	r10, Y+10	; 0x0a
    6928:	b9 84       	ldd	r11, Y+9	; 0x09
    692a:	c8 84       	ldd	r12, Y+8	; 0x08
    692c:	df 80       	ldd	r13, Y+7	; 0x07
    692e:	ee 80       	ldd	r14, Y+6	; 0x06
    6930:	fd 80       	ldd	r15, Y+5	; 0x05
    6932:	0c 81       	ldd	r16, Y+4	; 0x04
    6934:	1b 81       	ldd	r17, Y+3	; 0x03
    6936:	aa 81       	ldd	r26, Y+2	; 0x02
    6938:	b9 81       	ldd	r27, Y+1	; 0x01
    693a:	ce 0f       	add	r28, r30
    693c:	d1 1d       	adc	r29, r1
    693e:	0f b6       	in	r0, 0x3f	; 63
    6940:	f8 94       	cli
    6942:	de bf       	out	0x3e, r29	; 62
    6944:	0f be       	out	0x3f, r0	; 63
    6946:	cd bf       	out	0x3d, r28	; 61
    6948:	ed 01       	movw	r28, r26
    694a:	08 95       	ret

0000694c <memcpy>:
    694c:	fb 01       	movw	r30, r22
    694e:	dc 01       	movw	r26, r24
    6950:	02 c0       	rjmp	.+4      	; 0x6956 <memcpy+0xa>
    6952:	01 90       	ld	r0, Z+
    6954:	0d 92       	st	X+, r0
    6956:	41 50       	subi	r20, 0x01	; 1
    6958:	50 40       	sbci	r21, 0x00	; 0
    695a:	d8 f7       	brcc	.-10     	; 0x6952 <memcpy+0x6>
    695c:	08 95       	ret

0000695e <_exit>:
    695e:	f8 94       	cli

00006960 <__stop_program>:
    6960:	ff cf       	rjmp	.-2      	; 0x6960 <__stop_program>
